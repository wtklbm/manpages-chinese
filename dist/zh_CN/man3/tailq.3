.\" -*- coding: UTF-8 -*-
.\" Copyright (c) 1993
.\"    The Regents of the University of California.  All rights reserved.
.\" and Copyright (c) 2020 by Alejandro Colomar <alx@kernel.org>
.\"
.\" SPDX-License-Identifier: BSD-3-Clause
.\"
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH TAILQ 3 2022\-10\-30 "Linux man\-pages 6.03" 
.SH NAME
.\"TAILQ_FOREACH_FROM,
.\"TAILQ_FOREACH_FROM_SAFE,
.\"TAILQ_FOREACH_REVERSE_FROM,
.\"TAILQ_FOREACH_REVERSE_FROM_SAFE,
.\"TAILQ_FOREACH_REVERSE_SAFE,
.\"TAILQ_FOREACH_SAFE,
.\"TAILQ_SWAP
TAILQ_CONCAT, TAILQ_EMPTY, TAILQ_ENTRY, TAILQ_FIRST, TAILQ_FOREACH,
TAILQ_FOREACH_REVERSE, TAILQ_HEAD, TAILQ_HEAD_INITIALIZER, TAILQ_INIT,
TAILQ_INSERT_AFTER, TAILQ_INSERT_BEFORE, TAILQ_INSERT_HEAD,
TAILQ_INSERT_TAIL, TAILQ_LAST, TAILQ_NEXT, TAILQ_PREV, TAILQ_REMOVE \-
implementation of a doubly linked tail queue
.SH LIBRARY
标准 C 库 (\fIlibc\fP、\fI\-lc\fP)
.SH SYNOPSIS
.nf
\fB#include <sys/queue.h>\fP
.PP
\fBTAILQ_ENTRY(TYPE);\fP
.PP
\fBTAILQ_HEAD(HEADNAME, TYPE);\fP
\fBTAILQ_HEAD TAILQ_HEAD_INITIALIZER(TAILQ_HEAD \fP\fIhead\fP\fB);\fP
\fBvoid TAILQ_INIT(TAILQ_HEAD *\fP\fIhead\fP\fB);\fP
.PP
\fBint TAILQ_EMPTY(TAILQ_HEAD *\fP\fIhead\fP\fB);\fP
.PP
\fBvoid TAILQ_INSERT_HEAD(TAILQ_HEAD *\fP\fIhead\fP\fB,\fP
\fB                         struct TYPE *\fP\fIelm\fP\fB, TAILQ_ENTRY \fP\fINAME\fP\fB);\fP   
\fBvoid TAILQ_INSERT_TAIL(TAILQ_HEAD *\fP\fIhead\fP\fB,\fP
\fB                         struct TYPE *\fP\fIelm\fP\fB, TAILQ_ENTRY \fP\fINAME\fP\fB);\fP
\fBvoid TAILQ_INSERT_BEFORE(struct TYPE *\fP\fIlistelm\fP\fB,\fP
\fB                         struct TYPE *\fP\fIelm\fP\fB, TAILQ_ENTRY \fP\fINAME\fP\fB);\fP
\fBvoid TAILQ_INSERT_AFTER(TAILQ_HEAD *\fP\fIhead\fP\fB, struct TYPE *\fP\fIlistelm\fP\fB,\fP
\fB                         struct TYPE *\fP\fIelm\fP\fB, TAILQ_ENTRY \fP\fINAME\fP\fB);\fP
.PP
\fBstruct TYPE *TAILQ_FIRST(TAILQ_HEAD *\fP\fIhead\fP\fB);\fP
\fBstruct TYPE *TAILQ_LAST(TAILQ_HEAD *\fP\fIhead\fP\fB, 头名);\fP
\fBstruct TYPE *TAILQ_PREV(struct TYPE *\fP\fIelm\fP\fB，头名，TAILQ_ENTRY \fP\fINAME\fP\fB);\fP
\fBstruct TYPE *TAILQ_NEXT(struct TYPE *\fP\fIelm\fP\fB, TAILQ_ENTRY \fP\fINAME\fP\fB);\fP
.PP
.\" .BI "TAILQ_FOREACH_FROM(struct TYPE *" var ", TAILQ_HEAD *" head ,
.\" .BI "                                TAILQ_ENTRY " NAME );
.\" .BI "TAILQ_FOREACH_REVERSE_FROM(struct TYPE *" var ", TAILQ_HEAD *" head ", HEADNAME,"
.\" .BI "                                TAILQ_ENTRY " NAME );
.\" .PP
.\" .BI "TAILQ_FOREACH_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ,
.\" .BI "                                TAILQ_ENTRY " NAME ,
.\" .BI "                                struct TYPE *" temp_var );
.\" .BI "TAILQ_FOREACH_FROM_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ,
.\" .BI "                                TAILQ_ENTRY " NAME ,
.\" .BI "                                struct TYPE *" temp_var );
.\" .BI "TAILQ_FOREACH_REVERSE_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ,
.\" .BI "                                HEADNAME, TAILQ_ENTRY " NAME ,
.\" .BI "                                struct TYPE *" temp_var );
.\" .BI "TAILQ_FOREACH_REVERSE_FROM_SAFE(struct TYPE *" var ", TAILQ_HEAD *" head ,
.\" .BI "                                HEADNAME, TAILQ_ENTRY " NAME ,
.\" .BI "                                struct TYPE *" temp_var );
\fBTAILQ_FOREACH(struct TYPE *\fP\fIvar\fP\fB, TAILQ_HEAD *\fP\fIhead\fP\fB,\fP
\fB                         TAILQ_ENTRY \fP\fINAME\fP\fB);\fP
\fBTAILQ_FOREACH_REVERSE(struct TYPE *\fP\fIvar\fP\fB, TAILQ_HEAD *\fP\fIhead\fP\fB, HEADNAME,\fP
\fB                         TAILQ_ENTRY \fP\fINAME\fP\fB);\fP
.PP
\fBvoid TAILQ_REMOVE(TAILQ_HEAD *\fP\fIhead\fP\fB, struct TYPE *\fP\fIelm\fP\fB,\fP
\fB                         TAILQ_ENTRY \fP\fINAME\fP\fB);\fP
.PP
.\" .BI "void TAILQ_SWAP(TAILQ_HEAD *" head1 ", TAILQ_HEAD *" head2 ", TYPE,"
.\" .BI "                                TAILQ_ENTRY " NAME );
\fBvoid TAILQ_CONCAT(TAILQ_HEAD *\fP\fIhead1\fP\fB, TAILQ_HEAD *\fP\fIhead2\fP\fB,\fP
\fB                         TAILQ_ENTRY \fP\fINAME\fP\fB);\fP
.fi
.SH DESCRIPTION
这些宏定义并操作双向链接的尾队列。
.PP
在宏定义中，\fITYPE\fP 是用户定义的结构体的名称，它必须包含一个 \fITAILQ_ENTRY\fP 类型的字段，名为 \fINAME\fP。 参数
\fIHEADNAME\fP 是必须使用宏 \fBTAILQ_HEAD\fP() 声明的用户定义结构体的名称。
.SS Creation
尾队列由 \fBTAILQ_HEAD\fP() 宏定义的结构体领导。 这个结构体包含一对指针，一个指向队列中的第一个元素，另一个指向队列中的最后一个元素。
这些元素是双向链接的，因此可以在不遍历队列的情况下删除任意元素。 可以在现有元素之后、现有元素之前、队列头部或队列末尾将新元素添加到队列中。
\fITAILQ_HEAD\fP 结构体声明如下:
.PP
.in +4
.EX
TAILQ_HEAD(HEADNAME, TYPE) 头;
.EE
.in
.PP
其中 \fIstruct HEADNAME\fP 是要定义的结构体，\fIstruct TYPE\fP 是要链接到队列中的元素的类型。
指向队列头部的指针稍后可以声明为:
.PP
.in +4
.EX
struct HEADNAME *headp;
.EE
.in
.PP
(名称 \fIhead\fP 和 \fIheadp\fP 可由用户选择。)
.PP
\fBTAILQ_ENTRY\fP() 声明了一个连接队列中元素的结构体。
.PP
\fBTAILQ_HEAD_INITIALIZER\fP() 的计算结果为队列 \fIhead\fP 的初始化。
.PP
\fBTAILQ_INIT\fP() 初始化引用的队列
.PP
如果队列中没有项，则 \fBTAILQ_EMPTY\fP() 的计算结果为真。 \fIhead\fP.
.SS Insertion
\fBTAILQ_INSERT_HEAD\fP() 将新元素 \fIelm\fP 插入队列的头部。
.PP
\fBTAILQ_INSERT_TAIL\fP() 在队列末尾插入新元素 \fIelm\fP。
.PP
\fBTAILQ_INSERT_BEFORE\fP() 在元素 \fIlistelm\fP 之前插入新元素 \fIelm\fP。
.PP
\fBTAILQ_INSERT_AFTER\fP() 在元素 \fIlistelm\fP 之后插入新元素 \fIelm\fP。
.SS Traversal
\fBTAILQ_FIRST\fP() 返回队列中的第一项，如果队列为空则返回 NULL。
.PP
\fBTAILQ_LAST\fP() 返回队列中的最后一项。 如果队列为空，则返回值为 NULL。
.PP
\fBTAILQ_PREV\fP() 返回队列中的前一项，如果该项是第一项，则返回 NULL。
.PP
\fBTAILQ_NEXT\fP() 返回队列中的下一项，如果该项是最后一项则返回 NULL。
.PP
.\" .PP
.\" .BR TAILQ_FOREACH_FROM ()
.\" behaves identically to
.\" .BR TAILQ_FOREACH ()
.\" when
.\" .I var
.\" is NULL, else it treats
.\" .I var
.\" as a previously found TAILQ element and begins the loop at
.\" .I var
.\" instead of the first element in the TAILQ referenced by
.\" .IR head .
\fBTAILQ_FOREACH\fP() 正向遍历 \fIhead\fP 引用的队列，依次将每个元素赋值给 \fIvar\fP。 如果循环正常完成，或者没有元素，则
\fIvar\fP 设置为 NULL。
.PP
.\" .PP
.\" .BR TAILQ_FOREACH_REVERSE_FROM ()
.\" behaves identically to
.\" .BR TAILQ_FOREACH_REVERSE ()
.\" when
.\" .I var
.\" is NULL, else it treats
.\" .I var
.\" as a previously found TAILQ element and begins the reverse loop at
.\" .I var
.\" instead of the last element in the TAILQ referenced by
.\" .IR head .
.\" .PP
.\" .BR TAILQ_FOREACH_SAFE ()
.\" and
.\" .BR TAILQ_FOREACH_REVERSE_SAFE ()
.\" traverse the list referenced by
.\" .I head
.\" in the forward or reverse direction respectively,
.\" assigning each element in turn to
.\" .IR var .
.\" However, unlike their unsafe counterparts,
.\" .BR TAILQ_FOREACH ()
.\" and
.\" .BR TAILQ_FOREACH_REVERSE ()
.\" permit to both remove
.\" .I var
.\" as well as free it from within the loop safely without interfering with the
.\" traversal.
.\" .PP
.\" .BR TAILQ_FOREACH_FROM_SAFE ()
.\" behaves identically to
.\" .BR TAILQ_FOREACH_SAFE ()
.\" when
.\" .I var
.\" is NULL, else it treats
.\" .I var
.\" as a previously found TAILQ element and begins the loop at
.\" .I var
.\" instead of the first element in the TAILQ referenced by
.\" .IR head .
.\" .PP
.\" .BR TAILQ_FOREACH_REVERSE_FROM_SAFE ()
.\" behaves identically to
.\" .BR TAILQ_FOREACH_REVERSE_SAFE ()
.\" when
.\" .I var
.\" is NULL, else it treats
.\" .I var
.\" as a previously found TAILQ element and begins the reverse loop at
.\" .I var
.\" instead of the last element in the TAILQ referenced by
.\" .IR head .
\fBTAILQ_FOREACH_REVERSE\fP() 反方向遍历 \fIhead\fP 引用的队列，依次将每个元素赋值给 \fIvar\fP。
.SS Removal
\fBTAILQ_REMOVE\fP() 从队列中删除元素 \fIelm\fP。
.SS "Other features"
.\" .BR TAILQ_SWAP ()
.\" swaps the contents of
.\" .I head1
.\" and
.\" .IR head2 .
.\" .PP
\fBTAILQ_CONCAT\fP() 将以 \fIhead2\fP 为首的队列连接到以 \fIhead1\fP 为首的队列的末尾，删除前者的所有条目。
.SH "RETURN VALUE"
如果队列为空，则 \fBTAILQ_EMPTY\fP() 返回非零; 如果队列包含至少一个条目，则返回零。
.PP
\fBTAILQ_FIRST\fP()、\fBTAILQ_LAST\fP()、\fBTAILQ_PREV\fP() 和 \fBTAILQ_NEXT\fP()
分别返回指向第一个、最后一个、上一个或下一个 \fITYPE\fP 结构体的指针。
.PP
\fBTAILQ_HEAD_INITIALIZER\fP() 返回一个可以分配给队列 \fIhead\fP 的初始化。
.SH STANDARDS
不在 POSIX.1、POSIX.1\-2001 或 POSIX.1\-2008 中。 出现在 BSD 上。 (TAILQ 函数首次出现于 4.4BSD)。
.SH BUGS
\fBTAILQ_FOREACH\fP() 和 \fBTAILQ_FOREACH_REVERSE\fP() 不允许在循环内删除或释放
\fIvar\fP，因为它会干扰遍历。 \fBTAILQ_FOREACH_SAFE\fP() 和 \fBTAILQ_FOREACH_REVERSE_SAFE\fP()
存在于 BSD 中但不存在于 glibc 中，通过允许 \fIvar\fP 安全地从列表中删除并从循环中释放而不干扰遍历来修复此限制。
.SH EXAMPLES
.\" SRC BEGIN (tailq.c)
.EX
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/queue.h>

struct entry {
    int data;
    TAILQ_ENTRY(entry) entries;             /* Tail queue */
};

TAILQ_HEAD(tailhead, entry);

int
main(void)
{
    struct entry *n1, *n2, *n3, *np;
    struct tailhead head;                    /* Tail queue head */
    int i;

    TAILQ_INIT(&head);                      /* Initialize the queue */

    n1 = malloc(sizeof(struct entry));      /* Insert at the head */
    TAILQ_INSERT_HEAD(&head, n1, entries);

    n1 = malloc(sizeof(struct entry));      /* Insert at the tail */
    TAILQ_INSERT_TAIL(&head, n1, entries);

    n2 = malloc(sizeof(struct entry));      /* Insert after */
    TAILQ_INSERT_AFTER(&head, n1, n2, entries);

    n3 = malloc(sizeof(struct entry));      /* Insert before */
    TAILQ_INSERT_BEFORE(n2, n3, entries);

    TAILQ_REMOVE(&head, n2, entries);       /* Deletion */
    free(n2);
                                            /* Forward traversal */
    i = 0;
    TAILQ_FOREACH(np, &head, entries)
        np\->data = i++;
                                            /* Reverse traversal */
    TAILQ_FOREACH_REVERSE(np, &head, tailhead, entries)
        printf("%i\en", np\->data);
                                            /* TailQ deletion */
    n1 = TAILQ_FIRST(&head);
    while (n1 != NULL) {
        n2 = TAILQ_NEXT(n1, entries);
        free(n1);
        n1 = n2;
    }
    TAILQ_INIT(&head);

    exit(EXIT_SUCCESS);
}
.EE
.\" SRC END
.SH "SEE ALSO"
\fBinsque\fP(3), \fBqueue\fP(7)
.PP
.SH [手册页中文版]
.PP
本翻译为免费文档；阅读
.UR https://www.gnu.org/licenses/gpl-3.0.html
GNU 通用公共许可证第 3 版
.UE
或稍后的版权条款。因使用该翻译而造成的任何问题和损失完全由您承担。
.PP
该中文翻译由 wtklbm
.B <wtklbm@gmail.com>
根据个人学习需要制作。
.PP
项目地址:
.UR \fBhttps://github.com/wtklbm/manpages-chinese\fR
.ME 。
