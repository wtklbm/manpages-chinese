.\" -*- coding: UTF-8 -*-
.\" -*- nroff -*-
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH libalpm_cb 3 "Tue Nov 1 2022" libalpm 
.ad l
.nh
.SH NAME
libalpm_cb \- Callbacks
.PP
 \- libalpm 回调的函数和结构 \&。

.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
struct \fBalpm_event_any_t\fP
.br
可以代表任何事件的事件 \&。
.ti -1c
struct \fBalpm_event_package_operation_t\fP
.br
发生包操作事件 \&。
.ti -1c
struct \fBalpm_event_optdep_removal_t\fP
.br
删除了一个可选的依赖项 \&。
.ti -1c
struct \fBalpm_event_scriptlet_info_t\fP
.br
运行了一个小脚本 \&。
.ti -1c
struct \fBalpm_event_database_missing_t\fP
.br
缺少数据库 \&。
.ti -1c
struct \fBalpm_event_pkgdownload_t\fP
.br
下载了一个包 \&。
.ti -1c
struct \fBalpm_event_pacnew_created_t\fP
.br
已创建 pacnew 文件 \&。
.ti -1c
struct \fBalpm_event_pacsave_created_t\fP
.br
已创建 pacsave 文件 \&。
.ti -1c
struct \fBalpm_event_hook_t\fP
.br
pre/post 事务，钩子，将运行 \&。
.ti -1c
struct \fBalpm_event_hook_run_t\fP
.br
运行了 pre/post 事务，钩子 \&。
.ti -1c
struct \fBalpm_event_pkg_retrieve_t\fP
.br
包下载即将开始 \&。
.ti -1c
union \fBalpm_event_t\fP
.br
Events\&.
.ti -1c
struct \fBalpm_question_any_t\fP
.br
可以代表任何其他问题的问题 \&。
.ti -1c
struct \fBalpm_question_install_ignorepkg_t\fP
.br
是否应该安装 ignorepkg 中的目标?
.ti -1c
struct \fBalpm_question_replace_t\fP
.br
是否应该更换包裹?
.ti -1c
struct \fBalpm_question_conflict_t\fP
.br
是否应该删除有冲突的包?
.ti -1c
struct \fBalpm_question_corrupted_t\fP
.br
是否应该删除损坏的包?
.ti -1c
struct \fBalpm_question_remove_pkgs_t\fP
.br
是否应从交易中删除无法解决的目标?
.ti -1c
struct \fBalpm_question_select_provider_t\fP
.br
提供商选择 \&。
.ti -1c
struct \fBalpm_question_import_key_t\fP
.br
是否应该导入密钥?
.ti -1c
union \fBalpm_question_t\fP
.br
Questions\&.
.ti -1c
struct \fBalpm_download_event_init_t\fP
.br
下载开始时的上下文结构体 \&。
.ti -1c
struct \fBalpm_download_event_progress_t\fP
.br
下载进行时的上下文结构体 \&。
.ti -1c
struct \fBalpm_download_event_retry_t\fP
.br
下载重试时的上下文结构体 \&。
.ti -1c
struct \fBalpm_download_event_completed_t\fP
.br
下载完成时的上下文结构体 \&。
.in -1c
.SS Typedefs

.in +1c
.ti -1c
typedef void(* \fBalpm_cb_event\fP) (void *ctx, \fBalpm_event_t\fP *)
.br
事件回调 \&。
.ti -1c
typedef void(* \fBalpm_cb_question\fP) (void *ctx, \fBalpm_question_t\fP *)
.br
问题回调 \&。
.ti -1c
typedef void(* \fBalpm_cb_progress\fP) (void *ctx, \fBalpm_progress_t\fP progress,
const char *pkg, int percent, size_t howmany, size_t current)
.br
进度回调 \&.
.ti -1c
typedef void(* \fBalpm_cb_download\fP) (void *ctx, const char *filename,
\fBalpm_download_event_type_t\fP event, void *data)
.br
下载进度回调类型 \&。
.ti -1c
typedef int(* \fBalpm_cb_fetch\fP) (void *ctx, const char *url, const char
*localpath, int force)
.br
下载文件的回调 \&。
.in -1c
.SS Enumerations

.in +1c
.ti -1c
enum \fBalpm_event_type_t\fP { \fBALPM_EVENT_CHECKDEPS_START\fP = 1,
\fBALPM_EVENT_CHECKDEPS_DONE\fP, \fBALPM_EVENT_FILECONFLICTS_START\fP,
\fBALPM_EVENT_FILECONFLICTS_DONE\fP, \fBALPM_EVENT_RESOLVEDEPS_START\fP,
\fBALPM_EVENT_RESOLVEDEPS_DONE\fP, \fBALPM_EVENT_INTERCONFLICTS_START\fP,
\fBALPM_EVENT_INTERCONFLICTS_DONE\fP, \fBALPM_EVENT_TRANSACTION_START\fP,
\fBALPM_EVENT_TRANSACTION_DONE\fP, \fBALPM_EVENT_PACKAGE_OPERATION_START\fP,
\fBALPM_EVENT_PACKAGE_OPERATION_DONE\fP, \fBALPM_EVENT_INTEGRITY_START\fP,
\fBALPM_EVENT_INTEGRITY_DONE\fP, \fBALPM_EVENT_LOAD_START\fP,
\fBALPM_EVENT_LOAD_DONE\fP, \fBALPM_EVENT_SCRIPTLET_INFO\fP,
\fBALPM_EVENT_DB_RETRIEVE_START\fP, \fBALPM_EVENT_DB_RETRIEVE_DONE\fP,
\fBALPM_EVENT_DB_RETRIEVE_FAILED\fP, \fBALPM_EVENT_PKG_RETRIEVE_START\fP,
\fBALPM_EVENT_PKG_RETRIEVE_DONE\fP, \fBALPM_EVENT_PKG_RETRIEVE_FAILED\fP,
\fBALPM_EVENT_DISKSPACE_START\fP, \fBALPM_EVENT_DISKSPACE_DONE\fP,
\fBALPM_EVENT_OPTDEP_REMOVAL\fP, \fBALPM_EVENT_DATABASE_MISSING\fP,
\fBALPM_EVENT_KEYRING_START\fP, \fBALPM_EVENT_KEYRING_DONE\fP,
\fBALPM_EVENT_KEY_DOWNLOAD_START\fP, \fBALPM_EVENT_KEY_DOWNLOAD_DONE\fP,
\fBALPM_EVENT_PACNEW_CREATED\fP, \fBALPM_EVENT_PACSAVE_CREATED\fP,
\fBALPM_EVENT_HOOK_START\fP, \fBALPM_EVENT_HOOK_DONE\fP,
\fBALPM_EVENT_HOOK_RUN_START\fP, \fBALPM_EVENT_HOOK_RUN_DONE\fP }
.br
事件类型 \&。
.ti -1c
enum \fBalpm_package_operation_t\fP { \fBALPM_PACKAGE_INSTALL\fP = 1,
\fBALPM_PACKAGE_UPGRADE\fP, \fBALPM_PACKAGE_REINSTALL\fP,
\fBALPM_PACKAGE_DOWNGRADE\fP, \fBALPM_PACKAGE_REMOVE\fP }
.br
包操作类型的枚举 \&。
.ti -1c
enum \fBalpm_hook_when_t\fP { \fBALPM_HOOK_PRE_TRANSACTION\fP = 1,
\fBALPM_HOOK_POST_TRANSACTION\fP }
.br
有点像钩子 \&。
.ti -1c
enum \fBalpm_question_type_t\fP { \fBALPM_QUESTION_INSTALL_IGNOREPKG\fP = (1
<< 0), \fBALPM_QUESTION_REPLACE_PKG\fP = (1 << 1),
\fBALPM_QUESTION_CONFLICT_PKG\fP = (1 << 2),
\fBALPM_QUESTION_CORRUPTED_PKG\fP = (1 << 3),
\fBALPM_QUESTION_REMOVE_PKGS\fP = (1 << 4),
\fBALPM_QUESTION_SELECT_PROVIDER\fP = (1 << 5),
\fBALPM_QUESTION_IMPORT_KEY\fP = (1 << 6) }
.br
问题类型 \&。
.ti -1c
enum \fBalpm_progress_t\fP { \fBALPM_PROGRESS_ADD_START\fP,
\fBALPM_PROGRESS_UPGRADE_START\fP, \fBALPM_PROGRESS_DOWNGRADE_START\fP,
\fBALPM_PROGRESS_REINSTALL_START\fP, \fBALPM_PROGRESS_REMOVE_START\fP,
\fBALPM_PROGRESS_CONFLICTS_START\fP, \fBALPM_PROGRESS_DISKSPACE_START\fP,
\fBALPM_PROGRESS_INTEGRITY_START\fP, \fBALPM_PROGRESS_LOAD_START\fP,
\fBALPM_PROGRESS_KEYRING_START\fP }
.br
对不同类型的进度警报的枚举 \&。
.ti -1c
enum \fBalpm_download_event_type_t\fP { \fBALPM_DOWNLOAD_INIT\fP,
\fBALPM_DOWNLOAD_PROGRESS\fP, \fBALPM_DOWNLOAD_RETRY\fP,
\fBALPM_DOWNLOAD_COMPLETED\fP }
.br
文件下载事件 \&。
.in -1c
.SH "Detailed Description"
.PP
libalpm 回调的函数和结构 \&。


.SH "Data Structure Documentation"
.PP
.SH "struct alpm_event_any_t"
.PP
可以代表任何事件的事件 \&。
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_event_package_operation_t"
.PP
发生包操作事件 \&。
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_pkg_t\fP * \fInewpkg\fP 新包 \&。
.br
.PP
\fBalpm_pkg_t\fP * \fIoldpkg\fP 旧包 \&。
.br
.PP
\fBalpm_package_operation_t\fP \fIoperation\fP 操作类型 \&。
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_event_optdep_removal_t"
.PP
删除了一个可选的依赖项 \&。
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_depend_t\fP * \fIoptdep\fP Optdep 被删除 \&。
.br
.PP
\fBalpm_pkg_t\fP * \fIpkg\fP 带有 optdep\& 的软件包。
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_event_scriptlet_info_t"
.PP
运行了一个小脚本 \&。
.PP
\fBData Fields:\fP
.RS 4
const char * \fIline\fP Line of scriptlet output\&.
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_event_database_missing_t"
.PP
缺少数据库 \&。

数据库已注册但尚未下载
.PP
\fBData Fields:\fP
.RS 4
const char * \fIdbname\fP Name of the database\&.
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_event_pkgdownload_t"
.PP
下载了一个包 \&。
.PP
\fBData Fields:\fP
.RS 4
const char * \fIfile\fP Name of the file\&.
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_event_pacnew_created_t"
.PP
已创建 pacnew 文件 \&。
.PP
\fBData Fields:\fP
.RS 4
const char * \fIfile\fP Filename of the file without the \&.pacnew suffix\&.
.br
.PP
int \fIfrom_noupgrade\fP Whether the creation was result of a NoUpgrade or
not\&.
.br
.PP
\fBalpm_pkg_t\fP * \fInewpkg\fP 新包 \&。
.br
.PP
\fBalpm_pkg_t\fP * \fIoldpkg\fP 旧包 \&。
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_event_pacsave_created_t"
.PP
已创建 pacsave 文件 \&。
.PP
\fBData Fields:\fP
.RS 4
const char * \fIfile\fP Filename of the file without the \&.pacsave suffix\&.
.br
.PP
\fBalpm_pkg_t\fP * \fIoldpkg\fP 旧包 \&。
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_event_hook_t"
.PP
pre/post 事务，钩子，将运行 \&。
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
\fBalpm_hook_when_t\fP \fIwhen\fP Type of hook\&.
.br
.PP
.RE
.PP
.SH "struct alpm_event_hook_run_t"
.PP
运行了 pre/post 事务，钩子 \&。
.PP
\fBData Fields:\fP
.RS 4
const char * \fIdesc\fP Description of hook to be outputted\&.
.br
.PP
const char * \fIname\fP Name of hook\&.
.br
.PP
size_t \fIposition\fP position of hook being run
.br
.PP
size_t \fItotal\fP total hooks being run
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_event_pkg_retrieve_t"
.PP
包下载即将开始 \&。
.PP
\fBData Fields:\fP
.RS 4
size_t \fInum\fP Number of packages to download\&.
.br
.PP
off_t \fItotal_size\fP 要下载的包的总大小 \&。
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型 \&。
.br
.PP
.RE
.PP
.SH "union alpm_event_t"
.PP
Events\&.

这是一个传递给回调的 union，它允许前端知道触发了哪种类型的事件 (通过类型) \&。然后可以将指针类型转换为正确的结构体，或使用 union
字段，以访问特定于事件的数据 \&。
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_event_any_t\fP \fIany\fP 任何事件类型 \&。
.br
访问 this\& 总是安全的。
.br
.PP
\fBalpm_event_database_missing_t\fP \fIdatabase_missing\fP 缺少数据库 \&。
.br
.PP
\fBalpm_event_hook_t\fP \fIhook\fP Pre/post 事务，钩子，正在运行 \&。
.br
.PP
\fBalpm_event_hook_run_t\fP \fIhook_run\fP 已运行，钩子 \&。
.br
.PP
\fBalpm_event_optdep_removal_t\fP \fIoptdep_removal\fP optdept 已删除 \&。
.br
.PP
\fBalpm_event_package_operation_t\fP \fIpackage_operation\fP 包操作 \&。
.br
.PP
\fBalpm_event_pacnew_created_t\fP \fIpacnew_created\fP 创建了一个 pacnew 文件 \&。
.br
.PP
\fBalpm_event_pacsave_created_t\fP \fIpacsave_created\fP 已创建 pacsave 文件 \&。
.br
.PP
\fBalpm_event_pkg_retrieve_t\fP \fIpkg_retrieve\fP 下载包 \&。
.br
.PP
\fBalpm_event_pkgdownload_t\fP \fIpkgdownload\fP 已下载包 \&。
.br
.PP
\fBalpm_event_scriptlet_info_t\fP \fIscriptlet_info\fP 已运行 scriptlet\&。
.br
.PP
\fBalpm_event_type_t\fP \fItype\fP 事件类型访问此 \& 总是安全的。
.br
.PP
.RE
.PP
.SH "struct alpm_question_any_t"
.PP
可以代表任何其他问题的问题 \&。
.PP
\fBData Fields:\fP
.RS 4
int \fIanswer\fP Answer\&.
.br
.PP
\fBalpm_question_type_t\fP \fItype\fP 问题类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_question_install_ignorepkg_t"
.PP
是否应该安装 ignorepkg 中的目标?
.PP
\fBData Fields:\fP
.RS 4
int \fIinstall\fP Answer: whether or not to install pkg anyway\&.
.br
.PP
\fBalpm_pkg_t\fP * \fIpkg\fP 我们正在决定是否安装的被忽略的包 \&。
.br
.PP
\fBalpm_question_type_t\fP \fItype\fP 问题类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_question_replace_t"
.PP
是否应该更换包裹?
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_db_t\fP * \fInewdb\fP newpkg\& 的 DB。
.br
.PP
\fBalpm_pkg_t\fP * \fInewpkg\fP 包替换为 \&。
.br
.PP
\fBalpm_pkg_t\fP * \fIoldpkg\fP 要替换的包 \&。
.br
.PP
int \fIreplace\fP Answer: whether or not to replace oldpkg with newpkg\&.
.br
.PP
\fBalpm_question_type_t\fP \fItype\fP 问题类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_question_conflict_t"
.PP
是否应该删除有冲突的包?
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_conflict_t\fP * \fIconflict\fP 冲突信息 \&。
.br
.PP
int \fIremove\fP Answer: whether or not to remove conflict\->package2\&.
.br
.PP
\fBalpm_question_type_t\fP \fItype\fP 问题类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_question_corrupted_t"
.PP
是否应该删除损坏的包?
.PP
\fBData Fields:\fP
.RS 4
const char * \fIfilepath\fP File to remove\&.
.br
.PP
\fBalpm_errno_t\fP \fIreason\fP 包无效原因的错误码 \&。
.br
.PP
int \fIremove\fP Answer: whether or not to remove filepath\&.
.br
.PP
\fBalpm_question_type_t\fP \fItype\fP 问题类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_question_remove_pkgs_t"
.PP
是否应从交易中删除无法解决的目标?
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_list_t\fP * \fIpackages\fP alpm_pkg_t* 列表，具有未解决的依赖性 \&。
.br
.PP
int \fIskip\fP Answer: whether or not to skip packages\&.
.br
.PP
\fBalpm_question_type_t\fP \fItype\fP 问题类型 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_question_select_provider_t"
.PP
提供商选择 \&。
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_depend_t\fP * \fIdepend\fP 供应商提供什么 \&。
.br
.PP
\fBalpm_list_t\fP * \fIproviders\fP alpm_pkg_t* 列表作为可能的供应商 \&。
.br
.PP
\fBalpm_question_type_t\fP \fItype\fP 问题类型 \&。
.br
.PP
int \fIuse_index\fP Answer: which provider to use (index from providers)
.br
.PP
.RE
.PP
.SH "struct alpm_question_import_key_t"
.PP
是否应该导入密钥?
.PP
\fBData Fields:\fP
.RS 4
int \fIimport\fP Answer: whether or not to import key\&.
.br
.PP
\fBalpm_pgpkey_t\fP * \fIkey\fP 导入 \& 的键。
.br
.PP
\fBalpm_question_type_t\fP \fItype\fP 问题类型 \&。
.br
.PP
.RE
.PP
.SH "union alpm_question_t"
.PP
Questions\&.

这是一个 union 传递给回调，它允许前端知道触发了哪种类型的问题 (通过类型) \&。然后可以将指针类型转换为正确的结构体，或使用 union
字段，以访问特定于问题的数据 \&。
.PP
\fBData Fields:\fP
.RS 4
\fBalpm_question_any_t\fP \fIany\fP 一个 question，可以代表任何问题 \&。
.br
访问 this\& 总是安全的。
.br
.PP
\fBalpm_question_conflict_t\fP \fIconflict\fP 是否应该删除有冲突的包?
.br
.PP
\fBalpm_question_corrupted_t\fP \fIcorrupted\fP 损坏的包是否应该删除?
.br
.PP
\fBalpm_question_import_key_t\fP \fIimport_key\fP 是否应该导入密钥?
.br
.PP
\fBalpm_question_install_ignorepkg_t\fP \fIinstall_ignorepkg\fP 是否应该安装 ignorepkg
中的目标?
.br
.PP
\fBalpm_question_remove_pkgs_t\fP \fIremove_pkgs\fP 是否应从事务中删除无法解析的目标?
.br
.PP
\fBalpm_question_replace_t\fP \fIreplace\fP 是否应该更换一个包?
.br
.PP
\fBalpm_question_select_provider_t\fP \fIselect_provider\fP 提供商选择 \&。
.br
.PP
\fBalpm_question_type_t\fP \fItype\fP 题型 \&。
.br
访问 this\& 总是安全的。
.br
.PP
.RE
.PP
.SH "struct alpm_download_event_init_t"
.PP
下载开始时的上下文结构体 \&。
.PP
\fBData Fields:\fP
.RS 4
int \fIoptional\fP whether this file is optional and thus the errors could be
ignored
.br
.PP
.RE
.PP
.SH "struct alpm_download_event_progress_t"
.PP
下载进行时的上下文结构体 \&。
.PP
\fBData Fields:\fP
.RS 4
off_t \fIdownloaded\fP 下载的数据量 \&。
.br
.PP
off_t \fItotal\fP 需要下载的总量 \&。
.br
.PP
.RE
.PP
.SH "struct alpm_download_event_retry_t"
.PP
下载重试时的上下文结构体 \&。
.PP
\fBData Fields:\fP
.RS 4
int \fIresume\fP If the download will resume or start over\&.
.br
.PP
.RE
.PP
.SH "struct alpm_download_event_completed_t"
.PP
下载完成时的上下文结构体 \&。
.PP
\fBData Fields:\fP
.RS 4
int \fIresult\fP download result code: 0 \- download completed successfully 1 \-
the file is up\-to\-date \-1 \- error
.br
.PP
off_t \fItotal\fP 文件中的总字节数 \&。
.br
.PP
.RE
.PP
.SH "Typedef Documentation"
.PP
.SS "typedef void(* alpm_cb_download) (void *ctx, const char *filename, alpm_download_event_type_t event, void *data)"

.PP
下载进度回调类型 \&。
.PP
\fBParameters\fP
.RS 4
\fIctx\fP 用户提供的上下文
.br
\fIfilename\fP 正在下载的文件名
.br
\fIevent\fP 事件类型
.br
\fIdata\fP alpm_download_event_*_t 类型的事件数据
.RE
.PP

.SS "typedef void(* alpm_cb_event) (void *ctx, alpm_event_t *)"

.PP
事件回调 \&。事件发生时调用
.PP
\fBParameters\fP
.RS 4
\fIctx\fP 用户提供的上下文
.br
\fIevent\fP 发生的事件
.RE
.PP

.SS "typedef int(* alpm_cb_fetch) (void *ctx, const char *url, const char *localpath, int force)"

.PP
下载文件的回调 \&。
.PP
\fBParameters\fP
.RS 4
\fIctx\fP 用户提供的上下文
.br
\fIurl\fP 要下载的文件的 URL
.br
\fIlocalpath\fP 文件应下载到的目录
.br
\fIforce\fP 是否强制更新，即使文件相同
.RE
.PP
\fBReturns\fP
.RS 4
成功时为 0，如果文件存在且相同则为 1，错误时为 \-1\&。
.RE
.PP

.SS "typedef void(* alpm_cb_progress) (void *ctx, alpm_progress_t progress, const char *pkg, int percent, size_t howmany, size_t current)"

.PP
进度回调 \&. 提醒前端某些事件的进展情况 \&。允许为需要一段时间才能完成的事件实现加载栏 \&。
.PP
\fBParameters\fP
.RS 4
\fIctx\fP 用户提供的上下文
.br
\fIprogress\fP 正在进行的事件类型
.br
\fIpkg\fP 用于包操作，正在操作的包的名称
.br
\fIpercent\fP 动作完成百分比
.br
\fIhowmany\fP 项目总金额
.br
\fIcurrent\fP 当前项目完成进度回调
.RE
.PP

.SS "typedef void(* alpm_cb_question) (void *ctx, alpm_question_t *)"

.PP
问题回调 \&。此回调允许用户提供输入并决定在某些事件期间要做什么
.PP
\fBParameters\fP
.RS 4
\fIctx\fP 用户提供的上下文
.br
\fIquestion\fP 被问的问题 \&。
.RE
.PP

.SH "Enumeration Type Documentation"
.PP
.SS "enum alpm_download_event_type_t"

.PP
文件下载事件 \&。这些事件由 ALPM 通过下载回调 \& 报告。
.PP
\fBEnumerator\fP
.in +1c
.TP 
\fIALPM_DOWNLOAD_INIT \fP
下载已开始 \&。
.TP 
\fIALPM_DOWNLOAD_PROGRESS \fP
下载取得进展 \&。
.TP 
\fIALPM_DOWNLOAD_RETRY \fP
将重试下载 \&。
.TP 
\fIALPM_DOWNLOAD_COMPLETED \fP
下载完成 \&。
.SS "enum alpm_event_type_t"

.PP
事件类型 \&。
.PP
\fBEnumerator\fP
.in +1c
.TP 
\fIALPM_EVENT_CHECKDEPS_START \fP
将为包计算依赖性。
.TP 
\fIALPM_EVENT_CHECKDEPS_DONE \fP
为包计算了依赖性 \&。
.TP 
\fIALPM_EVENT_FILECONFLICTS_START \fP
将为包计算文件冲突 \&。
.TP 
\fIALPM_EVENT_FILECONFLICTS_DONE \fP
为包计算了文件冲突 \&。
.TP 
\fIALPM_EVENT_RESOLVEDEPS_START \fP
将为目标包解决依赖关系 \&。
.TP 
\fIALPM_EVENT_RESOLVEDEPS_DONE \fP
已解决目标包 \& 的依赖关系。
.TP 
\fIALPM_EVENT_INTERCONFLICTS_START \fP
将检查目标包 \& 的内部冲突。
.TP 
\fIALPM_EVENT_INTERCONFLICTS_DONE \fP
检查了目标包的内部冲突 \&。
.TP 
\fIALPM_EVENT_TRANSACTION_START \fP
处理包交易正在开始 \&。
.TP 
\fIALPM_EVENT_TRANSACTION_DONE \fP
处理包事务已完成 \&。
.TP 
\fIALPM_EVENT_PACKAGE_OPERATION_START \fP
包将是 installed/upgraded/downgraded/re\-installed/removed; 有关参数 \&，请参见
\fBalpm_event_package_operation_t\fP。
.TP 
\fIALPM_EVENT_PACKAGE_OPERATION_DONE \fP
包裹是 installed/upgraded/downgraded/re\-installed/removed; 有关参数 \&，请参见
\fBalpm_event_package_operation_t\fP。
.TP 
\fIALPM_EVENT_INTEGRITY_START \fP
目标包的完整性将被检查 \&。
.TP 
\fIALPM_EVENT_INTEGRITY_DONE \fP
已检查目标包的完整性 \&。
.TP 
\fIALPM_EVENT_LOAD_START \fP
目标包将被加载 \&。
.TP 
\fIALPM_EVENT_LOAD_DONE \fP
目标包已完成加载 \&。
.TP 
\fIALPM_EVENT_SCRIPTLET_INFO \fP
Scriptlet 有打印信息; 有关参数 \&，请参见 \fBalpm_event_scriptlet_info_t\fP。
.TP 
\fIALPM_EVENT_DB_RETRIEVE_START \fP
数据库文件将从库 \& 下载。
.TP 
\fIALPM_EVENT_DB_RETRIEVE_DONE \fP
数据库文件是从一个库 \& 下载的。
.TP 
\fIALPM_EVENT_DB_RETRIEVE_FAILED \fP
并非所有数据库文件都从库 \& 成功下载。
.TP 
\fIALPM_EVENT_PKG_RETRIEVE_START \fP
包文件将从库 \& 下载。
.TP 
\fIALPM_EVENT_PKG_RETRIEVE_DONE \fP
包文件是从库 \& 下载的。
.TP 
\fIALPM_EVENT_PKG_RETRIEVE_FAILED \fP
并非所有包文件都从库 \& 成功下载。
.TP 
\fIALPM_EVENT_DISKSPACE_START \fP
将为包计算磁盘空间使用情况 \&。
.TP 
\fIALPM_EVENT_DISKSPACE_DONE \fP
计算了包的磁盘空间使用情况 \&。
.TP 
\fIALPM_EVENT_OPTDEP_REMOVAL \fP
正在删除另一个包的 optdepend; 有关参数 \&，请参见 \fBalpm_event_optdep_removal_t\fP。
.TP 
\fIALPM_EVENT_DATABASE_MISSING \fP
缺少配置的库库数据库; 有关参数 \&，请参见 \fBalpm_event_database_missing_t\fP。
.TP 
\fIALPM_EVENT_KEYRING_START \fP
用于创建签名的检查密钥位于密钥环 \& 中。
.TP 
\fIALPM_EVENT_KEYRING_DONE \fP
密钥环检查完成 \&。
.TP 
\fIALPM_EVENT_KEY_DOWNLOAD_START \fP
正在将丢失的密钥下载到密钥环 \&。
.TP 
\fIALPM_EVENT_KEY_DOWNLOAD_DONE \fP
密钥下载完成 \&。
.TP 
\fIALPM_EVENT_PACNEW_CREATED \fP
创建了一个 \&.pacnew 文件; 有关参数 \&，请参见 \fBalpm_event_pacnew_created_t\fP。
.TP 
\fIALPM_EVENT_PACSAVE_CREATED \fP
创建了一个 \&.pacsave 文件; 有关参数 \&，请参见 \fBalpm_event_pacsave_created_t\fP。
.TP 
\fIALPM_EVENT_HOOK_START \fP
处理，钩子，将开始 \&。
.TP 
\fIALPM_EVENT_HOOK_DONE \fP
处理，钩子，完成 \&。
.TP 
\fIALPM_EVENT_HOOK_RUN_START \fP
一个钩子正在开始 \&。
.TP 
\fIALPM_EVENT_HOOK_RUN_DONE \fP
钩子已完成运行 \&。
.SS "enum alpm_hook_when_t"

.PP
有点像钩子 \&。
.SS "enum alpm_package_operation_t"

.PP
包操作类型的枚举 \&。
.PP
\fBEnumerator\fP
.in +1c
.TP 
\fIALPM_PACKAGE_INSTALL \fP
包 (待) 安装 \&。(没有 oldpkg)
.TP 
\fIALPM_PACKAGE_UPGRADE \fP
包 (待) 升级 \&。
.TP 
\fIALPM_PACKAGE_REINSTALL \fP
包 (待) 重新安装 \&。
.TP 
\fIALPM_PACKAGE_DOWNGRADE \fP
包 (待) 降级 \&。
.TP 
\fIALPM_PACKAGE_REMOVE \fP
软件包 (待) 删除 (无 newpkg)
.SS "enum alpm_progress_t"

.PP
对不同类型的进度警报的枚举 \&。
.PP
\fBEnumerator\fP
.in +1c
.TP 
\fIALPM_PROGRESS_ADD_START \fP
包安装 \&。
.TP 
\fIALPM_PROGRESS_UPGRADE_START \fP
包升级 \&。
.TP 
\fIALPM_PROGRESS_DOWNGRADE_START \fP
包降级 \&。
.TP 
\fIALPM_PROGRESS_REINSTALL_START \fP
包重新安装 \&。
.TP 
\fIALPM_PROGRESS_REMOVE_START \fP
包删除 \&。
.TP 
\fIALPM_PROGRESS_CONFLICTS_START \fP
冲突检查 \&。
.TP 
\fIALPM_PROGRESS_DISKSPACE_START \fP
磁盘空间检查 \&。
.TP 
\fIALPM_PROGRESS_INTEGRITY_START \fP
包完整性检查 \&。
.TP 
\fIALPM_PROGRESS_LOAD_START \fP
从磁盘加载包 \&。
.TP 
\fIALPM_PROGRESS_KEYRING_START \fP
检查包的签名 \&。
.SS "enum alpm_question_type_t"

.PP
问题类型 \&。与事件或进度枚举不同，此枚举具有位掩码值，因此前端可以使用位掩码 map 为不同类型的问题提供预选答案 \&。
.PP
\fBEnumerator\fP
.in +1c
.TP 
\fIALPM_QUESTION_INSTALL_IGNOREPKG \fP
是否应该安装 ignorepkg 中的目标?
.TP 
\fIALPM_QUESTION_REPLACE_PKG \fP
是否应该更换包裹?
.TP 
\fIALPM_QUESTION_CONFLICT_PKG \fP
是否应该删除有冲突的包?
.TP 
\fIALPM_QUESTION_CORRUPTED_PKG \fP
是否应该删除损坏的包?
.TP 
\fIALPM_QUESTION_REMOVE_PKGS \fP
是否应从交易中删除无法解决的目标?
.TP 
\fIALPM_QUESTION_SELECT_PROVIDER \fP
提供商选择 \&。
.TP 
\fIALPM_QUESTION_IMPORT_KEY \fP
是否应该导入密钥?
.SH Author
.PP
由 Doxygen 从源代码为 libalpm 自动生成 \&。
.PP
.SH [手册页中文版]
.PP
本翻译为免费文档；阅读
.UR https://www.gnu.org/licenses/gpl-3.0.html
GNU 通用公共许可证第 3 版
.UE
或稍后的版权条款。因使用该翻译而造成的任何问题和损失完全由您承担。
.PP
该中文翻译由 wtklbm
.B <wtklbm@gmail.com>
根据个人学习需要制作。
.PP
项目地址:
.UR \fBhttps://github.com/wtklbm/manpages-chinese\fR
.ME 。
