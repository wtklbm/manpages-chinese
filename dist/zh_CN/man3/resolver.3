.\" -*- coding: UTF-8 -*-
'\" t
.\" Copyright 1993 David Metcalfe (david@prism.demon.co.uk)
.\" and (C) Copyright 2015 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" SPDX-License-Identifier: Linux-man-pages-copyleft
.\"
.\" References consulted:
.\"     Linux libc source code
.\"     Lewine's _POSIX Programmer's Guide_ (O'Reilly & Associates, 1991)
.\"     386BSD man pages
.\" Modified 1993-07-25 by Rik Faith (faith@cs.unc.edu)
.\" Modified 2004-10-31 by aeb
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH resolver 3 2023\-02\-05 "Linux man\-pages 6.03" 
.SH NAME
res_ninit, res_nquery, res_nsearch, res_nquerydomain, res_nmkquery,
res_nsend, res_nclose, res_init, res_query, res_search, res_querydomain,
res_mkquery, res_send, dn_comp, dn_expand \- resolver routines
.SH LIBRARY
解析器库 (\fIlibresolv\fP、\fI\-lresolv\fP)
.SH SYNOPSIS
.nf
\fB#include <netinet/in.h>\fP
\fB#include <arpa/nameser.h>\fP
\fB#include <resolv.h>\fP
.PP
\fBstruct __res_state;\fP
\fBtypedef struct __res_state *res_state;\fP
.PP
\fBint res_ninit(res_state \fP\fIstatep\fP\fB);\fP
.PP
\fBvoid res_nclose(res_state \fP\fIstatep\fP\fB);\fP
.PP
\fBint res_nquery(res_state \fP\fIstatep\fP\fB,\fP
\fB           const char *\fP\fIdname\fP\fB, int \fP\fIclass\fP\fB, int \fP\fItype\fP\fB,\fP
\fB           unsigned char \fP\fIanswer\fP\fB[.\fP\fIanslen\fP\fB], int \fP\fIanslen\fP\fB);\fP
.PP
\fBint res_nsearch(res_state \fP\fIstatep\fP\fB,\fP
\fB           const char *\fP\fIdname\fP\fB, int \fP\fIclass\fP\fB, int \fP\fItype\fP\fB,\fP
\fB           unsigned char \fP\fIanswer\fP\fB[.\fP\fIanslen\fP\fB], int \fP\fIanslen\fP\fB);\fP
.PP
\fBint res_nquerydomain(res_state \fP\fIstatep\fP\fB,\fP
\fB           const char *\fP\fIname\fP\fB, const char *\fP\fIdomain\fP\fB,\fP
\fB           int \fP\fIclass\fP\fB, int \fP\fItype\fP\fB, unsigned char \fP\fIanswer\fP\fB[.\fP\fIanslen\fP\fB],\fP
\fB           int \fP\fIanslen\fP\fB);\fP
.PP
\fBint res_nmkquery(res_state \fP\fIstatep\fP\fB,\fP
\fB           int \fP\fIop\fP\fB, const char *\fP\fIdname\fP\fB, int \fP\fIclass\fP\fB,\fP
\fB           int \fP\fItype\fP\fB, const unsigned char \fP\fIdata\fP\fB[.\fP\fIdatalen\fP\fB], int \fP\fIdatalen\fP\fB,\fP
\fB           const unsigned char *\fP\fInewrr\fP\fB,\fP
\fB           unsigned char \fP\fIbuf\fP\fB[.\fP\fIbuflen\fP\fB], int \fP\fIbuflen\fP\fB);\fP
.PP
\fBint res_nsend(res_state \fP\fIstatep\fP\fB,\fP
\fB           const unsigned char \fP\fImsg\fP\fB[.\fP\fImsglen\fP\fB], int \fP\fImsglen\fP\fB,\fP
\fB           unsigned char \fP\fIanswer\fP\fB[.\fP\fIanslen\fP\fB], int \fP\fIanslen\fP\fB);\fP
.PP
\fBint dn_comp(const char *\fP\fIexp_dn\fP\fB, unsigned char \fP\fIcomp_dn\fP\fB[.\fP\fIlength\fP\fB],\fP
\fB           int \fP\fIlength\fP\fB, unsigned char **\fP\fIdnptrs\fP\fB,\fP
\fB           unsigned char **\fP\fIlastdnptr\fP\fB);\fP
.PP
\fBint dn_expand(const unsigned char *\fP\fImsg\fP\fB,\fP
\fB           const unsigned char *\fP\fIeomorig\fP\fB,\fP
\fB           const unsigned char *\fP\fIcomp_dn\fP\fB, char \fP\fIexp_dn\fP\fB[.\fP\fIlength\fP\fB],\fP
\fB           int \fP\fIlength\fP\fB);\fP
.PP
\fB[[deprecated]] extern struct __res_state _res;\fP
.PP
\fB[[deprecated]] int res_init(void);\fP
.PP
\fB[[deprecated]]\fP
\fBint res_query(const char *\fP\fIdname\fP\fB, int \fP\fIclass\fP\fB, int \fP\fItype\fP\fB,\fP
\fB           unsigned char \fP\fIanswer\fP\fB[.\fP\fIanslen\fP\fB], int \fP\fIanslen\fP\fB);\fP
.PP
\fB[[deprecated]]\fP
\fBint res_search(const char *\fP\fIdname\fP\fB, int \fP\fIclass\fP\fB, int \fP\fItype\fP\fB,\fP
\fB           unsigned char \fP\fIanswer\fP\fB[.\fP\fIanslen\fP\fB], int \fP\fIanslen\fP\fB);\fP
.PP
\fB[[deprecated]]\fP
\fBint res_querydomain(const char *\fP\fIname\fP\fB, const char *\fP\fIdomain\fP\fB,\fP
\fB           int \fP\fIclass\fP\fB, int \fP\fItype\fP\fB, unsigned char \fP\fIanswer\fP\fB[.\fP\fIanslen\fP\fB],\fP
\fB           int \fP\fIanslen\fP\fB);\fP
.PP
\fB[[deprecated]]\fP
\fBint res_mkquery(int \fP\fIop\fP\fB, const char *\fP\fIdname\fP\fB, int \fP\fIclass\fP\fB,\fP
\fB           int \fP\fItype\fP\fB, const unsigned char \fP\fIdata\fP\fB[.\fP\fIdatalen\fP\fB], int \fP\fIdatalen\fP\fB,\fP
\fB           const unsigned char *\fP\fInewrr\fP\fB,\fP
\fB           unsigned char \fP\fIbuf\fP\fB[.\fP\fIbuflen\fP\fB], int \fP\fIbuflen\fP\fB);\fP
.PP
\fB[[deprecated]]\fP
\fBint res_send(const unsigned char \fP\fImsg\fP\fB[.\fP\fImsglen\fP\fB], int \fP\fImsglen\fP\fB,\fP
\fB           unsigned char \fP\fIanswer\fP\fB[.\fP\fIanslen\fP\fB], int \fP\fIanslen\fP\fB);\fP
.fi
.SH DESCRIPTION
\fBNote:\fP 此页面不完整 (未描述 glibc 提供的各种解析器函数) 并且可能已过时。
.PP
下面描述的函数查询并解释来自 Internet 域名服务器的响应。
.PP
API 由一组更现代的可重入函数和一组已被取代的旧的不可重入函数组成。 传统的解析器接口，如 \fBres_init\fP() 和
\fBres_query\fP() 使用存储在 \fI_res\fP 结构体中的一些静态 (global) 状态，呈现这些函数非线程安全。 BIND 8.2
引入了一组新接口 \fBres_ninit\fP()、\fBres_nquery\fP() 等，它们以 \fIres_state\fP
作为它们的第一个参数，因此您可以使用每线程解析器状态。
.PP
\fBres_ninit\fP() 和 \fBres_init\fP() 函数读取配置文件 (查看 \fBresolv.conf\fP(5)) 获取默认域名和名称服务器
address(es).  如果没有给出服务器，则尝试使用本地主机。 如果没有给出域，则使用与本地主机关联的域。 它可以用环境变量
\fBLOCALDOMAIN\fP 覆盖。 \fBres_ninit\fP() 或 \fBres_init\fP() 通常由第一个函数执行到另一个函数中的一个。 每个对
\fBres_ninit\fP() 的调用都需要一个对应的对 \fBres_nclose\fP() 的调用，以释放由 \fBres_ninit\fP() 分配的内存以及对
\fBres_nquery\fP() 的后续调用。
.PP
\fBres_nquery\fP() 和 \fBres_query\fP() 函数查询名称服务器以获取指定 \fItype\fP 和 \fIclass\fP 的完全限定域名
\fIname\fP。 回复留在调用者提供的长度为 \fIanslen\fP 的缓冲区 \fIanswer\fP 中。
.PP
\fBres_nsearch\fP() 和 \fBres_search\fP() 函数像 \fBres_nquery\fP() 和 \fBres_query\fP()
一样进行查询并等待响应，但此外它们还执行由 \fBRES_DEFNAMES\fP 和 \fBRES_DNSRCH\fP 控制的默认和搜索规则 (请参见下面
\fI_res\fP 选项的描述)。
.PP
\fBres_nquerydomain\fP() 和 \fBres_querydomain\fP() 函数在 \fIname\fP 和 \fIdomain\fP 的串联上使用
\fBres_nquery\fP()/\fBres_query\fP() 进行查询。
.PP
下面的函数是 \fBres_nquery\fP()/\fBres_query\fP() 使用的低级例程。
.PP
\fBres_nmkquery\fP() 和 \fBres_mkquery\fP() 函数在 \fIbuf\fP 中为域名 \fIdname\fP 构造一条长度为
\fIbuflen\fP 的查询消息。 查询类型 \fIop\fP 为以下之一 (通常为 \fBQUERY\fP):
.TP 
\fBQUERY\fP
标准查询。
.TP 
\fBIQUERY\fP
.\" commit e4e794841e3140875f2aa86b90e2ada3d61e1244
逆向查询。 这个选项在 glibc 2.26 中被删除了，因为它已经很长时间没有被 DNS 服务器支持了。
.TP 
\fBNS_NOTIFY_OP\fP
通知次级 SOA (授权开始) 更改。
.PP
\fInewrr\fP 当前未使用。
.PP
\fBres_nsend\fP() 和 \fBres_send\fP() 函数发送在 \fImsg\fP 中给出的长度为 \fImsglen\fP 的预格式化查询，并在
\fIanswer\fP 中返回长度为 \fIanslen\fP 的答案。 如果尚未调用，他们将调用 \fBres_ninit\fP()/\fBres_init\fP()。
.PP
\fBdn_comp\fP() 函数将域名 \fIexp_dn\fP 压缩后存放在长度为 \fIlength\fP 的缓冲区 \fIcomp_dn\fP 中。 压缩使用指针数组
\fIdnptrs\fP 指向当前消息中先前压缩的名称。 第一个指针指向消息的开头，列表以 NULL 结尾。 数组的界限由 \fIlastdnptr\fP 指定。
如果 \fIdnptr\fP 为 NULL，则不压缩域名。 如果 \fIlastdnptr\fP 为 NULL，则不更新标签列表。
.PP
\fBdn_expand\fP() 函数将压缩域名 \fIcomp_dn\fP 扩展为完整域名，放入大小为 \fIlength\fP 的缓冲区 \fIexp_dn\fP 中。
压缩名称包含在查询或回复消息中，\fImsg\fP 指向消息的开头。
.PP
解析器例程使用 \fI__res_state\fP 结构体中包含的配置和状态信息 (或者作为 \fIstatep\fP 参数传递，或者在全局变量 \fI_res\fP
中，在较旧的不可重入函数的情况下)。 通常由用户操作的结构体的唯一字段是 \fIoptions\fP 字段。 该字段可以包含以下选项的按位 "OR":
.TP 
\fBRES_INIT\fP
如果已调用 \fBres_ninit\fP() 或 \fBres_init\fP()，则为真。
.TP 
\fBRES_DEBUG\fP
.\" See resolv/README.
.\" Support for RES_DEBUG was made conditional in glibc 2.2.
打印调试信息。 此选项仅在 glibc 构建时启用调试时可用，这不是默认设置。
.TP 
\fBRES_AAONLY\fP (unimplemented; deprecated in glibc 2.25)
只接受权威答案。 \fBres_send\fP() 继续，直到找到权威答案或返回错误。 这个选项存在但直到 glibc 2.24 才实现; 自 glibc
2.25 以来，它已被弃用，并且它的使用会产生警告。
.TP 
\fBRES_USEVC\fP
使用 TCP 连接进行查询而不是 UDP 数据报。
.TP 
\fBRES_PRIMARY\fP (unimplemented; deprecated in glibc 2.25)
只查询主域名服务器。 这个选项存在但直到 glibc 2.24 才实现; 自 glibc 2.25 以来，它已被弃用，并且它的使用会产生警告。
.TP 
\fBRES_IGNTC\fP
忽略截断错误。 不要重试 TCP。
.TP 
\fBRES_RECURSE\fP
在查询中设置递归所需位。 递归是由域名服务器进行的，不是 \fBres_send\fP()。 [Enabled by default].
.TP 
\fBRES_DEFNAMES\fP
如果设置，\fBres_search\fP() 会将默认域名追加到单个组件名称 \[em]，即那些不包含点的名称。 [Enabled by default].
.TP 
\fBRES_STAYOPEN\fP
与 \fBRES_USEVC\fP 一起使用以在查询之间保持 TCP 连接打开。
.TP 
\fBRES_DNSRCH\fP
如果设置，\fBres_search\fP() 将在当前域和父域中搜索主机名。 \fBgethostbyname\fP(3) 使用此选项。 [Enabled by
default].
.TP 
\fBRES_INSECURE1\fP
接受来自错误服务器的响应。 这可用于检测潜在的安全隐患，但您需要在启用调试的情况下编译 glibc 并使用 \fBRES_DEBUG\fP 选项
(仅用于调试目的)。
.TP 
\fBRES_INSECURE2\fP
接受包含错误查询的响应。 这可用于检测潜在的安全隐患，但您需要在启用调试的情况下编译 glibc 并使用 \fBRES_DEBUG\fP 选项
(仅用于调试目的)。
.TP 
\fBRES_NOALIASES\fP
禁止使用 \fBHOSTALIASES\fP 环境变量。
.TP 
\fBRES_USE_INET6\fP
在 \fBgethostbyname\fP(3) 函数内的 A 查询之前尝试 AAAA 查询，如果未找到 AAAA 记录但存在 A 记录集，则在 IPv6
"tunneled form" 中尝试 map IPv4 响应。 从 glibc 2.25 开始，这个选项被弃用，它的使用会产生警告; 应用程序应该使用
\fBgetaddrinfo\fP(3)，而不是 \fBgethostbyname\fP(3)。
.TP 
\fBRES_ROTATE\fP
导致从列出的名称服务器中循环选择名称服务器。 这具有在所有列出的服务器之间分散查询负载的效果，而不是让所有客户端每次都先尝试第一个列出的服务器。
.TP 
\fBRES_NOCHECKNAME\fP (unimplemented; deprecated in glibc 2.25)
禁用对传入主机名和邮件名称的现代 BIND 检查是否存在无效字符，例如下划线 (_)、非 ASCII 或控制字符。 这个选项在 glibc 2.24
之前一直存在; 自 glibc 2.25 以来，它已被弃用，并且它的使用会产生警告。
.TP 
\fBRES_KEEPTSIG\fP (unimplemented; deprecated in glibc 2.25)
不要剥离 TSIG 记录。 这个选项存在但直到 glibc 2.24 才实现; 自 glibc 2.25 以来，它已被弃用，并且它的使用会产生警告。
.TP 
\fBRES_BLAST\fP (unimplemented; deprecated in glibc 2.25)
同时递归地向所有服务器发送每个查询。 这个选项存在但直到 glibc 2.24 才实现; 自 glibc 2.25
以来，它已被弃用，并且它的使用会产生警告。
.TP 
\fBRES_USEBSTRING\fP (glibc 2.3.4 to glibc 2.24)
使用 RFC 2673 中描述的位标签格式进行反向 IPv6 查找; 如果未设置此选项 (默认设置)，则使用半字节格式。 该选项在 glibc 2.25
中被删除，因为它依赖于一个从未在 Internet 上部署的向后不兼容的 DNS 扩展。
.TP 
\fBRES_NOIP6DOTINT\fP (glibc 2.24 and earlier)
在 IPv6 反向查找中使用 \fIip6.arpa\fP 区域而不是 \fIip6.int\fP，后者自 glibc 2.3.4 以来已被弃用。 此选项存在并包括
glibc 2.24，默认情况下处于启用状态。 在 glibc 2.25 中，这个选项被移除了。
.TP 
\fBRES_USE_EDNS0\fP (since glibc 2.6)
启用对 RFC 2671 中描述的 DNS 扩展 (EDNS0) 的支持。
.TP 
\fBRES_SNGLKUP\fP (since glibc 2.10)
默认情况下，glibc 从 glibc 2.9 开始在并行中执行 IPv4 和 IPv6 查找。 某些设备 DNS
服务器无法正确处理这些查询并使请求超时。 此选项禁用该行为并使 glibc 顺序执行 IPv6 和 IPv4 请求 (以解析过程的一些减慢为代价)。
.TP 
\fBRES_SNGLKUPREOP\fP
启用 \fBRES_SNGLKUP\fP 选项后，为每个请求打开一个新套接字。
.TP 
\fBRES_USE_DNSSEC\fP
在 OPT 记录中使用带有 OK 位的 DNSSEC。 该选项表示 \fBRES_USE_EDNS0\fP。
.TP 
\fBRES_NOTLDQUERY\fP
不要将不合格的名称查找为顶级域 (TLD)。
.TP 
\fBRES_DEFAULT\fP
.\"
默认选项表示: \fBRES_RECURSE\fP、\fBRES_DEFNAMES\fP、\fBRES_DNSRCH\fP 和 \fBRES_NOIP6DOTINT\fP。
.SH "RETURN VALUE"
\fBres_ninit\fP() 和 \fBres_init\fP() 函数在成功时返回 0，如果发生错误则返回 \-1。
.PP
\fBres_nquery\fP()、\fBres_query\fP()、\fBres_nsearch\fP()、\fBres_search\fP()、\fBres_nquerydomain\fP()、\fBres_querydomain\fP()、\fBres_nmkquery\fP()、\fBres_mkquery\fP()、\fBres_nsend\fP()
和 \fBres_send\fP() 函数返回响应的长度，如果发生错误则返回 \-1。
.PP
\fBdn_comp\fP() 和 \fBdn_expand\fP() 函数返回压缩名称的长度，如果发生错误则返回 \-1。
.PP
在从
\fBres_nquery\fP()、\fBres_query\fP()、\fBres_nsearch\fP()、\fBres_search\fP()、\fBres_nquerydomain\fP()
或 \fBres_querydomain\fP() 返回错误的情况下，可以参考全局变量 \fIh_errno\fP (参见
\fBgethostbyname\fP(3))) 来确定错误原因。
.SH FILES
.TP 
\fI/etc/resolv.conf\fP
解析器配置文件
.TP 
\fI/etc/host.conf\fP
解析器配置文件
.SH ATTRIBUTES
有关本节中使用的术语的解释，请参见 \fBattributes\fP(7)。
.ad l
.nh
.TS
allbox;
lbx lb lb
l l l.
Interface	Attribute	Value
T{
\fBres_ninit\fP(),
\fBres_nclose\fP(),
\fBres_nquery\fP(),
\fBres_nsearch\fP(),
\fBres_nquerydomain\fP(),
\fBres_nsend\fP()
T}	Thread safety	MT\-Safe locale
T{
\fBres_nmkquery\fP(),
\fBdn_comp\fP(),
\fBdn_expand\fP()
T}	Thread safety	MT\-Safe
.TE
.hy
.ad
.sp 1
.SH STANDARDS
4.3BSD.
.SH "SEE ALSO"
\fBgethostbyname\fP(3), \fBresolv.conf\fP(5), \fBresolver\fP(5), \fBhostname\fP(7),
\fBnamed\fP(8)
.PP
The GNU C library source file \fIresolv/README\fP.
.PP
.SH [手册页中文版]
.PP
本翻译为免费文档；阅读
.UR https://www.gnu.org/licenses/gpl-3.0.html
GNU 通用公共许可证第 3 版
.UE
或稍后的版权条款。因使用该翻译而造成的任何问题和损失完全由您承担。
.PP
该中文翻译由 wtklbm
.B <wtklbm@gmail.com>
根据个人学习需要制作。
.PP
项目地址:
.UR \fBhttps://github.com/wtklbm/manpages-chinese\fR
.ME 。
