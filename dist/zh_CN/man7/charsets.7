.\" -*- coding: UTF-8 -*-
.\" Copyright (c) 1996 Eric S. Raymond <esr@thyrsus.com>
.\" and Copyright (c) Andries Brouwer <aeb@cwi.nl>
.\"
.\" SPDX-License-Identifier: GPL-2.0-or-later
.\"
.\" This is combined from many sources, including notes by aeb and
.\" research by esr.  Portions derive from a writeup by Roman Czyborra.
.\"
.\" Changes also by David Starner <dstarner98@aasaa.ofe.org>.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH charsets 7 2023\-02\-05 "Linux man\-pages 6.03" 
.SH NAME
charsets \- 字符集标准和国际化
.SH DESCRIPTION
本手册页概述了不同的字符集标准，以及在 Unicode 变得无处不在之前它们是如何在 Linux 上使用的。
其中一些信息对使用遗留系统和文档的人仍然有帮助。
.PP
讨论的标准包括 ASCII、GB 2312、ISO 8859、JIS、KOI8\-R、KS 和 Unicode。
.PP
主要强调的是语言环境字符集实际使用的字符集，而不是可以在其他系统的数据中找到的无数其他字符集。
.SS ASCII
ASCII (American Standard Code For Information Interchange) 是最初的 7
位字符集，最初是为美式英语设计的。 也称为 US\-ASCII。 它目前由 ISO 646:1991 IRV (国际引用版本) 标准描述。
.PP
出现了各种 ASCII 变体，用其他货币符号替换美元符号，用非英语字母字符替换标点符号，以在 7 位中覆盖德语、法语、西班牙语和其他语言。 全部弃用;
glibc 不支持其字符集不是 ASCII 真正超集的语言环境。
.PP
由于 Unicode 在使用 UTF\-8 时与 ASCII 兼容，纯 ASCII 文本在现代 UTF\-8 使用系统上仍然可以正确呈现。
.SS "ISO 8859"
ISO 8859 是一系列 15 个 8 位字符集，所有这些字符集的低半部分 (7\-bit) 都有 ASCII，位置 128 到 159
有不可见的控制字符，位置 160\[en] 255 有 96 个固定宽度的图形。
.PP
其中，最重要的是 ISO 8859\-1 ("Latin Alphabet No. 1"/Latin\-1)。 它被不同的系统广泛采用和支持，并逐渐被
Unicode 取代。 ISO 8859\-1 字符也是 Unicode 的前 256 个字符。
.PP
其他 8859 字符集的控制台支持可通过用户模式实用工具在 Linux 下获得 (例如修改键盘绑定和 EGA 图形表的
\fBsetfont\fP(8))，并在控制台驱动程序中使用 "user mapping" 字体表。
.PP
以下是每个字符集的简要说明:
.TP 
8859\-1 (Latin\-1)
Latin\-1
涵盖多种欧洲语言，例如阿尔巴尼亚语、巴斯克语、丹麦语、英语、法罗语、加利西亚语、冰岛语、爱尔兰语、意大利语、挪威语、葡萄牙语、西班牙语和瑞典语。
连字荷兰语 Ĳ/ĳ、法语 œ 和旧式 `德语` 引号的缺失被认为是可以容忍的。
.TP 
8859\-2 (Latin\-2)
Latin\-2 支持多种拉丁书写的中欧和东欧语言，例如波斯尼亚语、克罗地亚语、捷克语、德语、匈牙利语、波兰语、斯洛伐克语和斯洛文尼亚语。
用ş/ţ代替罗马尼亚语的ş/ş被认为是可以接受的。
.TP 
8859\-3 (Latin\-3)
Latin\-3 旨在涵盖世界语、马耳他语和土耳其语，但后来 8859\-9 将其替换为土耳其语。
.TP 
8859\-4 (Latin\-4)
Latin\-4 为爱沙尼亚语、拉脱维亚语和立陶宛语等北欧语言引入了字母，但被 8859\-10 和 8859\-13 取代。
.TP 
8859\-5
支持保加利亚语、白俄罗斯语、马其顿语、俄语、塞尔维亚语和 (几乎完全) 乌克兰语的西里尔字母。 它从未被广泛使用，请参见下面对
KOI8\-R/KOI8\-U 的讨论。
.TP 
8859\-6
是为阿拉伯语创建的。 8859\-6 字形表是独立字母形式的固定字体，但适当的显示引擎应该使用适当的初始、中间和最终形式将它们组合起来。
.TP 
8859\-7
于 1987 年为现代希腊语创建，于 2003 年更新。
.TP 
8859\-8
支持不带 niqud (标点符号) 的现代希伯来语。 Niqud 和成熟的圣经希伯来语不在该字符集的作用域内。
.TP 
8859\-9 (Latin\-5)
这是 Latin\-1 的变体，用土耳其字母替换冰岛字母。
.TP 
8859\-10 (Latin\-6)
Latin\-6 添加了 Latin\-4 中缺失的因纽特 (Greenlandic) 和萨米 (Lappish) 字母，以覆盖整个北欧地区。
.TP 
8859\-11
支持泰语字母，几乎与 TIS\-620 标准相同。
.TP 
8859\-12
该字符集不存在。
.TP 
8859\-13 (Latin\-7)
支持波罗的海沿岸语言; 特别是，它包括 Latin\-4 中没有的拉脱维亚字符。
.TP 
8859\-14 (Latin\-8)
这是凯尔特字符集，涵盖古爱尔兰语、曼克斯语、盖尔语、威尔士语、康沃尔语和布列塔尼语。
.TP 
8859\-15 (Latin\-9)
Latin\-9 与广泛使用的 Latin\-1 类似，但用 Latin\-1 中缺失的欧元符号以及法语和芬兰语字母替换了一些不太常见的符号。
.TP 
8859\-16 (Latin\-10)
这个字符集涵盖了很多东南欧语言，最重要的是比 Latin\-2 更完整地支持罗马尼亚语。
.SS "KOI8\-R / KOI8\-U"
KOI8\-R 是 Unicode 之前在俄罗斯流行的非 ISO 字符集。 下半部分是 ASCII; 上面是一个比 ISO 8859\-5
设计得更好的西里尔字符集。 KOI8\-U，基于 KOI8\-R，对乌克兰语的支持更好。 与 ISO 8859 系列不同，这些设置都不兼容
ISO\-2022。
.PP
通过修改键盘绑定和 EGA 图形表的用户模式实用工具，在 Linux 下可获得对 KOI8\-R 的控制台支持，并在控制台驱动程序中使用 "user
mapping" 字体表。
.SS "GB 2312"
GB 2312 是用于表示简体中文的中国大陆国家标准字符集。 就像 JIS X 0208 一样，字符被映射到用于构造 EUC\-CN 的 94x94
两字节矩阵。 EUC\-CN 是 Linux 最重要的编码，包括 ASCII 和 GB 2312。 请注意，EUC\-CN 通常称为 GB、GB 2312
或 CN\-GB。
.SS Big5
.\" Thanks to Tomohiro KUBOTA for the following sections about
.\" national standards.
Big5 是台湾用来表达繁体中文的流行字符集。 (Big5 既是字符集又是编码。) 它是 ASCII 的超集。 非 ASCII 字符以两个字节表示。
字节 0xa1\[en] 0xfe 用作双字节字符的前导字节。 Big5 及其扩展在台湾和香港被广泛使用。 它不符合 ISO 2022 标准。
.SS "JIS X 0208"
JIS X 0208 是日本国家标准字符集。 虽然还有一些日本国家标准字符集 (如 JIS X 0201、JIS X 0212 和 JIS X
0213)，但这是最重要的一个。 字符被映射到一个 94x94 的双字节矩阵中，其每个字节都在 0x21\[en] 0x7e 范围内。 请注意，JIS
X 0208 是字符集，而不是编码。 这意味着 JIS X 0208 本身不用于表达文本数据。 JIS X 0208 用作构建编码的组件，例如
EUC\-JP、Shift_JIS 和 ISO\-2022\-JP。 EUC\-JP 是 Linux 最重要的编码，包括 ASCII 和 JIS X 0208。
在 EUC\-JP 中，JIS X 0208 字符用两个字节表示，每个字节是 JIS X 0208 代码加上 0x80。
.SS "KS X 1001"
KS X 1001 是韩国国家标准字符集。 正如 JIS X 0208 一样，字符被映射到一个 94x94 的两字节矩阵中。 KS X 1001 与
JIS X 0208 一样用作构建 EUC\-KR、Johab 和 ISO\-2022\-KR 等编码的组件。 EUC\-KR 是 Linux
最重要的编码，包括 ASCII 和 KS X 1001。 KS C 5601 是 KS X 1001 的旧名称。
.SS "ISO 2022 and ISO 4873"
ISO 2022 和 4873 标准描述了基于 VT100 实践的字体控制模型。 这个模型是 (partially)，Linux 内核和
\fBxterm\fP(1) 都支持它。 已经定义了几种基于 ISO 2022 的字符编码，尤其是对于日语。
.PP
图形字符集有 4 种，分别为 G0、G1、G2、G3，其中一种是当前高位为零的代码字符集 (初始为 G0)，一种是当前高位代码的字符集位一 (最初为
G1)。 每个图形字符集有 94 或 96 个字符，本质上是一个 7 位字符集。 它使用代码 040\[en] 0177 (041\[en]0176)
或 0240\[en] 0377 (0241\[en]0376)。 G0 的大小始终为 94 并使用代码 041\[en] 0176。
.PP
字符集之间的切换是使用 shift 函数 \fB\[ha]N\fP (SO or LS1), \fB\[ha]O\fP (SI or LS0), ESC n
(LS2), ESC o (LS3), ESC N (SS2), ESC O (SS3), ESC\[ti] (LS1R), ESC} (LS2R),
电调 | (LS3R)。 函数 LS\fIn\fP 使字符集 G\fIn\fP 成为高位零代码的当前字符集。 函数 LS\fIn\fPR 使字符集 G\fIn\fP
成为当前高位代码的字符集。 函数 SS\fIn\fP 使字符集 G\fIn\fP (\fIn\fP=2 或 3) 仅用于下一个字符的当前字符集 (无论其高位的值如何)。
.PP
一个 94 字符集通过转义序列 ESC (xx (for G0), ESC) xx (for G1), ESC * xx (for G2), ESC +
xx (for G3) 指定为 G\fIn\fP 字符集，其中 xx 是在 ISO 2375 国际编码字符集注册簿中找到的一个符号或一对符号。 例如，ESC
(@选择 ISO 646 字符集为 G0，ESC (A 选择英国标准字符集 (用井号代替数字符号)，ESC (B 选择 ASCII
(用美元代替货币符号)，ESC (M 为非洲语言选择字符集，ESC (!A 选择古巴字符集，依此类推。
.PP
96 个字符的字符集由转义序列 ESC\-xx (对于 G1)、ESC 指定为 G\fIn\fP 字符集。xx (对于 G2) 或 ESC/xx (对于
G3)。 例如，ESC\-G 选择希伯来字母作为 G1。
.PP
多字节字符集通过转义序列 ESC $ xx 或 ESC $ (xx (x01X), ESC $) xx (G1), ESC $ * xx (G2),
ESC $ + xx (G3)。 例如，ESC $ (C 为 G0 选择朝鲜语字符集。 ESC $ B 选择的日语字符集有 ESC&@ESC $ B
选择的更新版本。
.PP
ISO 4873 规定了更窄的字符集使用范围，其中 G0 是固定的 (始终为 ASCII)，因此 G1、G2 和 G3 只能针对设置了高阶位的代码调用。
特别是 \fB\[ha]N\fP 和 \fB\[ha]O\fP 不再使用，ESC ( xx 只能与 xx=B 和 ESC 一起使用) xx, ESC * xx,
ESC + xx 等同于 ESC\-xx, ESC。xx，ESC/xx，分别。
.SS TIS\-620
TIS\-620 是泰国国家标准字符集，是 ASCII 的超集。 与 ISO 8859 系列一样，泰语字符映射到 0xa1\[en] 0xfe。
.SS Unicode
Unicode (ISO 10646) 是一种标准，旨在明确表示每种人类语言中的每个字符。 Unicode 的结构体允许 20.1
位对每个字符进行编码。 由于大多数计算机不包含 20.1 位整数，因此 Unicode 通常在内部编码为 32 位整数和一系列 16 位整数
(UTF\-16) (仅在编码某些罕见字符时需要两个 16 位整数) 或一系列 8 位字节 (UTF\-8)。
.PP
Linux 表示使用 8 位 Unicode 转换格式 (UTF\-8) 的 Unicode。 UTF\-8 是 Unicode 的可变长度编码。 它用 1
字节编码 7 位，2 字节编码 11 位，3 字节编码 16 位，4 字节编码 21 位，5 字节编码 26 位，6 字节编码 31 位。
.PP
让 0,1,x 代表零、一或任意位。 字节 0xxxxxxx 代表 Unicode 00000000 0xxxxxxx，它编码与 ASCII
0xxxxxxx 相同的符号。 因此，ASCII 不变地进入 UTF\-8，而仅使用 ASCII 的人不会注意到任何变化: 代码和文件大小都没有变化。
.PP
一个字节 110xxxxx 是一个 2 字节码的开始，110xxxxx 10yyyyyy 组装成 00000xxx xxyyyyyy。 一个字节
1110xxxx 是一个 3 字节码的开始，1110xxxx 10yyyyyy 10zzzzzz 拼装成 xxxxyyyy yyzzzzzz。 (当
UTF\-8 用于对 31 位 ISO 10646 进行编码时，此进程将继续进行直至 6 字节代码。)
.PP
对于 ISO 8859 字符集中的大多数文本，这意味着 ASCII 之外的字符现在使用两个字节进行编码。
这往往只会将普通文本文件扩展百分之一或百分之二。 对于俄语或希腊语文本，这会将普通文本文件扩展 100%，因为这些语言的文本大多不在 ASCII
范围内。 对于日本用户，这意味着现在常用的 16 位代码将占用三个字节。 虽然存在从某些字符集 (尤其是 ISO 8859\-1) 到 Unicode
的算法转换，但一般转换需要随身携带转换表，这对于 16 位代码来说可能非常大。
.PP
注意 UTF\-8 是自同步的: 10xxxxxx 是一个尾部，任何其他字节都是一个代码的头部。 请注意，ASCII 字节出现在 UTF\-8
流中的唯一方式就是它们本身。 特别是，没有嵌入式 NUL (\[aq]\e0\[aq]) 或 \[aq]/\[aq] 构成某些较大代码的一部分。
.PP
由于 ASCII，尤其是 NUL 和 \[aq]/\[aq] 未更改，因此内核不会注意到正在使用 UTF\-8。 它根本不关心它正在处理的字节代表什么。
.PP
Unicode 数据流的呈现通常通过 "subfont" 表处理，其中 map 是 Unicode 到字形的子集。 内核在内部使用 Unicode
来描述加载到视频 RAM 中的子字体。 这意味着在 UTF\-8 模式下的 Linux 控制台中，可以使用具有 512 个不同符号的字符集。
这对于日语、中文和韩语来说还不够，但对于大多数其他用途来说已经足够了。
.SH "SEE ALSO"
\fBiconv\fP(1), \fBascii\fP(7), \fBiso_8859\-1\fP(7), \fBunicode\fP(7), \fButf\-8\fP(7)
.PP
.SH [手册页中文版]
.PP
本翻译为免费文档；阅读
.UR https://www.gnu.org/licenses/gpl-3.0.html
GNU 通用公共许可证第 3 版
.UE
或稍后的版权条款。因使用该翻译而造成的任何问题和损失完全由您承担。
.PP
该中文翻译由 wtklbm
.B <wtklbm@gmail.com>
根据个人学习需要制作。
.PP
项目地址:
.UR \fBhttps://github.com/wtklbm/manpages-chinese\fR
.ME 。
