.\" -*- coding: UTF-8 -*-
.PU
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH bzip2 1   
.SH NAME
bzip2、bunzip2 \- 块排序文件压缩器，v1.0.8
.br
bzcat \- 将文件解压缩到 stdout
.br
bzip2recover \- 从损坏的 bzip2 文件中恢复数据

.SH SYNOPSIS
.ll +8
\fBbzip2\fP [\fB \-cdfkqstvzVL123456789 \fP] [ \fIfilenames \&...\fP ]
.ll -8
.br
\fBbunzip2\fP [\fB \-fkvsVL \fP] [ \fIfilenames \&...\fP ]
.br
\fBbzcat\fP [\fB \-s \fP] [ \fIfilenames \&...\fP ]
.br
\fBbzip2recover\fP \fIfilename\fP

.SH DESCRIPTION
\fIbzip2\fP 使用 Burrows\-Wheeler 块排序文本压缩算法和霍夫曼编码来压缩文件。 压缩通常比更传统的 LZ77/LZ78\-based
压缩器实现的压缩效果要好得多，并且接近 PPM 系列统计压缩器的性能。

命令行选项与 \fIGNU gzip,\fP 的命令行选项非常相似，但并不完全相同。

\fIbzip2\fP 期望文件名列表伴随命令行标志。 每个文件都被其自身的压缩版本替换，名称为 "original_name.bz2"。
每个压缩文件都具有与相应原始文件相同的修改日期、权限和所有权 (如果可能)，以便在解压缩时可以正确恢复这些属性。
文件名处理是幼稚的，因为在缺乏这些概念或具有严格文件名长度限制的文件系统 (例如 MS\-DOS) 中没有保留原始文件名、权限、所有权或日期的机制。

\fIbzip2\fP 和 \fIbunzip2\fP 默认情况下不会覆盖现有文件。 如果您希望发生这种情况，请指定 \-f 标志。

如果未指定文件名，\fIbzip2\fP 将从标准输入压缩到标准输出。 在这种情况下，\fIbzip2\fP
将拒绝将压缩输出写入最终端，因为这将是完全不可理解的，因此毫无意义。

\fIbunzip2\fP (或 \fIbzip2 \-d)\fP 解压缩所有指定的文件。 不是由 \fIbzip2\fP 创建的文件将被检测和忽略，并发出警告。
\fIbzip2\fP 尝试从压缩文件的文件名中猜测解压缩文件的文件名，如下所示:

       filename.bz2 成为文件名
       filename.bz 成为文件名
       filename.tbz2 变成 filename.tar
       filename.tbz 变成 filename.tar
       任何其他名称变为 anyothername.out

如果文件不是以其中一种可识别的结尾结尾，\fI.bz2,\fP \fI.bz,\fP \fI.tbz2\fP 或 \fI.tbz,\fP \fIbzip2\fP
会抱怨它无法猜测原始文件的名称，并使用，追加 \fI.out\fP 的原始名称。

与压缩一样，不提供文件名会导致从标准输入解压缩到标准输出。

\fIbunzip2\fP 将正确解压缩由两个或多个压缩文件串联而成的文件。 结果是相应的未压缩文件的串联。 还支持串联压缩文件的完整性测试 (\-t)。

您还可以通过提供 \-c 标志将文件压缩或解压缩到标准输出。 多个文件可以像这样被压缩和解压。 产生的输出按顺序馈送到 stdout。
以这种方式压缩多个文件会生成一个包含多个压缩文件表示的流。 只有 \fIbzip2\fP 版本 0.9.0 或更高版本才能正确解压缩这样的流。
\fIbzip2\fP 的早期版本将在解压缩流中的第一个文件后停止。

\fIbzcat\fP (或 \fIbzip2 \-dc)\fP 将所有指定文件解压缩到标准输出。

\fIbzip2\fP 将从环境变量 \fIBZIP2\fP 和 \fIBZIP,\fP 中按顺序读取参数，并在从命令行读取任何参数之前处理它们。
这提供了一种提供默认参数的便捷方式。

始终执行压缩，即使压缩文件比原始文件稍大。 小于大约 100 字节的文件往往会变大，因为压缩机制在 50 字节左右有大量开销。 随机数据
(包括大多数文件压缩器的输出) 以每字节大约 8.05 位编码，扩展了大约 0.5%。

作为对您的保护的自我检查，\fIbzip2\fP 使用 32 位 CRC 来确保文件的解压缩版本与原始文件相同。 这可以防止压缩数据损坏，并防止
\fIbzip2\fP 中未检测到的错误 (希望可能性很小)。 数据损坏未被发现的可能性微乎其微，每个处理的文件大约有四十亿分之一的机会。
但是请注意，检查是在解压缩时进行的，因此它只能告诉您出现了问题。 它无法帮助您恢复原始的未压缩数据。 您可以使用 \fIbzip2recover\fP
尝试从损坏的文件中恢复数据。

返回值: 0 表示正常退出，1 表示环境问题 (未找到文件、无效标志、I/O 错误、&c)，2 表示损坏的压缩文件，3 表示内部一致性错误 (例如错误)
导致 \fIbzip2\fP panic。

.SH OPTIONS
.TP 
\fB\-c \-\-stdout\fP
压缩或解压缩到标准输出。
.TP 
\fB\-d \-\-decompress\fP
强行减压。 \fIbzip2,\fP \fIbunzip2\fP 和 \fIbzcat\fP 实际上是同一个程序，采取什么动作的决定是根据使用哪个名称来完成的。
此标志覆盖该机制，并强制 \fIbzip2\fP 解压缩。
.TP 
\fB\-z \-\-compress\fP
\-d 的补充: 强制压缩，不管调用名称如何。
.TP 
\fB\-t \-\-test\fP
检查指定 file(s) 的完整性，但不解压它们。 这样就真正进行了一次试探性的减压，把结果扔掉了。
.TP 
\fB\-f \-\-force\fP
强制覆盖输出文件。 通常，\fIbzip2\fP 不会覆盖现有的输出文件。 还强制 \fIbzip2\fP 断开文件的硬链接，否则它不会这样做。

bzip2 通常拒绝解压缩没有正确魔术头字节的文件。 但是，如果强制 (\-f)，它将通过未修改的此类文件。 这就是 GNU gzip 的行为方式。
.TP 
\fB\-k \-\-keep\fP
在压缩或解压缩期间保留 (不要删除) 输入文件。
.TP 
\fB\-s \-\-small\fP
减少内存使用，用于压缩、解压和测试。 使用修改后的算法对文件进行解压缩和测试，该算法只需要每个块字节 2.5 字节。 这意味着任何文件都可以在
2300k 的内存中解压缩，尽管速度大约是正常速度的一半。

在压缩期间，\-s 选择 200k 的块大小，这将内存使用限制在大约相同的数字，但会牺牲压缩率。 简而言之，如果您的机器内存不足 (8
兆字节或更少)，请对所有内容使用 \-s。 请参见下面的内存管理。
.TP 
\fB\-q \-\-quiet\fP
抑制不必要的警告消息。 与 I/O 错误和其他关键事件有关的消息将不会被抑制。
.TP 
\fB\-v \-\-verbose\fP
详细模式 \-\- 显示每个处理文件的压缩率。 此外，\-v 会增加详细级别，输出大量主要用于诊断目的的信息。
.TP 
\fB\-L \-\-license \-V \-\-version\fP
显示软件版本、许可条款和条件。
.TP 
\fB\-1 (or \-\-fast) to \-9 (or \-\-best)\fP
将块大小设置为 100 k、200 k ..  压缩时为 900 k。 解压时无效。 请参见下面的内存管理。 \-\-fast 和 \-\-best
别名主要用于 GNU gzip 兼容性。 特别是，\-\-fast 不会使事情变得更快。 而 \-\-best 仅选择默认行为。
.TP 
\fB\-\-\fP
将所有后续的参数视为文件名，即使它们以破折号开头。 这样您就可以处理名称以破折号开头的文件，例如: bzip2\-\-\-myfilename。
.TP 
\fB\-\-repetitive\-fast \-\-repetitive\-best\fP
这些标志在 0.9.5 及更高版本中是多余的。 它们对早期版本中的排序算法的行为提供了一些粗略的控制，这有时很有用。 0.9.5
及更高版本具有改进的算法，使这些标志变得无关紧要。

.SH "MEMORY MANAGEMENT"
\fIbzip2\fP 以块的形式压缩大文件。 块大小影响实现的压缩率以及压缩和解压缩所需的内存量。 标志 \-1 到 \-9 分别指定块大小为 100,000
字节到 900,000 字节 (默认值)。 在解压时，用于压缩的块大小从压缩文件的头部读取，然后 \fIbunzip2\fP
为自己分配刚好足够解压文件的内存。 由于块大小存储在压缩文件中，因此标志 \-1 到 \-9 与解压缩过程无关，因此会被忽略。

压缩和解压缩要求 (以字节为单位) 可以估计为:

       压缩: 400k + (8 x 块大小)

       解压缩: 100k + (4 x 块大小)，或
                      100k + (2.5 x 块大小)

较大的块大小会导致边际收益迅速递减。 大部分压缩来自前两三百 k 的块大小，在小型机器上使用 \fIbzip2\fP 时，这一事实值得牢记。
同样重要的是要理解，解压缩内存要求是在压缩时通过选择块大小来设置的。

对于使用默认 900k 块大小压缩的文件，\fIbunzip2\fP 将需要大约 3700 KB 来解压缩。 为了支持在 4
兆字节的机器上解压缩任何文件，\fIbunzip2\fP 有一个选项可以使用大约一半的内存进行解压缩，大约 2300 KB。
解压缩速度也减半，所以您应该只在必要时使用这个选项。 相关标志是 \-s。

通常，尝试使用内存限制允许的最大块大小，因为这样可以最大限度地实现压缩。 压缩和解压缩速度几乎不受块大小的影响。

另一个要点适用于适合单个块的文件 \-\- 这意味着您遇到的大多数文件都使用大块大小。 由于文件比块小，因此实际内存量与文件大小成正比。 例如，使用标志
\-9 压缩一个 20,000 字节长的文件将导致压缩器分配大约 7600k 的内存，但只涉及 400k + 20000 * 8=560 kbytes。
同样，解压缩器将分配 3700k，但仅触及 100k + 20000 * 4=180 kbytes。

下表总结了不同块大小的最大内存使用量。 还记录了卡尔加里文本压缩语料库的 14 个文件的总压缩大小，总计 3,141,622 字节。
本专栏给出了压缩如何随块大小变化的一些感受。 这些数字往往低估了较大文件的较大块大小的优势，因为语料库主要由较小的文件组成。

           压缩解压解压语料库
    Flag usage usage \-s usage 大小

     \-1      1200k       500k         350k      914704
     \-2      2000k       900k         600k      877703
     \-3      2800k      1300k         850k      860338
     \-4      3600k      1700k        1100k      846899
     \-5      4400k      2100k        1350k      845160
     \-6      5200k      2500k        1600k      838626
     \-7      6100k      2900k        1850k      834096
     \-8      6800k      3300k        2100k      828642
     \-9      7600k      3700k        2350k      828642

.SH "RECOVERING DATA FROM DAMAGED FILES"
\fIbzip2\fP 以块的形式压缩文件，通常为 900kbytes 长。 每个块都是独立处理的。 如果媒体或传输错误导致多块 .bz2
文件损坏，则可以从文件中未损坏的块中恢复数据。

每个块的压缩表示由 48 位模式分隔，这使得可以合理确定地找到块边界。 每个块还带有自己的 32 位 CRC，因此可以区分损坏的块和未损坏的块。

\fIbzip2recover\fP 是一个简单的程序，其目的是在 .bz2 文件中搜索块，并将每个块写到它自己的 .bz2 文件中。 然后您可以使用
\fIbzip2\fP \-t 来测试结果文件的完整性，并解压缩那些未损坏的文件。

\fIbzip2recover\fP 采用单个参数，损坏文件的名称，并写入包含提取块的多个文件
"rec00001file.bz2"、"rec00002file.bz2" 等。 输出文件名经过设计，以便在后续处理中使用通配符 (例如，"bzip2
\-dc rec*file.bz2 > recovered_data") 以正确的顺序处理文件。

\fIbzip2recover\fP 应该最适合处理大型 .bz2 文件，因为这些文件将包含许多块。
在损坏的单块文件上使用它显然是徒劳的，因为损坏的块无法恢复。
如果您希望将由于媒体或传输错误造成的任何潜在数据丢失降至最低，您可以考虑使用较小的块大小进行压缩。

.SH "PERFORMANCE NOTES"
压缩的排序阶段将文件中的相似字符串聚集在一起。 因此，包含非常长的重复符号的文件，如 "aabaabaabaab ..." (重复数百次)
可能比正常情况下压缩得更慢。 0.9.5 及以上版本在这方面比以前的版本要好得多。 最坏情况和平均情况压缩时间之比在 10:1 左右。
对于以前的版本，这个数字更像是 100:1。 如果需要，您可以使用 \-vvvv 选项来非常详细地监控进度。

减压速度不受这些现象的影响。

\fIbzip2\fP 通常会分配数兆字节的内存进行操作，然后以相当随机的方式对其进行充电。
这意味着压缩和解压缩的性能在很大程度上取决于您的机器可以处理缓存未命中的速度。
正因为如此，已经观察到对代码进行小的更改以降低未命中率会带来不成比例的大性能改进。 我想 \fIbzip2\fP 将在具有非常大缓存的机器上表现最佳。

.SH CAVEATS
I/O 错误消息并没有提供应有的帮助。 \fIbzip2\fP 努力检测 I/O 错误并干净地退出，但问题的详细信息有时看起来相当具有误导性。

本手册页适用于 \fIbzip2.\fP 版本的 1.0.8 此版本创建的压缩数据完全向前和向后兼容以前的公开版本，版本
0.1pl2、0.9.0、0.9.5、1.0.0、1.0.1、1.0.2 及更高版本，但有以下例外: 0.9.0 和以上可以正确解压多个串联的压缩文件。
0.1pl2 不能这样做; 它将在仅解压缩流中的第一个文件后停止。

1.0.2 之前的 \fIbzip2recover\fP 版本使用 32 位整数来表示压缩文件中的位位置，因此它们无法处理长度超过 512 兆字节的压缩文件。
1.0.2 及更高版本在某些支持它们的平台上使用 64 位整数 (GNU 支持的目标和 Windows)。 要确定 bzip2recover
是否在构建时有这样的限制，请在没有参数的情况下运行它。 在任何情况下，如果您可以将 MaybeUInt64 设置为无符号 64
位整数重新编译它，您就可以为自己构建一个无限版本。



.SH AUTHOR
朱利安苏厄德，jseward@acm.org。

https://sourceware.org/bzip2/

\fIbzip2\fP 中体现的想法 (至少) 归功于以下人员: Michael Burrows 和 David Wheeler
(用于块排序转换)、David Wheeler (再次用于 Huffman 编码器)、Peter Fenwick (用于结构化编码模型原始
\fIbzip,\fP 和许多改进)，以及 Alistair Moffat、Radford Neal 和 Ian Witten (对于原始 \fIbzip).\fP
中的算术编码器，我非常感谢他们的帮助、支持和建议。 请参见源代码分发中的手册以获取指向文档源的指针。 Christian von Roques
鼓励我寻找更快的排序算法，以加快压缩速度。 Bela Lubkin 鼓励我提高最坏情况下的压缩性能。 Donna Robinson 将文档 XML 化。
bz* 脚本源自 GNU gzip 的脚本。 许多人发送补丁，帮助解决可移植性问题，借出机器，提供建议并且通常提供帮助。
.PP
.SH [手册页中文版]
.PP
本翻译为免费文档；阅读
.UR https://www.gnu.org/licenses/gpl-3.0.html
GNU 通用公共许可证第 3 版
.UE
或稍后的版权条款。因使用该翻译而造成的任何问题和损失完全由您承担。
.PP
该中文翻译由 wtklbm
.B <wtklbm@gmail.com>
根据个人学习需要制作。
.PP
项目地址:
.UR \fBhttps://github.com/wtklbm/manpages-chinese\fR
.ME 。
