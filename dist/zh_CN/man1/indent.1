.\" -*- coding: UTF-8 -*-
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH INDENT 1   
.SH NAME
缩进 \- 通过插入或删除空格来改变 C 程序的外观。
.SH SYNOPSIS
\fBindent \fP [options] [input\-files]
.sp
\fBindent \fP [options] [single\-input\-file] [\-o output\-file]
.sp
\fBindent \fP \-\-version
.SH DESCRIPTION
此手册页是从文件 \fIindent.texinfo\fP 生成的。 这是 "The \fBindent\fP Manual" 的版本，用于缩进版本，最后更新。

\fBindent\fP 程序可用于使代码更易于阅读。 它还可以将 C 的一种编写风格转换为另一种编写风格。

\fBindent\fP 非常了解 C 的语法，但它也尝试处理不完整和格式错误的语法。

在版本 1.2 和更新的版本中，GNU 缩进样式是默认的。
.SH OPTIONS

.TP  4
\fB\-as\fP, \fB\-\-align\-with\-spaces\fP
如果使用制表符进行缩进，请使用空格进行对齐。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-bad\fP, \fB\-\-blank\-lines\-after\-declarations\fP
声明后强制空行。
.br
请参见 \fB\ BLANK\ LINES\fP。
.TP 
\fB\-bap\fP, \fB\-\-blank\-lines\-after\-procedures\fP
在过程体之后强制空行。
.br
请参见 \fB\ BLANK\ LINES\fP。
.TP 
\fB\-bbb\fP, \fB\-\-blank\-lines\-before\-block\-comments\fP
在块注释之前强制空行。
.br
请参见 \fB\ BLANK\ LINES\fP。
.TP 
\fB\-bbo\fP, \fB\-\-break\-before\-boolean\-operator\fP
更喜欢在 boolean 运算符之前打断长行。
.br
请参见 \fB\ BREAKING\ LONG\ LINES\fP。
.TP 
\fB\-bc\fP, \fB\-\-blank\-lines\-after\-commas\fP
在声明中逗号后强制换行。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-bl\fP, \fB\-\-braces\-after\-if\-line\fP
在 \fBif\fP 等之后放上大括号。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-blf\fP, \fB\-\-braces\-after\-func\-def\-line\fP
在函数定义行之后的行上放置大括号。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-bli\fP\fIn\fP, \fB\-\-brace\-indent\fP\fIn\fP
缩进大括号 \fIn\fP 空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-bls\fP, \fB\-\-braces\-after\-struct\-decl\-line\fP
在 \fBstruct\fP 声明行之后的行上放置大括号。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-br\fP, \fB\-\-braces\-on\-if\-line\fP
将大括号与 \fBif\fP 等对齐。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-brf\fP, \fB\-\-braces\-on\-func\-def\-line\fP
把大括号放在函数定义行上。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-brs\fP, \fB\-\-braces\-on\-struct\-decl\-line\fP
将大括号放在 \fBstruct\fP 声明行上。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-bs\fP, \fB\-\-Bill\-Shannon\fP, \fB\-\-blank\-before\-sizeof\fP
在 \fBsizeof\fP 和它的参数之间放一个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-c\fP\fIn\fP, \fB\-\-comment\-indentation\fP\fIn\fP
将注释放在 \fIn\fP 列中代码的右侧。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-cbi\fP\fIn\fP, \fB\-\-case\-brace\-indentation\fP\fIn\fP
在 case 标签后缩进大括号 N 个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-cd\fP\fIn\fP, \fB\-\-declaration\-comment\-column\fP\fIn\fP
将注释放在 \fIn\fP 列声明的右侧。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-cdb\fP, \fB\-\-comment\-delimiters\-on\-blank\-lines\fP
将注释定界符放在空行上。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-cdw\fP, \fB\-\-cuddle\-do\-while\fP
拥抱 \fBdo {} while;\fP 和前面的 \(oq}\(cq.
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-ce\fP, \fB\-\-cuddle\-else\fP
拥抱 else 和前面的 \(oq}\(cq.
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-ci\fP\fIn\fP, \fB\-\-continuation\-indentation\fP\fIn\fP
\fIn\fP 空格的连续缩进。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-cli\fP\fIn\fP, \fB\-\-case\-indentation\fP\fIn\fP
\fIn\fP 空格的大小写标签缩进。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-cp\fP\fIn\fP, \fB\-\-else\-endif\-column\fP\fIn\fP
将注释放在 \fIn\fP 列中 \fB#else\fP 和 \fB #endif\fP 语句的右侧。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-cs\fP, \fB\-\-space\-after\-cast\fP
在强制转换运算符后放置一个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-d\fP\fIn\fP, \fB\-\-line\-comments\-indentation\fP\fIn\fP
将不在代码右侧的注释缩进设置为 \fIn\fP 空格。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-bfda\fP, \fB\-\-break\-function\-decl\-args\fP
在声明中的所有参数之前换行。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-bfde\fP, \fB\-\-break\-function\-decl\-args\-end\fP
在声明中的最后一个参数之后换行。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-dj\fP, \fB\-\-left\-justify\-declarations\fP
如果使用 \-cd 0，则声明后的注释在声明后面对齐。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-di\fP\fIn\fP, \fB\-\-declaration\-indentation\fP\fIn\fP
将变量放入 \fIn\fP 列。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-fc1\fP, \fB\-\-format\-first\-column\-comments\fP
在第一列格式化注释。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-fca\fP, \fB\-\-format\-all\-comments\fP
不要禁用注释的所有格式。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-fnc\fP, \fB\-\-fix\-nested\-comments\fP
修复嵌套评论。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-gnu\fP, \fB\-\-gnu\-style\fP
使用 GNU 编码风格。 这是默认设置。
.br
请参见 \fB\ COMMON\ STYLES\fP。
.TP 
\fB\-gts\fP, \fB\-\-gettext\-strings\fP
将 gettext \fB_("...")\fP 和 \fBN_("...")\fP 视为字符串而不是函数。
.br
请参见 \fB\ BREAKING\ LONG\ LINES\fP。
.TP 
\fB\-hnl\fP, \fB\-\-honour\-newlines\fP
更喜欢在输入中换行的位置打断长行。
.br
请参见 \fB\ BREAKING\ LONG\ LINES\fP。
.TP 
\fB\-i\fP\fIn\fP, \fB\-\-indent\-level\fP\fIn\fP
将缩进级别设置为 \fIn\fP 空格。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-il\fP\fIn\fP, \fB\-\-indent\-label\fP\fIn\fP
将标签的偏移量设置为 \fIn\fP 列。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-ip\fP\fIn\fP, \fB\-\-parameter\-indentation\fP\fIn\fP
通过 \fIn\fP 空格缩进旧式函数定义中的参数类型。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-kr\fP, \fB\-\-k\-and\-r\-style\fP
使用 Kernighan&Ritchie 编码风格。
.br
请参见 \fB\ COMMON\ STYLES\fP。
.TP 
\fB\-l\fP\fIn\fP, \fB\-\-line\-length\fP\fIn\fP
将非注释行的最大行长度设置为 \fIn\fP。
.br
请参见 \fB\ BREAKING\ LONG\ LINES\fP。
.TP 
\fB\-lc\fP\fIn\fP, \fB\-\-comment\-line\-length\fP\fIn\fP
将注释格式的最大行长度设置为 \fIn\fP。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-linux\fP, \fB\-\-linux\-style\fP
使用 Linux 编码风格。
.br
请参见 \fB\ COMMON\ STYLES\fP。
.TP 
\fB\-lp\fP, \fB\-\-continue\-at\-parentheses\fP
在括号中排列连续的行。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-lps\fP, \fB\-\-leave\-preprocessor\-space\fP
在 \(oq#\(cq 和预处理器指令之间留出空格。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-nbad\fP, \fB\-\-no\-blank\-lines\-after\-declarations\fP
声明后不要强制空行。
.br
请参见 \fB\ BLANK\ LINES\fP。
.TP 
\fB\-nbap\fP, \fB\-\-no\-blank\-lines\-after\-procedures\fP
不要在过程体之后强制空行。
.br
请参见 \fB\ BLANK\ LINES\fP。
.TP 
\fB\-nbbo\fP, \fB\-\-break\-after\-boolean\-operator\fP
不要在 boolean 运算符之前打断长行。
.br
请参见 \fB\ BREAKING\ LONG\ LINES\fP。
.TP 
\fB\-nbc\fP, \fB\-\-no\-blank\-lines\-after\-commas\fP
不要在声明中强制在逗号后换行。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-nbfda\fP, \fB\-\-dont\-break\-function\-decl\-args\fP
Don\(cqt 将每个参数放在单独一行的函数声明中。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-ncdb\fP, \fB\-\-no\-comment\-delimiters\-on\-blank\-lines\fP
不要在空行上放置注释分隔符。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-ncdw\fP, \fB\-\-dont\-cuddle\-do\-while\fP
不要拥抱 \fB}\fP 和 \fBdo {} while;\fP 的 \fBwhile\fP。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-nce\fP, \fB\-\-dont\-cuddle\-else\fP
不要拥抱 \fB}\fP 和 \fBelse\fP。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-ncs\fP, \fB\-\-no\-space\-after\-casts\fP
施放运算符后不要放空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-ndj\fP\fIn\fP, \fB\-\-dont\-left\-justify\-declarations\fP
声明之后的评论与其他语言之后的评论一样对待。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-nfc1\fP, \fB\-\-dont\-format\-first\-column\-comments\fP
不要像往常一样格式化第一列中的注释。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-nfca\fP, \fB\-\-dont\-format\-comments\fP
不要格式化任何注释。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-ngts\fP, \fB\-\-no\-gettext\-strings\fP
将 gettext \fB_("...")\fP 和 \fBN_("...")\fP 视为正常的函数。 这是默认设置。
.br
请参见 \fB\ BREAKING\ LONG\ LINES\fP。
.TP 
\fB\-nhnl\fP, \fB\-\-ignore\-newlines\fP
不喜欢在输入中换行的位置打断长行。
.br
请参见 \fB\ BREAKING\ LONG\ LINES\fP。
.TP 
\fB\-nip\fP, \fB\-\-no\-parameter\-indentation\fP
参数的零宽度缩进。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-nlp\fP, \fB\-\-dont\-line\-up\-parentheses\fP
不要排列括号。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-npcs\fP, \fB\-\-no\-space\-after\-function\-call\-names\fP
不要在函数调用中的函数后放置空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-nprs\fP, \fB\-\-no\-space\-after\-parentheses\fP
不要在每个 \(cq (\(cq) 之后和每个 \(cq)\(cq.
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-npsl\fP, \fB\-\-dont\-break\-procedure\-type\fP
将过程的类型与其名称放在同一行。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-nsaf\fP, \fB\-\-no\-space\-after\-for\fP
不要在每个 \fBfor\fP 后放置一个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-nsai\fP, \fB\-\-no\-space\-after\-if\fP
不要在每个 \fBif\fP 后放置一个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-nsaw\fP, \fB\-\-no\-space\-after\-while\fP
不要在每个 \fBwhile\fP 后放置一个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-nsc\fP, \fB\-\-dont\-star\-comments\fP
不要将 \(oq*\(cq 字符放在注释的左侧。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-nsob\fP, \fB\-\-leave\-optional\-blank\-lines\fP
不要吞下可选的空行。
.br
请参见 \fB\ BLANK\ LINES\fP。
.TP 
\fB\-nss\fP, \fB\-\-dont\-space\-special\-semicolon\fP
不要在某些语言句子后的分号前强制使用空格。 禁用 \(oq\-ss\(cq.
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-ntac\fP, \fB\-\-dont\-tab\-align\-comments\fP
不要将注释填充到最近的制表位。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-nut\fP, \fB\-\-no\-tabs\fP
使用空格而不是制表符。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-nv\fP, \fB\-\-no\-verbosity\fP
禁用详细模式。
.br
请参见 \fB\ MISCELLANEOUS\ OPTIONS\fP。
.TP 
\fB\-orig\fP, \fB\-\-original\fP
使用原始的 Berkeley 编码风格。
.br
请参见 \fB\ COMMON\ STYLES\fP。
.TP 
\fB\-npro\fP, \fB\-\-ignore\-profile\fP
不要阅读 \(oq.indent.pro\(cq 文件。
.br
请参见 \fB\ INVOKING\ INDENT\fP。
.TP 
\fB\-pal\fP, \fB\-\-pointer\-align\-left\fP
将星号放在空格左侧的指针声明中，紧挨着类型: \(oq\(oqchar* p\(cq\(cq.
.TP 
\fB\-par\fP, \fB\-\-pointer\-align\-right\fP
在变量名称旁边的空格右侧的指针声明中放置星号: \(oq\(oqchar *p\(cq\(cq. 这是默认行为。
.TP 
\fB\-pcs\fP, \fB\-\-space\-after\-procedure\-calls\fP
在被调用过程的名称和 \(oq (\(cq.
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-pi\fP\fIn\fP, \fB\-\-paren\-indentation\fP\fIn\fP
指定每个左括号的额外缩进 \(cq (\(当语句为 broken.See \fB\ STATEMENTS\fP 时，cq。
.TP 
\fB\-pmt\fP, \fB\-\-preserve\-mtime\fP
保留输出 files.See \fB\ MISCELLANEOUS\ OPTIONS\fP 上的访问和修改时间。
.TP 
\fB\-ppi\fP\fIn\fP, \fB\-\-preprocessor\-indentation\fP\fIn\fP
指定预处理器条件 statements.See \fB\ INDENTATION\fP 的缩进。
.TP 
\fB\-prs\fP, \fB\-\-space\-after\-parentheses\fP
在每个 \(cq (\(cq) 之后和每个 \(cq)\(cq.
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-psl\fP, \fB\-\-procnames\-start\-lines\fP
将过程的类型放在其名称之前的行中。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-saf\fP, \fB\-\-space\-after\-for\fP
在每个 \fBfor\fP 后放置一个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-sai\fP, \fB\-\-space\-after\-if\fP
在每个 \fBif\fP 后放置一个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-sar\fP, \fB\-\-spaces\-around\-initializers\fP
在初始化器中的 \(oq {\(cq 之后和 \(oq}\(cq 之前放置一个空格。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-saw\fP, \fB\-\-space\-after\-while\fP
在每个 \fBwhile\fP 后放置一个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-sbi\fP\fIn\fP, \fB\-\-struct\-brace\-indentation\fP\fIn\fP
结构体、union 或枚举 N 个空格的缩进大括号。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-sc\fP, \fB\-\-start\-left\-side\-of\-comments\fP
将 \(oq*\(cq 字符放在注释的左侧。
.br
请参见 \fB\ COMMENTS\fP。
.TP 
\fB\-slc\fP, \fB\-\-single\-line\-conditionals\fP
允许无括号条件 (\fBif\fP、\fBelse\fP 等) 将它们的内部语句放在同一行。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-sob\fP, \fB\-\-swallow\-optional\-blank\-lines\fP
吞下可选的空行。
.br
请参见 \fB\ BLANK\ LINES\fP。
.TP 
\fB\-ss\fP, \fB\-\-space\-special\-semicolon\fP
在一行 \fBfor\fP 和 \fBwhile\fP 语句中，强制在分号前留一个空格。
.br
请参见 \fB\ STATEMENTS\fP。
.TP 
\fB\-st\fP, \fB\-\-standard\-output\fP
写入标准输出。
.br
请参见 \fB\ INVOKING\ INDENT\fP。
.TP 
\fB\-T\fP
告诉 \fBindent\fP typenames 的名称。
.br
请参见 \fB\ DECLARATIONS\fP。
.TP 
\fB\-ts\fP\fIn\fP, \fB\-\-tab\-size\fP\fIn\fP
将制表符大小设置为 \fIn\fP 空格。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-ut\fP, \fB\-\-use\-tabs\fP
使用选项卡。这是默认设置。
.br
请参见 \fB\ INDENTATION\fP。
.TP 
\fB\-v\fP, \fB\-\-verbose\fP
启用详细模式。
.br
请参见 \fB\ MISCELLANEOUS\ OPTIONS\fP。
.TP 
\fB\-version\fP
输出 \fBindent\fP 的版本号。
.br
请参见 \fB\ MISCELLANEOUS\ OPTIONS\fP。

.SH "INVOKING INDENT"

从版本 1.3 开始，\fBindent\fP 命令的格式为:

.in +5
.nf
.na

缩进 [\fIoptions\fP] [\fIinput\-files\fP]

缩进 [\fIoptions\fP] [\fIsingle\-input\-file\fP] [\-o \fIoutput\-file\fP]

.in -5
.ad
.fi

此格式不同于 \fBindent\fP 的早期版本和其他版本。

在第一种形式中，指定了一个或多个输入文件。 \fBindent\fP 为每个文件制作一个备份副本，原始文件被其缩进版本替换。 有关如何进行备份的说明，请参见
\fBBACKUP\ FILES\fP。

在第二种形式中，只指定了一个输入文件。 在这种情况下，或者当使用标准输入时，您可以在 \(oq\-o\(cq 选项之后指定一个输出文件。

要使 \fBindent\fP 写入标准输出，请使用 \(oq\-st\(cq 选项。 这仅在只有一个输入文件或使用标准输入时才允许。

如果没有命名输入文件，则读取标准输入作为输入。 此外，如果指定了名为 \(oq\-\(cq 的文件名，则会读取标准输入。

例如，以下每个命令都会输入程序 \(oqslithy_toves.c\(cq 并将其缩进文本写入 \(oqslithy_toves.out\(cq:

.in +5
.nf
.na

缩进 slithy_toves.c \-o slithy_toves.out

缩进 \-st slithy_toves.c > slithy_toves.out

cat slithy_toves.c | indent \-o slithy_toves.out

.in -5
.ad
.fi

\fBindent\fP 的大多数其他选项控制程序的格式化方式。
从版本 1.2 开始，\fBindent\fP 也为每个识别一个长名称
选项名称。 长选项以 \(oq\-\-\(cq 或
\(oq+\(cq.
[\(oq+\(cq 被 \(oq\-\-\(cq 取代到
与 POSIX 标准保持一致。]
 在本文档的大部分内容中，
为简洁起见，使用传统的简称。
有关选项列表，请参见 \fBOPTION\ SUMMARY\fP，包括长和
简称。

这是另一个例子:

.in +5
.nf
.na
缩进 \-br test/metabolism.c \-l85
.in -5
.ad
.fi

这将缩进程序 \(oqtest/metabolism.c\(cq 使用 \(oq\-br\(cq 和 \(oq\-l85\(cq 选项，将输出写回
\(oqtest/metabolism.c\(cq，并将 \(oqtest/metabolism.c\(cq 的原始内容写入 \(oqtest\(cq.

在此示例中使用长选项名称的等效调用是:

.in +5
.nf
.na

缩进 \-\-braces\-on\-if\-line\-\-line\-length185 test/metabolism.c

缩进 + braces\-on\-if\-line +line\-length185 test/metabolism.c

.in -5
.ad
.fi

如果您发现您经常使用具有相同选项的 \fBindent\fP，您
可以将这些选项放入名为 \(oq.indent.pro\(cq.
\fBindent\fP 将在三个位置查找配置文件。首先它会检查
环境变量 \fBINDENT_PROFILE\fP。如果存在它的值
应该命名要使用的文件。如果环境变量没有
不存在，indent 在当前目录下寻找 \(oq.indent.pro\(cq
 如果找到就使用它。 最后 \fBindent\fP 将搜索
\(oq.indent.pro\(cq 的主目录并使用该文件，如果它是
成立。此行为不同于其他版本的
\fBindent\fP，如果它们都存在，则加载这两个文件。

\(oq.indent.pro\(cq 的格式只是一个选项列表，就像它们出现在命令行上一样，由空格 (制表符、空格和换行符) 分隔。
\(oq.indent.pro\(cq 中的选项可能被 C 或 C++ 注释包围，在这种情况下它们将被忽略。

Command line switches are handled \fIafter\fP processing \(oq
.indent.pro\(cq.  Options specified later override arguments specified
earlier, with one exception: Explicitly specified options always override
background options (See \fBCOMMON\ STYLES\fP).  You can prevent \fBindent\fP from
reading an \(oq.indent.pro\(cq file by specifying the \(oq\-npro\(cq option.

.SH "BACKUP FILES"

从版本 1.3 开始，GNU \fBindent\fP 制作 GNU 样式的备份文件，与 GNU Emacs 的方式相同。 这意味着可以制作
\fIsimple\fP 或 \fInumbered\fP 备份文件名。

简单的备份文件名是通过将后缀追加到原始文件名生成的。 此后缀的默认值为单字符字符串 \(oq~\(cq (tilde).
因此，\(oqpython.c\(cq 的备份文件将是 \(oqpython.c~\(cq.

您可以通过将环境变量 \fBSIMPLE_BACKUP_SUFFIX\fP 设置为您首选的后缀来指定任何字符串作为后缀，而不是默认值。

文件的编号备份版本 \(oqmomeraths.c\(cq 看起来像 \(oqmomeraths.c.~23~\(cq，其中 23 是此特定备份的版本。
对文件 \(oqsrc/momeraths.c\(cq 进行编号备份时，备份文件将命名为
\(oqsrc/momeraths.c.~\fIV\fP~\(cq，其中 \fIV\fP 比目录 \(oqsrc\(cq.  环境变量
\fBVERSION_WIDTH\fP 控制位数，必要时使用左零填充。 例如，将此变量设置为 "2" 将导致备份文件被命名为
\(oqmomeraths.c.~04~\(cq.

备份文件的类型由环境变量 \fBVERSION_CONTROL\fP 的值控制。 如果它是字符串 \(oqsimple\(cq，那么只会进行简单备份。
如果其值为字符串 \(oqnumbered\(cq，则将进行编号备份。 如果它的值为
\(oqnumbered\-existing\(cq，那么如果被缩进的文件有 \fIalready exist\fP 编号的备份，那么将进行编号备份;
否则，将进行简单备份。 如果未设置 \fBVERSION_CONTROL\fP，则 \fBindent\fP 假定
\(oqnumbered\-existing\(cq.

\fBindent\fP 的其他版本在命名备份文件时使用后缀 \(oq.BAK\(cq。 可以通过将 \fBSIMPLE_BACKUP_SUFFIX\fP 设置为
\(oq.BAK\(cq.

另请注意，其他版本的 \fBindent\fP 在当前目录中进行备份，而不是像 GNU \fBindent\fP 现在那样在源文件的目录中进行备份。

.SH "COMMON STYLES"

C 代码有几种常见的风格，包括 GNU 风格、Kernighan&Ritchie 风格和原始 Berkeley 风格。 可以使用单个
\fIbackground\fP 选项选择样式，该选项为所有其他选项指定一组值。 但是，显式指定的选项总是会覆盖背景选项隐含的选项。

从 1.2 版本开始，GNU \fBindent\fP 默认样式为 GNU 样式。 因此，不再需要指定选项 \(oq\-gnu\(cq
来获取此格式，尽管这样做不会导致错误。 GNU 样式对应的选项设置为:

.in +5
.nf
.na
\-nbad \-bap \-nbc \-bbo \-bl \-bli2 \-bls \-ncdb \-nce \-cp1 \-cs \-di2
\-ndj \-nfc1 \-nfca \-hnl \-i2 \-ip5 \-lp \-pcs \-nprs \-psl \-saf \-sai
\-saw \-nsc \-nsob
.in -5
.ad
.fi

GNU 编码风格是 GNU 项目首选的编码风格。 这是 GNU Emacs C 模式所鼓励的风格，并在 GNU Emacs 的 C 部分中使用。
(有兴趣为 GNU 项目编写程序的人应该获得 "The GNU Coding Standards"
的副本，其中还涵盖了语义和可移植性问题，例如内存使用、整数大小等。)

Kernighan&Ritchie 风格贯穿于他们著名的 "The C Programming Language" 一书中。 它通过
\(oq\-kr\(cq 选项启用。 Kernighan&Ritchie 样式对应于以下选项集:

.in +5
.nf
.na
\-nbad \-bap \-bbo \-nbc \-br \-brs \-c33 \-cd33 \-ncdb \-ce \-ci4 \-cli0
\-cp33 \-cs \-d0 \-di1 \-nfc1 \-nfca \-hnl \-i4 \-ip0 \-l75 \-lp \-npcs
\-nprs \-npsl \-saf \-sai \-saw \-nsc \-nsob \-nss \-par
.in -5
.ad
.fi

Kernighan&Ritchie 风格不会始终将注释放在同一列的代码右侧 (也不会只在代码右侧使用一个空格)，因此对于这种风格，\fBindent\fP
随意选择了第 33 列。

可以通过指定 \(oq\-orig\(cq (或通过指定 \(oq\-\-original\(cq，使用长选项名称) 指定
\(oq\-\-original\(cq) 来获得原始 Berkeley \fBindent\fP 的样式。 此样式等效于以下设置:

.in +5
.nf
.na
\-nbad \-nbap \-bbo \-bc \-br \-brs \-c33 \-cd33 \-cdb \-ce \-ci4 \-cli0
\-cp33 \-di16 \-fc1 \-fca \-hnl \-i4 \-ip4 \-l75 \-lp \-npcs \-nprs \-psl
\-saf \-sai \-saw \-sc \-nsob \-nss \-ts8
.in -5
.ad
.fi

Linux 样式用于 linux 内核代码和驱动程序。代码通常必须遵循 Linux 编码风格才能被接受。 此样式等效于以下设置:

.in +5
.nf
.na
\-nbad \-bap \-nbc \-bbo \-hnl \-br \-brs \-c33 \-cd33 \-ncdb \-ce \-ci4
\-cli0 \-d0 \-di1 \-nfc1 \-i8 \-ip0 \-l80 \-lp \-npcs \-nprs \-npsl \-sai
\-saf \-saw \-ncs \-nsc \-sob \-nfca \-cp33 \-ss \-ts8 \-il1
.in -5
.ad
.fi

.SH "BLANK LINES"

各种编程风格在不同的地方使用空行。 \fBindent\fP 有许多选项可以在特定位置插入或删除空行。

\(oq\-bad\(cq 选项导致 \fBindent\fP 在每个声明块之后强制空行。 \(oq\-nbad\(cq 选项导致 \fBindent\fP
不强制这样的空行。

\(oq\-bap\(cq 选项在每个过程主体之后强制一个空行。 \(oq\-nbap\(cq 选项强制没有这样的空行。

\(oq\-bbb\(cq 选项在每个 boxed 注释之前强制一个空行 (参见 \fBCOMMENTS\fP.)\(oq\-nbbb\(cq
选项不强制这样的空行。

\(oq\-sob\(cq 选项导致 \fBindent\fP 吞下可选空行 (即，输入中存在的任何可选空行将从输出中删除)。 如果指定了
\(oq\-nsob\(cq，输入文件中存在的任何空行都将被复制到输出文件。


.SH \-\-blank\-lines\-after\-declarations

\(oq\-bad\(cq 选项在每个声明块之后强制一个空行。 \(oq\-nbad\(cq 选项不会添加任何此类空行。

例如，给定输入
.in +5
.nf
.na
char *foo;
char *bar;
/* 这分隔声明块。 */
int baz;
.in -5
.ad
.fi

\fBindent \-bad\fP 产生

.in +5
.nf
.na
char *foo;
char *bar;

/* This separates blocks of declarations.  */
int baz;
.in -5
.ad
.fi

\fBindent \-nbad\fP 产生

.in +5
.nf
.na
char *foo;
char *bar;
/* 这分隔声明块。 */
int baz;
.in -5
.ad
.fi

.SH \-\-blank\-lines\-after\-procedures

\(oq\-bap\(cq 选项在每个过程主体之后强制一个空行。

例如，给定输入

.in +5
.nf
.na
int
foo ()
{
  puts("Hi");
}
/* 程序栏就更没意思了。 */
char *
bar ()
{
  puts("Hello");
}
.in -5
.ad
.fi

\fBindent \-bap\fP produces

.in +5
.nf
.na
int
foo ()
{
  puts ("Hi");
}

/* The procedure bar is even less interesting.  */
char *
bar ()
{
  puts ("Hello");
}
.in -5
.ad
.fi

and \fBindent \-nbap\fP produces

.in +5
.nf
.na
int
foo ()
{
  puts ("Hi");
}
/* 程序栏就更没意思了。 */
char *
bar ()
{
  puts ("Hello");
}
.in -5
.ad
.fi

\fBfoo\fP 程序后不加空行。

.SH COMMENTS

\fBindent\fP 格式化 C 和 C++ 注释。C 注释以 \(oq/*\(cq 开始，以 \(oq*/\(cq 结束，可能包含换行符。 C++
注释以分隔符 \(oq//\(cq 开始并在换行符结束。

\fBindent\fP 根据上下文以不同方式处理注释。 \fBindent\fP
试图区分语句后面的注释、声明后面的注释、预处理器指令后面的注释，以及前面没有任何类型代码的注释，即它们开始行的文本 (尽管不一定在第 1 列)。

\fBindent\fP 进一步区分在过程和聚合外部发现的注释和在它们内部发现的注释。 特别是，在过程中找到的一行开始的注释将缩进到代码当前缩进的列。
例外情况是从最左边的列开始的注释; 在该列输出这样的评论。

\fBindent\fP 试图让 \fIboxed comments\fP 保持不变。这样的评论的一般想法是它被包围在一个矩形或
\(oq\(oqbox\(cq\(cq 的星号或破折号中，以在视觉上将它分开。 更准确地说，boxed 注释被定义为那些初始的 \(oq/*\(cq
后面紧跟着字符 \(oq*\(cq,\(oq=\(cq,\(oq_\(cq, 或 \(oq\-\(cq，或那些起始注释定界符 (\(oq/*\(cq)
单独在一行，且下一行以 \(oq*\(cq 与起始定界符的星号在同一列中.

boxed 评论的例子是:

.in +5
.nf
.na
/**********************
 * Comment in a box!! *
 **********************/

       /*
        * 一种不同的气味，
        * 不同类型的评论。
        */
.in -5
.ad
.fi

\fBindent\fP 试图保留 boxed 注释，就像它们在源文件中找到的一样。 因此注释的缩进没有改变，它的长度也没有以任何方式检查。
所做的唯一更改是嵌入的制表符可以转换为适当数量的空格。

如果指定了 \(oq\-bbb\(cq 选项，则所有此类 boxed 注释都将以空行开头，除非此类注释以代码开头。

不是 boxed 注释的注释可能会被格式化，这意味着该行被打断以适合右边距并向左填充空格。 单个换行符相当于一个空格，但空行
(一行中的两个或多个换行符) 被视为段落分隔符。 使用 \(oq\-fca\(cq 选项启用在第一列之后开始的注释格式。
要格式化从第一列开始的那些，请指定 \(oq\-fc1\(cq.  默认情况下禁用此类格式。

格式化的右边距默认为 78，但可以使用 \(oq\-lc\(cq 选项更改。 如果指定的页边距不允许打印评论，则页边距将在该评论的持续时间内自动扩展。
如果注释未被格式化，则不考虑边距。

如果指定了 \(oq\-fnc\(cq 选项，所有嵌入了 \(oq/*\(cq) 的注释都会将该字符序列替换为空格后跟字符
\(oq*\(cq，从而消除嵌套。

如果注释开始一行 (即，其左侧没有程序文本)，它将缩进到它所在的列，除非注释在代码块内。 在这种情况下，这样的注释将与该块的缩进代码对齐
(除非注释从第一列开始)。 这种对齐可能会受到 \(oq\-d\(cq 选项的影响，该选项指定将此类注释移动到 \fIleft\fP 或未缩进的数量。
例如，\(oq\-d2\(cq 在代码左侧放置两个空格的注释。 默认情况下，注释与代码对齐，除非它们从第一列开始，在这种情况下它们默认保留在那里 \-\-\-
要使它们与代码对齐，请指定 \(oq\-fc1\(cq.

默认情况下，代码右侧的注释将出现在第 33 列中。 这可以通过三个选项之一进行更改。 \(oq\-c\(cq
将指定代码后面的注释列，\(oq\-cd\(cq 指定声明后面的注释列，以及 \(oq\-cp\(cq 指定预处理程序指令后面的注释列 \fB#else\fP 和
\fB#endif\fP。\(oq\-dj\(cq 和 \(oq\-cd0\(cq 可用于抑制注释对齐到声明的右侧，导致注释在声明末尾后跟一个制表位。通常
\(oq\-cd0\(cq 导致 \(oq\-c\(cq 生效。

如果注释左侧的代码超出了起始列，则注释列将扩展到代码末尾之后的下一个制表位列，除非指定了 \(oq\-ntac\(cq 选项。
在预处理器指令的情况下，注释被扩展到指令末尾后的一个空格。 此扩展仅针对该特定评论的输出持续。

\(oq\-cdb\(cq 选项将注释定界符放在空行上。 因此，像 \fB/* Loving hug */\fP 这样的单行注释可以转化为:

.in +5
.nf
.na
/*
   Loving hug
 */
.in -5
.ad
.fi

可以使用 \(oq\-sc\(cq 选项将星号放置在多行注释的开头。 因此，上面的单行注释可以转换 (用 \(oq\-cdb\-sc\(cq) 成:

.in +5
.nf
.na
/*
 * Loving hug
 */
.in -5
.ad
.fi

.SH STATEMENTS

\(oq\-br\(cq 或 \(oq\-bl\(cq 选项指定如何格式化大括号。

\(oq\-br\(cq 选项格式化语句大括号如下:

.in +5
.nf
.na
if (x > 0) {
  x\-\-;
}
.in -5
.ad
.fi

\(oq\-bl\(cq 选项将它们格式化如下:

.in +5
.nf
.na
if (x > 0)
  {
    x\-\-;
  }
.in -5
.ad
.fi

如果您使用 \(oq\-bl\(cq 选项，您可能还想指定 \(oq\-bli\(cq 选项。 此选项指定大括号缩进的空格数。
\(oq\-bli2\(cq，默认值，给出如上所示的结果。 \(oq\-bli0\(cq 结果如下:

.in +5
.nf
.na
if (x > 0)
{
  x\-\-;
}
.in -5
.ad
.fi

如果您正在使用 \(oq\-br\(cq 选项，您可能还想使用 \(oq\-ce\(cq 选项。 这会导致 if\-then\-else 结构中的
\fBelse\fP 紧贴前面的 \(oq}\(cq.  例如，使用 \(oq\-br\-ce\(cq 您会得到以下内容:

.in +5
.nf
.na
if (x > 0) {
  x\-\-;
} else {
  fprintf (stderr, "...something wrong?\en");
}
.in -5
.ad
.fi

使用 \(oq\-br\-nce\(cq 该代码将显示为

.in +5
.nf
.na
if (x > 0) {
  x\-\-;
}
else {
  fprintf (stderr, "...something wrong?\en");
}
.in -5
.ad
.fi

当右大括号和随后的 else 语句之间有注释时，会出现异常行为。 虽然 \(oq\-br\(cq 选项会导致左大括号跳过注释，但 else
不会跳过注释进行拥抱，因为它很可能会改变注释的含义。

\(oq\-cdw\(cq 选项会导致 do\-while 循环中的 \fBwhile\fP 紧靠在前面的 \(oq}\(cq.  例如，使用
\(oq\-cdw\(cq 您会得到以下内容:

.in +5
.nf
.na
做 {
  x\-\-;
} while (x);
.in -5
.ad
.fi

使用 \(oq\-ncdw\(cq 该代码将显示为

.in +5
.nf
.na
做 {
  x\-\-;
}
while (x);
.in -5
.ad
.fi

\(oq\-slc\(cq 选项允许无括号条件语句及其内部语句出现在同一行。例如:

.in +5
.nf
.na
if (x) x\-\-;
else x++;
.in -5
.ad
.fi

没有 \(oq\-slc\(cq 该代码将显示为

.in +5
.nf
.na
if (x)
  x\-\-;
else
  x++;
.in -5
.ad
.fi

\(oq\-cli\(cq 选项指定 case 标签应缩进到包含 \fBswitch\fP 语句右侧的空格数。

默认给出如下代码:

.in +5
.nf
.na
switch (i)
  {
  case 0:
    break; 
  case 1:
    {
      ++i;
    }
  default:
    break;
  }
.in -5
.ad
.fi

使用 \(oq\-cli2\(cq 将变为:

.in +5
.nf
.na
switch (i)
  {
    case 0:
      break; 
    case 1:
      {
        ++i;
      }
    default:
      break;
  }
.in -5
.ad
.fi

可以使用 \(oq\-cbi\fIn\fP\(cq 选项控制 case 语句下方大括号的缩进。 例如，使用 \(oq\-cli2\-cbi0\(cq 结果:

.in +5
.nf
.na
switch (i)
  {
    case 0:
      break; 
    case 1:
    {
      ++i;
    }
    default:
      break;
  }
.in -5
.ad
.fi

如果分号与 \fBfor\fP 或 \fBwhile\fP 语句位于同一行，\(oq\-ss\(cq 选项将导致在分号之前放置一个空格。 这强调了分号，清楚地表明
\fBfor\fP 或 \fBwhile\fP 语句的主体是一个空语句。 \(oq\-nss\(cq 禁用此，特性。

\(oq\-pcs\(cq 选项导致在被调用过程的名称和 \(oq (\(cq (例如，\fBputs\ ("Hi");\fP.  \(oq\-npcs\(cq
选项会给出 \fBputs("Hi");\fP)。


如果指定了 \(oq\-cs\(cq 选项，\fBindent\fP 会在转换运算符和要转换的对象之间放置一个空格。\(oq\-ncs\(cq
确保转换运算符和对象之间没有空格。请记住，\fBindent\fP 只知道标准 C 数据类型，因此无法识别强制转换中的用户定义类型。因此
\fB(mytype)thing\fP 不被视为强制转换。

\(oq\-bs\(cq 选项确保关键字 \fBsizeof\fP 与其参数之间有一个空格。 在某些版本中，这称为 \(oqBill_Shannon\(cq
选项。

\(oq\-saf\(cq 选项强制在 \fBfor\fP 和后面的括号之间留一个空格。 这是默认设置。

\(oq\-sai\(cq 选项强制在 \fBif\fP 和后面的括号之间留一个空格。 这是默认设置。

\(oq\-saw\(cq 选项强制在 \fBwhile\fP 和后面的括号之间留一个空格。 这是默认设置。

\(oq\-prs\(cq 选项导致所有括号之间用空格分隔。 例如，使用 \(oq\-prs\(cq 结果代码如下:

.in +5
.nf
.na
  while ( ( e_code \- s_code ) < ( dec_ind \- 1 ) )
    {
      set_buf_break ( bb_dec_ind );
      *e_code++ = \(cq \(cq;
    }
.in -5
.ad
.fi

.SH DECLARATIONS

默认情况下，\fBindent\fP 将在 \(oq\-di\(cq 选项指定的列中排列标识符。 例如，\(oq\-di16\(cq 让事情看起来像:

.in +5
.nf
.na
int             foo;
char           *bar;
.in -5
.ad
.fi

为 \(oq\-di\(cq 选项使用较小的值 (例如一个或两个) 可用于使标识符放置在第一个可用位置; 例如:

.in +5
.nf
.na
int foo;
char *bar;
.in -5
.ad
.fi

给 \(oq\-di\(cq 选项的值仍然会影响变量，它们与它们的类型放在不同的行上，例如 \(oq\-di2\(cq 将导致:

.in +5
.nf
.na
int
  foo;
.in -5
.ad
.fi

如果指定了 \(oq\-bc\(cq 选项，则在声明中的每个逗号之后强制换行。 例如，

.in +5
.nf
.na
int a,
  b,
  c;
.in -5
.ad
.fi

使用 \(oq\-nbc\(cq 选项，这看起来像

.in +5
.nf
.na
int a, b, c;
.in -5
.ad
.fi

\(oq\-bfda\(cq 选项导致在逗号分隔函数声明的参数之后强制换行。 参数将出现在比函数声明更深的一个缩进级别。
这对于包含长参数列表的函数特别有用。 选项 \(oq\-bfde\(cq 导致在函数声明的右括号之前强制换行。对于这两个选项，\(cqn\(cq
设置是默认设置: \-nbfda 和 \-nbfde。


例如，

.in +5
.nf
.na
void foo (int arg1, char arg2, int *arg3, long arg4, char arg5);
.in -5
.ad
.fi
使用 \(oq\-bfda\(cq 选项，这看起来像

.in +5
.nf
.na
void foo (
    int arg1,
    char arg2,
    int *arg3,
    long arg4,
    char arg5);
.in -5
.ad
.fi

此外，还有 \(oq\-bfde\(cq 选项，这看起来像

.in +5
.nf
.na
void foo (
    int arg1,
    char arg2,
    int *arg3,
    long arg4,
    char arg5
    );
.in -5
.ad
.fi

\(oq\-psl\(cq 选项导致被定义的过程的类型被放置在过程名称之前的行上。 \fBetags\fP 程序以及 Emacs 的一些 \fBc\-mode\fP
函数都需要这种风格才能正常工作。

您必须使用 \(oq\-T\(cq 选项告诉 \fBindent\fP 您程序中由 \fBtypedef\fP 定义的所有类型名的名称。 \(oq\-T\(cq
可以指定多次，并且使用所有指定的名称。 例如，如果您的程序包含

.in +5
.nf
.na
typedef unsigned long CODE_ADDR;
typedef 枚举 {red, blue, green} 颜色;
.in -5
.ad
.fi

您将使用选项 \(oq\-T CODE_ADDR \-T COLOR\(cq.


\(oq\-brs\(cq 或 \(oq\-bls\(cq 选项指定如何在结构体声明中格式化大括号。 \(oq\-brs\(cq 选项格式化大括号如下:

.in +5
.nf
.na
struct foo {
  int x;
};
.in -5
.ad
.fi

\(oq\-bls\(cq 选项将它们格式化如下:

.in +5
.nf
.na
struct foo
{
  int x;
};
.in -5
.ad
.fi


类似于结构体大括号 \(oq\-brs\(cq 和 \(oq\-bls\(cq 选项，
 函数大括号选项 \(oq\-brf\(cq 或 \(oq\-blf\(cq 指定如何格式化大括号
在函数定义中。 \(oq\-brf\(cq 选项格式大括号像
this:

.in +5
.nf
.na
int one(void) {
  return 1;
};
.in -5
.ad
.fi

\(oq\-blf\(cq 选项将它们格式化如下:

.in +5
.nf
.na
int one(void)
{
  return 1;
};
.in -5
.ad
.fi


\(oq\-sar\(cq 选项会影响 \fBindent\fP 将如何呈现初始化列表。没有 \(oq\-sar\(cq 它们的格式如下:

.in +5
.nf
.na
int a[] = {1, 2, 3, 4};

struct s {
  const char *name;
  int x;
} a[] = {
  {"name", 0},
  {"a", 1}
};
.in -5
.ad
.fi

使用 \(oq\-sar\(cq 它们的格式如下，大括号内有空格:

.in +5
.nf
.na
int a[] = { 1, 2, 3, 4 };

struct s {
  const char *name;
  int x;
} a[] = {
  { "name", 0 },
  { "a", 1 }
};
.in -5
.ad
.fi

.SH INDENTATION

关于代码格式最基本、也是最有争议的问题恰恰是缩进应该如何完成。 幸运的是，\fBindent\fP 支持多种不同风格的标识。 默认是使用制表符进行缩进，这是由
\(oq\-ut\(cq 选项指定的。假设默认制表符大小为 8，代码如下所示:

.in +5
.nf
.na
int a(int b)
{
        return b;
|\-\-\-\-\-\-|
 1 tab
}
.in -5
.ad
.fi

对于那些喜欢空格而不是制表符的人，\(oqindent\(cq 提供了 \(oq\-nut\(cq 选项。同样的代码看起来像这样:

.in +5
.nf
.na
int a(int b)
{
        return b;
|\-\-\-\-\-\-|
8 个空格
}
.in -5
.ad
.fi

代码格式的另一个问题是每行应该从左边距缩进多远。 当遇到 \fBif\fP 或 \fBfor\fP 等语句的开头时，缩进级别将增加 \(oq\-i\(cq
选项指定的值。 例如，使用 \(oq\-i8\(cq 为每个级别指定八个字符的缩进。 当一个语句被分成两行时，第二行缩进一些由 \(oq\-ci\(cq
选项指定的额外空格。 \(oq\-ci\(cq 默认为 0。 但是，如果指定了 \(oq\-lp\(cq
选项，并且某行的左括号未在该行闭合，则后续行将排成一行，从左括号后面的字符位置开始。 此处理也适用于 \(oq [\(cq 并适用于 \(oq
{\(cq 当它出现在初始化列表中时。 例如，一段连续的代码可能看起来像这样 \(oq\-nlp\-ci3\(cq 实际上:

.in +5
.nf
.na
  p1 = first_procedure (second_procedure (p2, p3),
     third_procedure (p4, p5));
.in -5
.ad
.fi

使用 \(oq\-lp\(cq 实际上，代码看起来更清晰一些:

.in +5
.nf
.na
  p1 = first_procedure (second_procedure (p2, p3),
                        third_procedure (p4, p5));
.in -5
.ad
.fi

当一个语句在两个或多个 paren 对 (...) 之间中断时，每个额外的对都会导致缩进级别额外缩进:

.in +5
.nf
.na
if ((((i < 2 &&
        k > 0) || p == 0) &&
    q == 1) ||
  n = 0)
.in -5
.ad
.fi

选项 \(oq\-ip\fIN\fP\(cq 可用于设置每个括号的额外偏移量。 例如，\(oq\-ip0\(cq 会将上面的格式设置为:

.in +5
.nf
.na
if ((((i < 2 &&
  k > 0) || p == 0) &&
  q == 1) ||
  n = 0)
.in -5
.ad
.fi

\fBindent\fP 假定制表符以规则的间隔放置在输入和输出字符流中。 这些间隔默认为 8 列宽，但 (从版本 1.2 开始) 可以通过
\(oq\-ts\(cq 选项。 制表符被视为等效数量的空格。

默认情况下，\fBindent\fP 会使用制表符尽可能地缩进，然后用空格填充，直到到达所需的位置。但是，使用 \(oq\-as\(cq
选项，空格将用于超出当前缩进级别的对齐。默认情况下，假设 \(oq\-lp\(cq 已启用，代码将像这样缩进 (\(oqt\(cq
表示制表符，\(oqs\(cq 表示空格):

.in +5
.nf
.na
unsigned long really_long_proc_name(unsigned long x, unsigned long y,
                                    int a)
|\-\-\-\-\-\-||\-\-\-\-\-\-\-||\-\-\-\-\-\-||\-\-\-\-\-\-\-|__
   t        t       t       t     ss
{
        p1 = first_procedure (second_procedure (p2, p3),
                              third_procedure (p4, p5));
|\-\-\-\-\-\-||\-\-\-\-\-\-||\-\-\-\-\-\-|_____
   t       t       t    sssss
}
.in -5
.ad
.fi

这很好，如果您假设阅读代码的人会遵守您对 8 个空格制表符的假设。如果 reader 使用 4 个空格的制表符，它看起来像这样:

.in +5
.nf
.na
unsigned long really_long_proc_name(unsigned long x, unsigned long y,
                      int a)
|\-\-\-||\-\-\-||\-\-\-||\-\-\-|__
  t    t    t    t  ss
{
        p1 = first_procedure (second_procedure (p2, p3),
                     third_procedure (p4, p5));
|\-\-\-||\-\-\-||\-\-\-|______
  t    t    t  ssssss
}
.in -5
.ad
.fi

\(oq\-as\(cq 选项修复了这个问题，这样无论用户阅读代码的制表符大小如何，代码都将显示一致。这看起来像:

.in +5
.nf
.na
unsigned long really_long_proc_name(unsigned long x, unsigned long y,
                                    int a)
____________________________________
ssssssssssssssssssssssssssssssssssss
{
        p1 = first_procedure (second_procedure (p2, p3),
                              third_procedure (p4, p5));
|\-\-\-\-\-\-|______________________
   t    ssssssssssssssssssssss
}
.in -5
.ad
.fi

旧式函数定义中类型声明的缩进由 \(oq\-ip\(cq 参数控制。 这是一个数字参数，指定缩进类型声明的空格数。 例如，默认的 \(oq\-ip5\(cq
使定义看起来像这样:

.in +5
.nf
.na
char *
create_world (x, y, scale)
     int x;
     int y;
     浮标;
{
  浮标;
}
.in -5
.ad
.fi

为了与其他版本的缩进兼容，提供了选项 \(oq\-nip\(cq，相当于 \(oq\-ip0\(cq.

ANSI C 允许在字符 \(oq#\(cq 和命令名称之间的预处理器命令行上放置空格。 默认情况下，\fBindent\fP 会删除此空格，但指定
\(oq\-lps\(cq 选项会指示 \fBindent\fP 保留此空格不变。选项 \(oq\-ppi\(cq 覆盖 \(oq\-nlps\(cq 和
\(oq\-lps\(cq.

此选项可用于请求预处理器条件语句可以缩进给定的空格数，例如使用选项 \(oq\-ppi 3\(cq

.in +5
.nf
.na
#if X
#if Y
#define Z 1
#else
#define Z 0
#endif
#endif
.in -5
.ad
.fi
becomes
.in +5
.nf
.na
#if X
#   if Y
#      define Z 1
#   else
#      define Z 0
#   endif
#endif
.in -5
.ad
.fi

此选项设置标签 (案例标签除外) 的定位偏移量。如果它被设置为零或正数，这表示从左边距到缩进标签的距离。 如果它设置为 negative
数字，则表示从当前缩进级别向后放置标签的距离。 默认设置为 \-2，它与缩进的早期版本的行为相匹配。 请注意，此参数不会影响案例标签的放置; 请参见
\(oq\-cli\(cq 参数。例如，选项 \(oq\-il 1\(cq

.in +5
.nf
.na
group
function()
{
    if (do_stuff1() == ERROR)
        goto cleanup1;

    if (do_stuff2() == ERROR)
        goto cleanup2;

    return SUCCESS;

  cleanup2:
    do_cleanup2();

  cleanup1:
    do_cleanup1();

    return ERROR;
}
.in -5
.ad
.fi
becomes
.in +5
.nf
.na
group
function()
{
    if (do_stuff1() == ERROR)
        goto cleanup1;

    if (do_stuff2() == ERROR)
        goto cleanup2;

    return SUCCESS;

 cleanup2:
    do_cleanup2();

 cleanup1:
    do_cleanup1();

    return ERROR;
}
.in -5
.ad
.fi

.SH "BREAKING LONG LINES"

使用选项 \(oq\-l\fIn\fP\(cq 或 \(oq\-\-line\-length\fIn\fP\(cq，可以指定一行 C 代码的最大长度，不包括其后可能的注释。

当行长于指定的行长度时，GNU \fBindent\fP 尝试在逻辑位置断开行。 这是 2.1 版本的新功能，但还不是很智能或灵活。

目前有三个选项可以干扰确定断线位置的算法。

\(oq\-bbo\(cq 选项导致 GNU \fBindent\fP 倾向于在布尔运算符号 \fB&&\fP 和 \fB||\fP 之前断开长行。
\(oq\-nbbo\(cq 选项导致 GNU \fBindent\fP 没有该偏好。 例如，默认选项 \(oq\-bbo\(cq (与
\(oq\-\-line\-length60\(cq 和 \(oq\-\-ignore\-newlines\(cq) 一起使代码看起来像这样:

.in +5
.nf
.na
  if (mask
      && ((mask[0] == \(cq\e0\(cq)
          || (mask[1] == \(cq\e0\(cq
              && ((mask[0] == \(cq0\(cq) || (mask[0] == \(cq*\(cq)))))
.in -5
.ad
.fi

使用选项 \(oq\-nbbo\(cq 将使它看起来像这样:

.in +5
.nf
.na
  if (mask &&
      ((mask[0] == \(cq\e0\(cq) ||
       (mask[1] == \(cq\e0\(cq &&
        ((mask[0] == \(cq0\(cq) || (mask[0] == \(cq*\(cq)))))
.in -5
.ad
.fi

默认的 \(oq\-hnl\(cq，然而，通过给予它们最高可能的优先级来换行，从而尊重输入文件中的换行符。 例如，当输入文件如下所示时:

.in +5
.nf
.na
  if (mask
      && ((mask[0] == \(cq\e0\(cq)
      || (mask[1] == \(cq\e0\(cq && ((mask[0] == \(cq0\(cq) || (mask[0] == \(cq*\(cq)))))
.in -5
.ad
.fi

然后使用选项 \(oq\-hnl\(cq，或 \(oq\-\-honour\-newlines\(cq，连同前面提到的 \(oq\-nbbo\(cq 和
\(oq\-\-line\-length60\(cq，将导致输出不是上一个示例中给出的输出，而是更愿意在输入文件中代码被破坏的位置中断:

.in +5
.nf
.na
  if (mask
      && ((mask[0] == \(cq\e0\(cq)
          || (mask[1] == \(cq\e0\(cq &&
              ((mask[0] == \(cq0\(cq) || (mask[0] == \(cq*\(cq)))))
.in -5
.ad
.fi

这个选项背后的想法是太长但已经被打断的线不会被 GNU \fBindent\fP 触及。 真正混乱的代码应该至少使用
\(oq\-\-ignore\-newlines\(cq 选项通过 \fBindent\fP 运行一次。

\(oq\-gts\(cq 选项会影响 gettext 标准宏 \fB_()\fP 和 \fBN_()\fP 的处理方式。 默认行为 (或使用
\(oq\-ngts\(cq) 导致缩进像对待其他函数一样对待它们，因此长字符串会像下面的示例一样被破坏。

.in +5
.nf
.na
  if (mask)
    {
      warning (_
               ("这是一条连在一起的长字符串。"));
    }
.in -5
.ad
.fi

使用 \(oq\-gts\(cq 选项，下划，字符串，被视为字符串的一部分，使其与字符串保持联系，并尊重 gettext
不显眼地提供本地化字符串这一事实。 仅当 \fB_("\fP 在字符串的开头作为一个元在一起并且 \fB")\fP 在结尾作为一个元在一起时才有效。

.in +5
.nf
.na
  if (mask)
    {
      warning 
        (_("这是一个保持在一起的长字符串。"));
    }
.in -5
.ad
.fi

.SH "DISABLING FORMATTING"

通过在程序中嵌入特殊的 \fIcontrol comments\fP，可以禁用部分程序的 C 代码格式化。 要关闭程序某个部分的格式设置，请将禁用控制注释
\fB/* *INDENT\-OFF* */\fP 单独放在该部分之前的一行中。
在该控制注释之后扫描的程序文本被精确地作为输入输出而没有修改，直到相应的使能注释被单独扫描到一行。 启用控件注释为 \fB/* *INDENT\-ON* */\fP，该行注释后面的任何文本也将以未格式化的方式输出。 格式化再次从启用控制注释之后的输入行开始。

更准确地说，\fBindent\fP 不会尝试验证这些 C 注释的结束定界符 (\fB*/\fP)，并且行中的任何空格都是完全透明的。

这些控制注释也以它们的 C++ 格式命名，即 \fB// *INDENT\-OFF*\fP 和 \fB// *INDENT\-ON*\fP。

应该注意 \fBindent\fP 的内部状态在未格式化部分的过程中保持不变。 因此，例如，在一个函数中间关闭格式化并在函数结束后继续它可能会导致奇怪的结果。
因此，明智的做法是在选择不格式化的代码时进行某种程度的模块化。

作为历史记录，某些早期版本的 \fBindent\fP 会产生以 \fB*INDENT**\fP 开头的错误消息。 这些版本的 \fBindent\fP
被编写为忽略任何以此类错误消息开头的输入文本行。 我已经从 GNU \fBindent\fP 中删除了这个乱伦的，特性。

.SH "MISCELLANEOUS OPTIONS"

要找出您拥有所有权的 \fBindent\fP 版本，请使用命令 \fBindent \-version\fP。这将报告 \fBindent\fP
的版本号，而不进行任何正常处理。

\(oq\-v\(cq 选项可用于打开详细模式。 在详细模式下，\fBindent\fP 在将一行输入拆分为另外两行输出时报告，并在完成时给出一些大小统计信息。

\(oq\-pmt\(cq 选项使 \fBindent\fP 保留输出文件的访问和修改时间。 使用此选项的优点是，在项目中的所有源文件和头文件上运行缩进不会
\(cqt 导致 \fBmake\fP 重建所有目标。 此选项仅在具有 POSIX \fButime(2)\fP 函数的操作系统上可用。

.SH BUGS

请向 bug\-indent@gnu.org 报告任何错误。

当 \fBindent\fP 在一个文件上运行两次时，使用相同的配置文件，它应该 \fInever\fP 第二次更改该文件。 目前的 \fBindent\fP
设计无法保证这一点，也没有经过广泛测试。

\fBindent\fP 不 understand C. In 某些情况下这会导致无法加入线路。 结果是通过 \fBindent\fP 运行文件是
\fIirreversible\fP，即使使用的输入文件是使用给定配置文件 (\(oq.indent.pro\(cq) 运行 \fBindent\fP 的结果。

虽然尝试让 \fBindent\fP 为 C++ 工作，但它在任何 C++ 源代码上都无法很好地工作，除了最简单的。

\fBindent\fP 在将注释写入输出文件时不会查看给定的 \(oq\-\-line\-length\(cq 选项。 这通常会导致评论被放在最右边。 为了禁止
\fBindent\fP 加入末尾有注释的断行，请确保注释从断行的第一行开始。

\fBindent\fP 不计算行数和注释 (请参见 \(oq\-v\(cq 选项) 当 \fBindent\fP 与 \fB/* *INDENT\-OFF* */\fP
一起关闭时。

\fB/*UPPERCASE*/\fP
形式的注释不被视为注释，而是被视为标识符，导致它们与下一行连接。这使得这种类型的注释变得无用，除非它们一开始就嵌入到代码中。

.SH COPYRIGHT

以下版权声明适用于 \fBindent\fP 程序。 本手册的版权和复制许可出现在 \(oqindent.texinfo\(cq 和
\(oqindent.info\(cq) 的开头附近，以及 \(oqindent.1\(cq.

.nf
.na
Copyright (c) 2015 Tim Hentenaar.
Copyright (c) 2001 David Ingamells.
Copyright (c) 1999 Carlo Wood.
Copyright (c) 1995, 1996 Joseph Arceneaux.
Copyright (c) 1989, 1992, 1993, 1994, 1995, 1996, 2014 Free Software Foundation
Copyright (c) 1985 Sun Microsystems, Inc.
Copyright (c) 1980 The Regents of the University of California.
Copyright (c) 1976 Board of Trustees of the University of Illinois.
版权所有。

允许以源代码和二进制形式重新分发和使用
前提是上述版权声明和本段是
以所有此类形式复制，并且任何文件，
广告材料，以及与此相关的其他材料
分发和使用承认该软件是开发的
由加州大学伯克利分校、伊利诺伊大学、
Urbana 和 Sun Microsystems, Inc.  两所大学的名字
或 Sun Microsystems 不得用于认可或促销产品
未经特定的事先书面许可而从该软件派生。
本软件以 \(oq\(oqAS IS\(cq\(cq 并且没有任何明示或
默示保证，包括但不限于默示保证
特定商品的适销性和适用性保证
PURPOSE.
.ad
.fi

.SH "Options\(cq Cross Key"

这是一个按长选项字母顺序排列的选项列表，以帮助您找到相应的短选项。


.in +5
.nf
.na
\-\-align\-with\-spaces                             \-as
\-\- 逗号后的空白行 \-bc            
\-\-blank\-lines\-after\-declarations                \-bad           
\-\-blank\-lines\-after\-procedures                  \-bap           
\-\-blank\-lines\-before\-block\-comments             \-bbb           
\-\-if 行后大括号 \-bl            
\-\-braces\-after\-func\-def\-line                    \-blf
\-\- 大括号缩进 \-bli
\-\-braces\-after\-struct\-decl\-line                 \-bls
\-\- 大括号在线 \-br            
\-\-braces\-on\-func\-def\-line                       \-brf
\-\-braces\-on\-struct\-decl\-line                    \-brs
\-\-break\-after\-boolean\-operator                  \-nbbo
\-\-break\-before\-boolean\-operator                 \-bbo
\-\-break\-function\-decl\-args                      \-bfda
\-\-break\-function\-decl\-args\-end                  \-bfde
\-\-case \- 缩进 \-cli\fIn\fP    
\-\-case\-brace\-indentation                        \-cbi\fIn\fP
\-\-comment\-delimiters\-on\-blank\-lines             \-cdb           
\-\- 注释缩进 \-c\fIn\fP      
\-\-continuation\-indentation                      \-ci\fIn\fP     
\-\-continue\-at\-parentheses                       \-lp            
\-\-cuddle\-do\-while                               \-cdw
\-\-cuddle\-else                                   \-ce            
\-\-declaration\-comment\-column                    \-cd\fIn\fP     
\-\- 声明缩进 \-di\fIn\fP     
\-\-dont\-break\-function\-decl\-args                 \-nbfda
\-\-dont\-break\-function\-decl\-args\-end             \-nbfde
\-\-dont\-break\-procedure\-type                     \-npsl          
\-\-dont\-cuddle\-do\-while                          \-ncdw
\-\-dont\-cuddle\-else                              \-nce           
\-\-dont\-format\-comments                          \-nfca          
\-\-dont\-format\-first\-column\-comments             \-nfc1          
\-\-dont\-line\-up\-parentheses                      \-nlp           
\-\-dont\-left\-justify\-declarations                \-ndj 
\-\-dont\-space\-special\-semicolon                  \-nss
\-\-dont\-star\-comments                            \-nsc           
\-\-dont\-tab\-align\-comments                       \-ntac
\-\-else\-endif \- 列 \-cp\fIn\fP
\-\-format\-all\-comments                           \-fca           
\-\-format\-first\-column\-comments                  \-fc1           
\-\-gnu 风格 \-gnu           
\-\-honour\-newlines                               \-hnl
\-\- 忽略换行 \-nhnl
\-\-ignore\-profile                                \-npro          
\-\- 缩进标签 \-il\fIn\fP      
\-\- 缩进级 \-i\fIn\fP      
\-\-k \- 和 \- r \- 风格 \-kr            
\-\-leave\-optional\-blank\-lines                    \-nsob          
\-\-leave\-preprocessor\-space                      \-lps
\-\-left\-justify\-declarations                     \-dj
\-\-line\-comments\-indentation                     \-d\fIn\fP      
\-\-line\-length                                   \-l\fIn\fP      
\-\-linux 风格 \-linux            
\-\-no\-blank\-lines\-after\-commas                   \-nbc           
\-\-no\-blank\-lines\-after\-declarations             \-nbad          
\-\-no\-blank\-lines\-after\-procedures               \-nbap          
\-\-no\-blank\-lines\-before\-block\-comments          \-nbbb          
\-\-no\-comment\-delimiters\-on\-blank\-lines          \-ncdb          
\-\-no\-space\-after\-casts                          \-ncs           
\-\-no\-parameter\-indentation                      \-nip           
\-\-no\-space\-after\-for				\-nsaf
\-\-no\-space\-after\-function\-call\-names            \-npcs          
\-\-no\-space\-after\-if				\-nsai
\-\- 括号后无空格 \-nprs
\-\-no\-space\-after\-while				\-nsaw
\-\- 无制表符 \-nut
\-\-no\-verbosity                                  \-nv            
\-\- 原始 \-orig
\-\- 参数缩进 \-ip\fIn\fP     
\-\-paren \- 缩进 \-pi\fIn\fP
\-\-preserve\-mtime				\-pmt
\-\- 预处理器缩进 \-ppi\fIn\fP
\-\-procnames\-start\-lines                         \-psl           
\-\- 单行条件 \-slc
\-\- 施放后的空间 \-cs            
\-\-space\-after\-for				\-saf
\-\-space\-after\-if				\-sai
\-\- 括号后空格 \-prs
\-\- 程序调用后的空格 \-pcs           
\-\-space\-after\-while				\-saw
\-\-space\-special\-semicolon                       \-ss            
\-\-spaces\-around\-initializers                    \-sar
\-\- 标准输出 \-st            
\-\-start\-left\-side\-of\-comments                   \-sc            
\-\-struct\-brace\-indentation                      \-sbi\fIn\fP
\-\-swallow\-optional\-blank\-lines                  \-sob           
\-\-tab\-size                                      \-ts\fIn\fP     
\-\-use\-tabs                                      \-ut
\-\- 详细 \-v             
.in -5
.ad
.fi

.SH "RETURN VALUE"
Unknown
.SH FILES
.br
.nf
.\" set tabstop to longest possible filename, plus a wee bit
.ta \w'$HOME/.indent.pro   'u
\fI$HOME/.indent.pro\fP	holds 缩进的默认选项。
.SH AUTHORS
.br
蒂姆亨特纳尔
.br
卡罗・伍德
.br
约瑟夫・阿瑟诺
.br
吉姆・金登
.br
大卫・英格梅尔斯
.SH HISTORY
源自 UCB 程序 "indent"。
.SH COPYING
Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 2014, 2015 Free Software
Foundation, Inc.   Copyright (C) 1995, 1996 Joseph Arceneaux.   Copyright
(C) 1999 Carlo Wood.   Copyright (C) 2001 David Ingamells.   Copyright (C)
2013 Łukasz Stelmach.   Copyright (C) 2015 Tim Hentenaar.

允许制作和分发本手册的逐字副本，前提是在所有副本上保留版权声明和此许可声明。


.PP
.SH [手册页中文版]
.PP
本翻译为免费文档；阅读
.UR https://www.gnu.org/licenses/gpl-3.0.html
GNU 通用公共许可证第 3 版
.UE
或稍后的版权条款。因使用该翻译而造成的任何问题和损失完全由您承担。
.PP
该中文翻译由 wtklbm
.B <wtklbm@gmail.com>
根据个人学习需要制作。
.PP
项目地址:
.UR \fBhttps://github.com/wtklbm/manpages-chinese\fR
.ME 。
