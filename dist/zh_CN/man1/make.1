.\" -*- coding: UTF-8 -*-
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MAKE 1 "31 May 2022" GNU "User Commands"
.SH NAME
make\-GNU make 用于维护程序组的实用程序
.SH SYNOPSIS
\fBmake\fP [\fIOPTION\fP]... [\fITARGET\fP]...
.SH DESCRIPTION
.LP
\fImake\fP 实用程序将自动确定大型程序的哪些部分需要重新编译，并发出重新编译它们的命令。 该手册描述了 \fBmake\fP 的 GNU 实现，由
Richard Stallman 和 Roland McGrath 编写，目前由 Paul Smith 维护。 我们的示例显示 C
程序，因为它们非常常见，但您可以将 \fBmake\fP 与任何编程语言一起使用，其编译器可以使用 shell 命令运行。 实际上，\fBmake\fP
并不局限于程序。 您可以使用它来描述任何任务，其中某些文件必须在其他文件发生更改时自动从其他文件更新。
.LP
要准备使用 \fBmake\fP，您必须编写一个名为 \fImakefile\fP 的文件，该文件描述程序中文件之间的关系，并提供更新每个文件的命令。
在程序中，可执行文件通常是从目标文件更新而来的，目标文件又是通过编译源文件生成的。
.LP
一旦存在合适的 makefile，每次更改一些源文件时，这个简单的 shell 命令:
.sp 1
.RS
\fBmake\fP
.RE
.sp 1
足以执行所有必要的重新编译。 \fBmake\fP 程序使用 makefile 描述和文件的最后修改时间来决定哪些文件需要更新。
对于其中的每一个文件，它都会发出生成文件中记录的命令。
.LP
\fBmake\fP 执行 \fImakefile\fP 中的命令来更新一个或多个 \fItargets\fP，其中 \fItarget\fP 通常是一个程序。 如果没有
\fB\-f\fP 选项，\fBmake\fP 将按顺序查找生成文件 \fIGNUmakefile\fP、\fImakefile\fP 和 \fIMakefile\fP。
.LP
通常您应该调整您的 makefile 为 \fImakefile\fP 或 \fIMakefile\fP。 (我们推荐
\fIMakefile\fP，因为它显眼地出现在目录列表的开头附近，就在其他重要文件附近，例如 \fIREADME\fP.)。大多数 makefile
不推荐检查名字 \fIGNUmakefile\fP。 如果您有一个特定于 GNU \fBmake\fP 的 makefile，并且 \fBmake\fP
的其他版本无法理解，则您应该使用此名称。 如果 \fImakefile\fP 为 '\-'，则读取标准输入。
.LP
如果目标依赖于自上次修改目标以来已修改的先决条件文件，或者目标不存在，则 \fBmake\fP 会更新目标。
.SH OPTIONS
.sp 1
.TP  0.5i
\fB\-b\fP, \fB\-m\fP
为了与其他版本的 \fBmake\fP 兼容，这些选项将被忽略。
.TP  0.5i
\fB\-B\fP, \fB\-\-always\-make\fP
无条件做出所有目标。
.TP  0.5i
\fB\-C\fP \fIdir\fP, \fB\-\-directory\fP=\fIdir\fP
在读取 makefile 或执行任何其他操作之前更改目录 \fIdir\fP。 如果指定了多个 \fB\-C\fP 选项，则每个选项都相对于前一个选项进行解释:
\fB\-C \fP/ \fB\-C \fPetc 等同于 \fB\-C \fP/etc。这通常与 \fBmake\fP 的递归调用一起使用。
.TP  0.5i
\fB\-d\fP
除了正常处理外，还打印调试信息。
调试信息表明正在考虑重新制作哪些文件，正在比较哪些文件时间以及结果，哪些文件实际上需要重新制作，考虑了哪些隐式规则以及应用了哪些规则 \-\- 关于
\fBmake\fP 如何决定的所有有趣的事情该怎么办。
.TP  0.5i
\fB\-\-debug\fP\fI[=FLAGS]\fP
除了正常处理外，还打印调试信息。 如果省略 \fIFLAGS\fP，则行为与指定 \fB\-d\fP 相同。 \fIFLAGS\fP
可以是以下任何或所有名称，以逗号或空格分隔。 只有第一个字符是重要的: 其余的可以省略: \fIall\fP 用于所有调试输出 (与使用 \fB\-d\fP)
相同，\fIbasic\fP 用于基本调试，\fIverbose\fP 用于更详细的基本调试，\fIimplicit\fP 用于显示隐式规则搜索操作，\fIjobs\fP
用于调用的详细信息命令，\fImakefile\fP 用于在重新制作 makefile 时进行调试，\fIprint\fP
显示所有运行的配方，即使它们是静默的，\fIwhy\fP 显示 \fBmake\fP 决定重建每个目标的原因。 使用 \fInone\fP 禁用所有以前的调试标志。
.TP  0.5i
\fB\-e\fP, \fB\-\-environment\-overrides\fP
使从环境中获取的变量优先于从 makefile 中获取的变量。
.TP  0.5i
\fB\-E\fP \fIstring\fP, \fB\-\-eval\fP \fIstring\fP
在解析任何 makefile 之前，使用 \fBeval\fP 函数解释 \fIstring\fP。
.TP  0.5i
\fB\-f\fP \fIfile\fP, \fB\-\-file\fP=\fIfile\fP, \fB\-\-makefile\fP=\fIFILE\fP
使用 \fIfile\fP 作为联编文件。
.TP  0.5i
\fB\-i\fP, \fB\-\-ignore\-errors\fP
忽略为重新制作文件而执行的命令中的所有错误。
.TP  0.5i
\fB\-I\fP \fIdir\fP, \fB\-\-include\-dir\fP=\fIdir\fP
指定目录 \fIdir\fP 以搜索包含的 makefile。 如果使用多个 \fB\-I\fP 选项指定多个目录，则按照指定的顺序搜索目录。 与 \fBmake\fP
的其他标志的引用不同，带有 \fB\-I\fP 标志的目录可能会直接出现在标志之后: \fB\-I\fP\fIdir\fP 是允许的，以及 \fB\-I\fP \fIdir\fP。
允许此语法与 C 预处理器的 \fB\-I\fP 标志兼容。
.TP  0.5i
\fB\-j\fP [\fIjobs\fP], \fB\-\-jobs\fP[=\fIjobs\fP]
指定同时运行的 \fIjobs\fP (commands) 的数量。 如果有多个 \fB\-j\fP 选项，最后一个有效。 如果在没有参数的情况下给出 \fB\-j\fP
选项，\fBmake\fP 将不会限制可以同时运行的作业数。
.TP  0.5i
\fB\-\-jobserver\-style=\fP\fIstyle\fP
要使用的作业服务器的样式。 \fIstyle\fP 可以是 \fBfifo\fP、\fBpipe\fP 或 \fBsem\fP (仅限 Windows) 之一。
.TP  0.5i
\fB\-k\fP, \fB\-\-keep\-going\fP
出错后尽可能继续。 虽然失败的目标和依赖于它的目标无法重新创建，但这些目标的其他依赖项可以完全相同地处理。
.TP  0.5i
\fB\-l\fP [\fIload\fP], \fB\-\-load\-average\fP[=\fIload\fP]
指定如果有其他作业正在运行且平均负载至少为 \fIload\fP (浮点数)，则不应启动新作业 (commands)。 没有参数，删除以前的负载限制。
.TP  0.5i
\fB\-L\fP, \fB\-\-check\-symlink\-times\fP
在符号链接和目标之间使用最新的 mtime。
.TP  0.5i
\fB\-n\fP, \fB\-\-just\-print\fP, \fB\-\-dry\-run\fP, \fB\-\-recon\fP
打印将要执行的命令，但不执行它们 (某些情况除外)。
.TP  0.5i
\fB\-o\fP \fIfile\fP, \fB\-\-old\-file\fP=\fIfile\fP, \fB\-\-assume\-old\fP=\fIfile\fP
不要重新制作文件 \fIfile\fP，即使它早于其依赖项，也不要因为 \fIfile\fP 中的更改而重新制作任何内容。
本质上，该文件被视为非常旧，其规则将被忽略。
.TP  0.5i
\fB\-O\fP[\fItype\fP], \fB\-\-output\-sync\fP[=\fItype\fP]
使用 \fB\-j\fP 在并行中运行多个作业时，请确保每个作业的输出都收集在一起，而不是散布在其他作业的输出中。 如果未指定 \fItype\fP 或者是
\fBtarget\fP，则每个目标的整个配方的输出将组合在一起。 如果 \fItype\fP 是 \fBline\fP，配方中每个命令行的输出将组合在一起。 如果
\fItype\fP 是 \fBrecurse\fP，则整个递归 make 的输出将组合在一起。 如果 \fItype\fP 为 \fBnone\fP，则输出同步被禁用。
.TP  0.5i
\fB\-p\fP, \fB\-\-print\-data\-base\fP
打印读取 makefile 产生的数据库 (规则和变量值) ; 然后照常执行或按其他规定执行。 这也会打印 \fB\-v\fP 开关给出的版本信息 (见下文)。
要打印数据库而不尝试重新制作任何文件，请使用 \fImake \-p \-f/dev/null\fP。
.TP  0.5i
\fB\-q\fP, \fB\-\-question\fP
\*(lq 问题模式 \*(rq。 不要运行任何命令，或打印任何东西; 如果指定的目标已经是最新的，则只返回一个退出状态为零，否则返回非零。
.TP  0.5i
\fB\-r\fP, \fB\-\-no\-builtin\-rules\fP
消除对内置隐式规则的使用。 还要清除后缀规则的默认后缀列表。
.TP  0.5i
\fB\-R\fP, \fB\-\-no\-builtin\-variables\fP
不要定义任何内置变量。
.TP  0.5i
\fB\-s\fP, \fB\-\-silent\fP, \fB\-\-quiet\fP
静音操作; 不要在执行时打印命令。
.TP  0.5i
\fB\-\-no\-silent\fP
取消 \fB\-s\fP 选项的影响。
.TP  0.5i
\fB\-S\fP, \fB\-\-no\-keep\-going\fP, \fB\-\-stop\fP
取消 \fB\-k\fP 选项的影响。
.TP  0.5i
\fB\-t\fP, \fB\-\-touch\fP
触摸文件 (将它们标记为最新而不真正更改它们) 而不是运行它们的命令。 这用于假装命令已完成，以欺骗 \fBmake\fP 的 future 调用。
.TP  0.5i
\fB\-\-trace\fP
打印有关每个目标的配置的信息 (为什么要重建目标以及运行什么命令来重建它)。
.TP  0.5i
\fB\-v\fP, \fB\-\-version\fP
打印 \fBmake\fP 程序的版本以及版权、作者列表和不提供保证的通知。
.TP  0.5i
\fB\-w\fP, \fB\-\-print\-directory\fP
在其他处理之前和之后打印包含工作目录的消息。 这对于从复杂的递归 \fBmake\fP 命令嵌套中跟踪错误可能很有用。
.TP  0.5i
\fB\-\-no\-print\-directory\fP
关闭 \fB\-w\fP，即使它是隐式打开的。
.TP  0.5i
\fB\-\-shuffle\fP\fI[=MODE]\fP
启用目标和先决条件排序的洗牌。 \fIMODE\fP 是禁用打乱模式的 \fInone\fP、以随机顺序打乱先决条件的 \fIrandom\fP、以相反顺序考虑先决条件的
\fIreverse\fP 或启用具有特定 \fIseed\fP 值的 \fIrandom\fP 模式的整数 \fI<seed>\fP 之一。 如果省略
\fIMODE\fP，则默认为 \fIrandom\fP。
.TP  0.5i
\fB\-W\fP \fIfile\fP, \fB\-\-what\-if\fP=\fIfile\fP, \fB\-\-new\-file\fP=\fIfile\fP, \fB\-\-assume\-new\fP=\fIfile\fP
假设目标 \fIfile\fP 刚刚被修改。 当与 \fB\-n\fP 标志一起使用时，这会向您显示如果您要修改该文件会发生什么。 没有 \fB\-n\fP，几乎与在运行
\fBmake\fP 之前在给定文件上运行 \fItouch\fP 命令一样，只是修改时间只是在 \fBmake\fP 的想象中改变。
.TP  0.5i
\fB\-\-warn\-undefined\-variables\fP
引用未定义的变量时发出警告。
.SH "EXIT STATUS"
GNU \fBmake\fP 如果所有 makefile 都被成功解析并且没有构建失败的目标，则退出时状态为零。 如果使用了 \fB\-q\fP 标志并且
\fBmake\fP 确定需要重建目标，则将返回状态 1。 如果遇到任何错误，将返回状态 2。
.SH "SEE ALSO"
\fBmake\fP 的完整文档作为 Texinfo 手册进行维护。 如果 \fBinfo\fP 和 \fBmake\fP 程序在您的站点上正确安装，则命令
.IP
\fBinfo make\fP
.PP
应该可以让您访问完整的手册。
.SH BUGS
请参见 \fIThe GNU Make Manual\fP 中的 `问题和错误` 一章。
.SH AUTHOR
本手册页由斯坦福大学的 Dennis Morse 提供。 Mike Frysinger 提供的进一步更新。 它已由 Roland McGrath
重新制作。 由保罗・史密斯维护。
.SH COPYRIGHT
Copyright \(co 1992\-1993, 1996\-2022 Free Software Foundation, Inc.   该文件是
\fIGNU make\fP 的一部分。
.LP
GNU Make 是免费软件; 您可以根据自由软件基金会发布的 GNU 通用公共许可证的条款重新分发或者修改它; 许可的第 3 版，或 (由您选择)
任何更高版本。
.LP
GNU Make 的发布是希望它有用，但不提供任何保证; 甚至没有针对特定用途的适销性或适用性的默示保证。 有关详细信息，请参见 GNU
通用公共许可证。
.LP
您应该已随本程序收到 GNU 通用公共许可证的副本。 如果不是，请参见 \fIhttps://www.gnu.org/licenses/\fP。
.PP
.SH [手册页中文版]
.PP
本翻译为免费文档；阅读
.UR https://www.gnu.org/licenses/gpl-3.0.html
GNU 通用公共许可证第 3 版
.UE
或稍后的版权条款。因使用该翻译而造成的任何问题和损失完全由您承担。
.PP
该中文翻译由 wtklbm
.B <wtklbm@gmail.com>
根据个人学习需要制作。
.PP
项目地址:
.UR \fBhttps://github.com/wtklbm/manpages-chinese\fR
.ME 。
