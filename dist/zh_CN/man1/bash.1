.\" -*- coding: UTF-8 -*-
.if  \n(zZ=1 .ig zZ
.\"
.\" MAN PAGE COMMENTS to
.\"
.\"	Chet Ramey
.\"	Case Western Reserve University
.\"	chet.ramey@case.edu
.\"
.\"	Last Change: Wed Sep 23 09:28:31 EDT 2020
.\"
.\" bash_builtins, strip all but Built-Ins section
.if  \n(zY=1 .ig zY
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH BASH 1 "2020 October 29" "GNU Bash 5.1" 
.de  FN
\fI\|\\$1\|\fP
..
.\"
.\" There's some problem with having a `@'
.\" in a tagged paragraph with the BSD man macros.
.\" It has to do with `@' appearing in the }1 macro.
.\" This is a problem on 4.3 BSD and Ultrix, but Sun
.\" appears to have fixed it.
.\" If you're seeing the characters
.\" `@u-3p' appearing before the lines reading
.\" `possible-hostname-completions
.\" and `complete-hostname' down in READLINE,
.\" then uncomment this redefinition.
.\"
.\" .de }1
.\" .ds ]X \&\*(]B\
.\" .nr )E 0
.\" .if !"\$1"" .nr )I \$1n
.\" .}f
.\" .ll \n(LLu
.\" .in \n()Ru+\n(INu+\n()Iu
.\" .ti \n(INu
.\" .ie !\n()Iu+\n()Ru-\w\*(]Xu-3p \{\*(]X
.\" .br\}
.\" .el \*(]X\h|\n()Iu+\n()Ru\c
.\" .}f
.\" ..
.\"
.\" File Name macro.  This used to be `.PN', for Path Name,
.\" but Sun doesn't seem to like that very much.
.\"
.SH NAME
bash \- GNU Bourne\-Again SHell
.SH SYNOPSIS
\fBbash\fP [options] [command_string | file]
.SH COPYRIGHT
.if  n Bash is Copyright (C) 1989-2020 by the Free Software Foundation, Inc.
.if  t Bash is Copyright \(co 1989-2020 by the Free Software Foundation, Inc.
.SH DESCRIPTION
\fBBash\fP 是一种 \fBsh\fP\-compatible 命令语言解释器，它执行从标准输入或文件中读取的命令。 \fBBash\fP 还结合了 \fIKorn\fP
和 \fIC\fP shells (\fBksh\fP 和 \fBcsh\fP) 的有用，特性。
.PP
\fBBash\fP 旨在成为 IEEE POSIX 规范 (IEEE 标准 1003.1) 的 Shell 和实用工具部分的一致实现。
默认情况下，\fBBash\fP 可以配置为符合 POSIX 标准。
.SH OPTIONS
\fBset\fP 内置命令的描述中记录的所有单字符 shell 选项 (包括 \fB\-o\fP) 都可以在调用 shell 时用作选项。 此外，\fBbash\fP
在调用时会解释以下选项:
.PP
.PD 0
.TP  10
\fB\-c\fP
如果存在 \fB\-c\fP 选项，则从第一个非选项参数 \fIcommand_string\fP 读取命令。 如果 \fIcommand_string\fP
后有参数，则第一个参数分配给 \fB$0\fP，其余参数分配给位置参数。 对 \fB$0\fP 的赋值设置 shell 的名称，用于警告和错误消息。
.TP 
\fB\-i\fP
如果存在 \fB\-i\fP 选项，则 shell 为 \fIinteractive\fP。
.TP 
\fB\-l\fP
使 \fBbash\fP 表现得好像它已被调用为登录 shell (请参见下面的
.SM
\fBINVOCATION\fP)。
.TP 
\fB\-r\fP
如果存在 \fB\-r\fP 选项，则 shell 变为 \fIrestricted\fP (请参见下面的
.SM
\fBRESTRICTED SHELL\fP)。
.TP 
\fB\-s\fP
如果存在 \fB\-s\fP 选项，或者如果在选项处理后没有参数剩余，则从标准输入读取命令。 此选项允许在调用交互式 shell
或通过管道读取输入时设置位置参数。
.TP 
\fB\-D\fP
在标准输出上打印所有以 \fB$\fP 开头的双引号字符串的列表。 当当前语言环境不是 \fBC\fP 或 \fBPOSIX\fP 时，这些是要进行语言翻译的字符串。
这意味着 \fB\-n\fP 选项; 不会执行任何命令。
.TP 
\fB[\-+]O [\fP\fIshopt_option\fP\fB]\fP
\fIshopt_option\fP 是内置 \fBshopt\fP 接受的 shell 选项之一 (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。 如果存在 \fIshopt_option\fP，则 \fB\-O\fP 设置该选项的值; \fB+O\fP 取消设置。 如果未提供
\fIshopt_option\fP，则 \fBshopt\fP 接受的 shell 选项的名称和值将打印在标准输出上。 如果调用选项为
\fB+O\fP，则输出以可作为输入重用的格式显示。
.TP 
\fB\-\-\fP
\fB\-\-\fP 表示选项结束并禁用进一步的选项处理。 \fB\-\-\fP 之后的任何参数都被视为文件名和参数。 \fB\-\fP 的一个参数相当于 \fB\-\-\fP。
.PD
.PP
\fBBash\fP 还解释了一些多字符选项。 这些选项必须出现在命令行中的单字符选项之前才能被识别。
.PP
.PD 0
.TP 
\fB\-\-debugger\fP
安排在 shell 启动之前执行调试器配置文件。 打开扩展调试模式 (参见下面对 \fBshopt\fP 内置的 \fBextdebug\fP 选项的描述)。
.TP 
\fB\-\-dump\-po\-strings\fP
等同于 \fB\-D\fP，但输出为 GNU \fIgettext\fP \fBpo\fP (便携对象) 文件格式。
.TP 
\fB\-\-dump\-strings\fP
相当于 \fB\-D\fP。
.TP 
\fB\-\-help\fP
在标准输出上显示用法消息并成功退出。
.TP 
\fB\-\-init\-file\fP \fIfile\fP 
.PD 0
.TP 
\fB\-\-rcfile\fP \fIfile\fP 
.PD
如果 shell 是交互式的，则从 \fIfile\fP 而不是标准的个人初始化文件 \fI~/.bashrc\fP 执行命令 (参见下面的
.SM
\fBINVOCATION\fP)。
.TP 
\fB\-\-login\fP
相当于 \fB\-l\fP。
.TP 
\fB\-\-noediting\fP
当 shell 交互时，不要使用 GNU \fBreadline\fP 库读取命令行。
.TP 
\fB\-\-noprofile\fP
不要读取系统范围的启动文件
.FN /etc/profile
或任何个人初始化文件 \fI~/.bash_profile\fP、\fI~/.bash_login\fP 或 \fI~/.profile\fP。
默认情况下，\fBbash\fP 在作为登录名 shell 调用时读取这些文件 (请参见下面的
.SM
\fBINVOCATION\fP)。
.TP 
\fB\-\-norc\fP
如果 shell 是交互式的，不要读取和执行个人初始化文件 \fI~/.bashrc\fP。 如果 shell 作为 \fBsh\fP 调用，则此选项默认打开。
.TP 
\fB\-\-posix\fP
更改默认操作不同于 POSIX 标准的 \fBbash\fP 的行为以匹配标准 (\fIposix mode\fP)。 请参见下面的
.SM
\fBSEE ALSO\fP 以获取详细说明 posix 模式如何影响 bash 行为的文档的引用。
.TP 
\fB\-\-restricted\fP
shell 受到限制 (参见下面的
.SM
\fBRESTRICTED SHELL\fP)。
.TP 
\fB\-\-verbose\fP
相当于 \fB\-v\fP。
.TP 
\fB\-\-version\fP
在标准输出上显示此 \fBbash\fP 实例的版本信息并成功退出。
.PD
.SH ARGUMENTS
如果参数在选项处理后仍然存在，并且既没有提供 \fB\-c\fP 也没有提供 \fB\-s\fP 选项，则第一个参数被假定为包含 shell 命令的文件的名称。
如果以这种方式调用 \fBbash\fP，则将 \fB$0\fP 设置为文件名，并将位置参数设置为剩余的参数。 \fBBash\fP
从这个文件中读取并执行命令，然后退出。 \fBBash\fP's 退出状态是脚本中执行的最后一条命令的退出状态。 如果没有执行任何命令，则退出状态为 0。
首先尝试打开当前目录中的文件，如果没有找到文件，则 shell 会在
.SM
\fBPATH\fP 中的目录中搜索脚本。
.SH INVOCATION
\fIlogin shell\fP 是参数零的第一个字符是 \fB\-\fP，或者以 \fB\-\-login\fP 选项开头的。
.PP
一个 \fIinteractive\fP shell 是一个启动时没有非选项参数 (除非指定了 \fB\-s\fP) 并且没有 \fB\-c\fP
选项，其标准输入和错误都连接到终端 (由 \fIisatty\fP(3)) 确定，或者是一个以 \fB\-i\fP 选项启动。
.SM
\fBPS1\fP
已设置，如果 \fBbash\fP 是交互式的，则 \fB$\-\fP 包括 \fBi\fP，允许 shell 脚本或启动文件测试此状态。
.PP
以下段落描述 \fBbash\fP 如何执行其启动文件。 如果存在任何文件但无法读取，则 \fBbash\fP 报告错误。 波浪号在文件名中展开，如下面
.SM
\fBEXPANSION\fP 部分的 \fBTilde Expansion\fP 下所述。
.PP
当 \fBbash\fP 作为交互式登录 shell 或作为带有 \fB\-\-login\fP 选项的非交互式 shell 被调用时，它首先从文件
\fI/etc/profile\fP 中读取并执行命令 (如果该文件存在)。 读取该文件后，它会按顺序查找
\fI~/.bash_profile\fP、\fI~/.bash_login\fP 和 \fI~/.profile\fP，然后从第一个存在且可读的文件开始读取和执行命令。
当 shell 启动时可以使用 \fB\-\-noprofile\fP 选项来抑制这种行为。
.PP
当交互式登录 shell 退出，或非交互式登录 shell 执行 \fBexit\fP 内置命令时，\fBbash\fP 从文件 \fI~/.bash_logout\fP
(如果存在) 中读取并执行命令。
.PP
当启动不是登录 shell 的交互式 shell 时，\fBbash\fP 会从 \fI~/.bashrc\fP 读取并执行命令 (如果该文件存在)。
这可以通过使用 \fB\-\-norc\fP 选项来禁止。 \fB\-\-rcfile\fP \fIfile\fP 选项将强制 \fBbash\fP 从 \fIfile\fP 而不是
\fI~/.bashrc\fP 读取和执行命令。
.PP
当 \fBbash\fP 非交互启动时，例如运行 shell 脚本，它会在环境中查找变量
.SM
\fBBASH_ENV\fP，如果出现则对其值进行扩展，并将扩展后的值作为文件名进行读取和读取执行。 \fBBash\fP 的行为就像执行了以下命令一样:
.sp .5
.RS
.if  t \f(CWif [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi\fP
.if  n if [ \-n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
.RE
.sp .5
但
.SM
\fBPATH\fP 变量的值不用于搜索文件名。
.PP
如果使用名称 \fBsh\fP 调用 \fBbash\fP，它会尝试尽可能模仿 \fBsh\fP 历史版本的启动行为，同时也符合 POSIX 标准。 当作为交互式登录
shell 或带有 \fB\-\-login\fP 选项的非交互式 shell 调用时，它首先尝试按顺序从 \fI/etc/profile\fP 和
\fI~/.profile\fP 读取和执行命令。 \fB\-\-noprofile\fP 选项可用于禁止此行为。 当作为名为 \fBsh\fP 的交互式 shell
调用时，\fBbash\fP 查找变量
.SM
\fBENV\fP，如果已定义则扩展其值，并将扩展值用作要读取和执行的文件的名称。 由于作为 \fBsh\fP
调用的 shell 不会尝试从任何其他启动文件读取和执行命令，因此 \fB\-\-rcfile\fP 选项无效。 使用名称 \fBsh\fP 调用的非交互式 shell
不会尝试读取任何其他启动文件。 当作为 \fBsh\fP 调用时，\fBbash\fP 在读取启动文件后进入 \fIposix\fP 模式。
.PP
当 \fBbash\fP 以 \fIposix\fP 模式启动时，与 \fB\-\-posix\fP 命令行选项一样，它遵循启动文件的 POSIX 标准。 在此模式下，交互式
shells 扩展
.SM
\fBENV\fP 变量，并从名称为扩展值的文件中读取和执行命令。 没有读取其他启动文件。
.PP
\fBBash\fP 尝试确定它何时在其标准输入连接到网络连接的情况下运行，就像远程 shell 守护进程 (通常是 \fIrshd\fP) 或安全 shell
守护进程 \fIsshd\fP 执行时一样。 如果 \fBbash\fP 确定它正在以这种方式运行，它会从 \fI~/.bashrc\fP 读取并执行命令
(如果该文件存在且可读)。 如果作为 \fBsh\fP 调用，它不会执行此操作。 \fB\-\-norc\fP 选项可用于禁止此行为，而 \fB\-\-rcfile\fP
选项可用于强制读取另一个文件，但 \fIrshd\fP 和 \fIsshd\fP 通常都不会使用这些选项调用 shell 或允许指定它们。
.PP
如果 shell 以有效用户 (group) id 不等于真实用户 (group) id 启动，并且未提供 \fB\-p\fP
选项，则不会读取任何启动文件，shell 函数未从环境中继承，
.SM
\fBSHELLOPTS\fP，
.SM
\fBBASHOPTS\fP，
.SM
\fBCDPATH\fP,
.SM
\fBGLOBIGNORE\fP 变量如果出现在环境中，将被忽略，有效用户 id 设置为真实用户 id。如果在调用时提供
\fB\-p\fP 选项，则启动行为相同，但不会重置有效用户 ID。
.SH DEFINITIONS
本文档的其余部分使用以下定义。
.PD 0
.TP 
\fBblank\fP
空格或制表符。
.TP 
\fBword\fP
被 shell 视为单个元的字符序列。 也称为 \fBtoken\fP。
.TP 
\fBname\fP
\fIword\fP 仅包含字母数字字符和下划线，并以字母字符或下划线开头。 也称为 \fBidentifier\fP。
.TP 
\fBmetacharacter\fP
一个字符，当不加引号时，用于分隔单词。 以下之一:
.br
.RS
.PP
.if  t \fB|  &  ;  (  )  <  >  space  tab  newline\fP
.if  n \fB|  & ; ( ) < > space tab newline\fP
.RE
.TP 
\fBcontrol operator\fP
执行控制函数的 \fItoken\fP。 它是以下符号之一:
.RS
.PP
.if  t \fB||  &  &&  ;  ;;  ;&  ;;&  (  )  |  |&    <newline>\fP
.if  n \fB|| & && ; ;; ;& ;;& ( ) | |& <newline>\fP
.RE
.PD
.SH "RESERVED WORDS"
\fIReserved words\fP 是对 shell 具有特殊含义的词。 以下字在未加引号时被识别为保留字，并且是命令的第一个字 (参见下面的
.SM
\fBSHELL GRAMMAR\fP)、\fBcase\fP 或 \fBselect\fP 命令的第三个字 (仅 \fBin\fP 有效) 或 \fBfor\fP
命令的第三个字 (仅 \fBin\fP 和 \fBdo\fP 有效) :
.if  t .RS
.PP
.B
.if  n ! case  coproc  do done elif else esac fi for function if in select then until while { } time [[ ]]
.if  t !    case    coproc    do    done    elif    else    esac    fi    for    function    if    in    select    then    until    while    {    }    time    [[    ]]
.if  t .RE
.SH "SHELL GRAMMAR"
.SS "Simple Commands"
\fIsimple command\fP 是一系列可选变量赋值，后跟 \fBblank\fP\-separated 字和重定向，并以 \fIcontrol operator\fP 终止。 第一个字指定要执行的命令，并作为参数零传递。 剩余的单词作为参数传递给调用的命令。
.PP
\fIsimple command\fP 的返回值是它的退出状态，如果命令被信号 \fIn\fP 终止，则返回 128+\fIn\^\fP。
.SS Pipelines
\fIpipeline\fP 是由控制运算符 \fB|\fP 或 \fB|&\fP 之一分隔的一个或多个命令的序列。 管道的格式为:
.RS
.PP
[\fBtime\fP [\fB\-p\fP]] [ ! ] \fIcommand\fP [ [\fB|\fP\(bv\fB|&\fP] \fIcommand2\fP ... ]
.RE
.PP
\fIcommand\fP 的标准输出通过管道连接到 \fIcommand2\fP 的标准输入。 此连接在命令指定的任何重定向之前执行 (请参见下面的
.SM
\fBREDIRECTION\fP)。 如果使用 \fB|&\fP，\fIcommand\fP's 标准错误除了它的标准输出外，还通过管道连接到
\fIcommand2\fP's 标准输入; 它是 \fB2>&1 |\fP 的简写。 在命令指定的任何重定向之后执行将标准错误隐式重定向到标准输出。
.PP
管道的返回状态是最后一个命令的退出状态，除非启用了 \fBpipefail\fP 选项。 如果启用
\fBpipefail\fP，则管道的返回状态是最后一个以非零状态退出的 (rightmost) 命令的值，如果所有命令都成功退出则为零。 如果保留字
\fB!\fP 位于管道之前，则该管道的退出状态是上述退出状态的逻辑否定。 shell 在返回值之前等待管道中的所有命令终止。
.PP
如果 \fBtime\fP 保留字在管道之前，则在管道终止时报告其执行所消耗的已用时间以及用户和系统时间。 \fB\-p\fP 选项将输出格式更改为 POSIX
指定的格式。 当 shell 在 \fIposix mode\fP 中时，如果下一个 token 以 '\-' 开头，它不会将 \fBtime\fP
识别为保留字。
.SM
\fBTIMEFORMAT\fP 变量可以设置为格式字符串，指定如何显示计时信息; 见下面 \fBShell Variables\fP
下
.SM
\fBTIMEFORMAT\fP 的说明。
.PP
当 shell 在 \fIposix mode\fP 中时，\fBtime\fP 后面可能跟一个换行符。 在这种情况下，shell 显示 shell
及其子进程消耗的总用户和系统时间。
.SM
\fBTIMEFORMAT\fP 变量可用于指定时间信息的格式。
.PP
管道中的每个命令都作为单独的进程执行 (即，在子 shell 中)。 有关子 shell 环境的描述，请参见
.SM
\fBCOMMAND EXECUTION ENVIRONMENT\fP。 如果使用内置的 \fBshopt\fP 启用了 \fBlastpipe\fP 选项 (请参见下面对 \fBshopt\fP
的描述)，管道的最后一个元素可能由 shell 进程运行。
.SS Lists
\fIlist\fP 是一个或多个管道的序列，由运算符 \fB;\fP、\fB&\fP、\fB&&\fP 或 \fB||\fP 之一分隔，并可选地由 \fB;\fP、\fB&\fP 或
\fB<newline>\fP 之一终止。
.PP
在这些列表运算符中，\fB&&\fP 和 \fB||\fP 具有同等优先级，其次是 \fB;\fP 和 \fB&\fP，它们具有同等优先级。
.PP
一个或多个换行符的序列可能出现在 \fIlist\fP 中，而不是分号来分隔命令。
.PP
如果命令被控制操作符 \fB&\fP 终止，则 shell 会在子 shell 中执行 \fIbackground\fP 中的命令。 shell
不等待命令完成，返回状态为 0。 这些被称为 \fIasynchronous\fP 命令。 由 \fB;\fP 分隔的命令按顺序执行; shell
依次等待每个命令终止。 返回状态是最后执行的命令的退出状态。
.PP
AND 和 OR 列表是一个或多个管道的序列，分别由 \fB&&\fP 和 \fB||\fP 控件运算符分隔。 AND 和 OR 列表以左结合律执行。 AND
列表具有以下形式
.RS
.PP
\fIcommand1\fP \fB&&\fP \fIcommand2\fP
.RE
.PP
当且仅当 \fIcommand1\fP 返回零 (success) 的退出状态时，才会执行 \fIcommand2\fP。
.PP
OR 列表具有以下形式
.RS
.PP
\fIcommand1\fP \fB||\fP \fIcommand2\fP
.RE
.PP
当且仅当 \fIcommand1\fP 返回非零退出状态时，才会执行 \fIcommand2\fP。 AND 和 OR
列表的返回状态是列表中最后执行的命令的退出状态。
.SS "Compound Commands"
\fIcompound command\fP 是以下之一。 在大多数情况下，命令描述中的 \fIlist\fP
可以用一个或多个换行符与命令的其余部分分隔开，并且后面可以用换行符代替分号。
.TP 
(\fIlist\fP)
\fIlist\fP 在子 shell 环境中执行 (参见下面的
.SM
\fBCOMMAND EXECUTION ENVIRONMENT\fP)。
命令完成后，影响 shell 环境的变量分配和内置命令不会保持有效。 返回状态为 \fIlist\fP 的退出状态。
.TP 
{ \fIlist\fP; }
\fIlist\fP 只是在当前的 shell 环境中执行。 \fIlist\fP 必须以换行符或分号结束。 这称为 \fIgroup command\fP。 返回状态为
\fIlist\fP 的退出状态。 请注意，与元字符 \fB(\fP 和 \fB)\fP 不同，\fB{\fP 和 \fB}\fP 是 \fIreserved words\fP，并且必须出现在允许识别保留字的位置。 由于它们不会导致断字，因此必须用空格或另一个 shell 元字符将它们与 \fIlist\fP 分开。
.TP 
((\fIexpression\fP))
\fIexpression\fP 根据下面
.SM
\fBARITHMETIC EVALUATION\fP 下描述的规则进行评估。
如果表达式的值不为零，则返回状态为 0; 否则返回状态为 1。 这完全等同于 \fBlet "\fP\fIexpression\fP\fB"\fP。
.TP 
\fB[[\fP \fIexpression\fP \fB]]\fP
根据条件表达式 \fIexpression\fP 的评估，返回状态 0 或 1。 表达式由下面
.SM
\fBCONDITIONAL EXPRESSIONS\fP 下描述的原色组成。 \fB[[\fP 和 \fB]]\fP 之间的词不进行分词和路径扩展;
执行波浪号扩展、参数和变量扩展、算术扩展、命令替换、进程替换和引用删除。 条件运算符如 \fB\-f\fP 必须不加引号才能被识别为初选。
.if  t .sp 0.5
.if  n .sp 1
当与 \fB[[\fP 一起使用时，\fB<\fP 和 \fB>\fP 运算符使用当前语言环境按字典顺序排序。
.if  t .sp 0.5
.if  n .sp 1
当使用 \fB==\fP 和 \fB!=\fP 运算符时，运算符右侧的字符串被视为模式并根据下面在 \fBPattern Matching\fP
下描述的规则进行匹配，就好像启用了 \fBextglob\fP shell 选项一样。 \fB=\fP 运算符等同于 \fB==\fP。 如果启用
\fBnocasematch\fP shell 选项，则执行匹配时不考虑字母字符的大小写。 如果字符串匹配 (\fB==\fP) 或不匹配 (\fB!=\fP)
模式，则返回值为 0，否则为 1。 可以引用模式的任何部分以强制将引用的部分作为字符串进行匹配。
.if  t .sp 0.5
.if  n .sp 1
可以使用额外的二元运算符 \fB=~\fP，其优先级与 \fB==\fP 和 \fB!=\fP 相同。 使用时，运算符右边的字符串被认为是 POSIX
扩展正则表达式并进行相应匹配 (使用 \fIregex\fP(3)).POSIX \fIregcomp\fP 和 \fIregexec\fP 接口通常描述)。
如果字符串与模式匹配，则返回值为 0，否则为 1。 如果正则表达式在语法上不正确，则条件表达式的返回值为 2。 如果启用 \fBnocasematch\fP
shell 选项，则执行匹配时不考虑字母字符的大小写。 可以引用模式的任何部分以强制将引用的部分作为字符串进行匹配。
正则表达式中的括号表达式必须小心处理，因为普通的引号字符在括号之间失去了意义。 如果模式存储在 shell
变量中，引用变量扩展会强制将整个模式作为字符串进行匹配。
.if  t .sp 0.5
.if  n .sp 1
如果模式与字符串的任何部分匹配，则该模式将匹配。 使用 \fB^\fP 和 \fB$\fP 正则表达式运算符来锚定模式以强制它匹配整个字符串。 数组变量
.SM
\fBBASH_REMATCH\fP 记录字符串的哪些部分与模式匹配。
.SM
\fBBASH_REMATCH\fP 的索引为 0
的元素包含与整个正则表达式匹配的字符串部分。 与正则表达式中带括号的子表达式匹配的子字符串保存在剩余的
.SM
\fBBASH_REMATCH\fP
索引中。
.SM
\fBBASH_REMATCH\fP 中索引为 \fIn\fP 的元素是与 \fIn\fPth 括号内的子表达式匹配的字符串部分。
.if  t .sp 0.5
.if  n .sp 1
可以使用以下运算符组合表达式，按优先级降序排列:
.if  t .sp 0.5
.if  n .sp 1
.RS
.PD 0
.TP 
\fB( \fP\fIexpression\fP\fB )\fP
返回 \fIexpression\fP 的值。 这可用于覆盖运算符的正常优先级。
.TP 
\fB! \fP\fIexpression\fP
如果 \fIexpression\fP 为假，则为真。
.TP 
\fIexpression1\fP \fB&&\fP \fIexpression2\fP
如果 \fIexpression1\fP 和 \fIexpression2\fP 都为真，则为真。
.TP 
\fIexpression1\fP \fB||\fP \fIexpression2\fP
如果 \fIexpression1\fP 或 \fIexpression2\fP 为真，则为真。
.PD
.LP
如果 \fIexpression1\fP 的值足以确定整个条件表达式的返回值，则 \fB&&\fP 和 \fB||\fP 运算符不会计算 \fIexpression2\fP。
.RE
.TP 
\fBfor\fP \fIname\fP [ [ \fBin\fP [ \fIword ...\fP ] ] ; ] \fBdo\fP \fIlist\fP ; \fBdone\fP
\fBin\fP 后面的单词列表被扩展，生成一个列表项。 变量 \fIname\fP 依次设置为这个列表的每个元素，每次执行 \fIlist\fP。 如果省略 \fBin\fP
\fIword\fP，则 \fBfor\fP 指令对每个设置的位置参数执行一次 \fIlist\fP (参见下面的
.SM
\fBPARAMETERS\fP)。
返回状态是执行的最后一个命令的退出状态。 如果 \fBin\fP 后面的项展开为空列表，则不执行任何命令，返回状态为 0.
.TP 
\fBfor\fP (( \fIexpr1\fP ; \fIexpr2\fP ; \fIexpr3\fP )) ; \fBdo\fP \fIlist\fP ; \fBdone\fP
首先，根据
.SM
\fBARITHMETIC EVALUATION\fP 下描述的规则对算术表达式 \fIexpr1\fP 求值。 然后重复计算算术表达式
\fIexpr2\fP，直到它的计算结果为零。 每次 \fIexpr2\fP 的计算结果为非零值时，都会执行 \fIlist\fP 并计算算术表达式 \fIexpr3\fP。
如果省略任何表达式，它的行为就好像它的计算结果为 1。 返回值是 \fIlist\fP 中执行的最后一个命令的退出状态，如果任何表达式无效则返回 false。
.TP 
\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP ] ; \fBdo\fP \fIlist\fP ; \fBdone\fP
\fBin\fP 后面的单词列表被扩展，生成一个列表项。 扩展单词集打印在标准错误上，每个单词前面都有一个数字。 如果省略 \fBin\fP
\fIword\fP，则打印位置参数 (见下面的
.SM
\fBPARAMETERS\fP)。 然后显示
.SM
\fBPS3\fP
提示，并从标准输入中读取一行。 如果该行包含与显示的单词之一相对应的数字，则 \fIname\fP 的值设置为该单词。 如果该行为空，则再次显示单词和提示。
如果读取到 EOF，则命令完成。 读取的任何其他值都会导致 \fIname\fP 设置为空。 读取的行保存在变量
.SM
\fBREPLY\fP 中。
每次选择后执行 \fIlist\fP，直到执行 \fBbreak\fP 命令。 \fBselect\fP 的退出状态是在 \fIlist\fP
中执行的最后一个命令的退出状态，如果没有执行任何命令，则为零。
.TP 
\fBcase\fP \fIword\fP \fBin\fP [ [(] \fIpattern\fP [ \fB|\fP \fIpattern\fP ] ... ) \fIlist\fP ;; ] ... \fBesac\fP
\fBcase\fP 命令首先扩展 \fIword\fP，并尝试使用下面 \fBPattern Matching\fP 中描述的匹配规则依次将其与每个
\fIpattern\fP 匹配。 \fIword\fP 使用波浪号扩展、参数和变量扩展、算术扩展、命令替换、进程替换和引用删除进行扩展。 检查的每个
\fIpattern\fP 都使用波浪号扩展、参数和变量扩展、算术扩展、命令替换和进程替换进行扩展。 如果启用 \fBnocasematch\fP shell
选项，则执行匹配时不考虑字母字符的大小写。 当找到匹配项时，将执行相应的 \fIlist\fP。 如果使用 \fB;;\fP
运算符，则在第一次模式匹配后不会尝试后续匹配。 使用 \fB;&\fP 代替 \fB;;\fP 会导致继续执行与下一组模式关联的 \fIlist\fP。 使用
\fB;;&\fP 代替 \fB;;\fP 会导致 shell 测试语句中的下一个模式列表 (如果有)，并在成功匹配时执行任何关联的 \fIlist\fP，继续执行
case 语句，就好像模式列表没有匹配一样。 如果没有模式匹配，则退出状态为零。 否则，它是在 \fIlist\fP 中执行的最后一个命令的退出状态。
.TP 
\fBif\fP \fIlist\fP; \fBthen\fP \fIlist\fP; [ \fBelif\fP \fIlist\fP; \fBthen\fP \fIlist\fP; ] ... [ \fBelse\fP \fIlist\fP; ] \fBfi\fP
\fBif\fP \fIlist\fP 被执行。 如果其退出状态为零，则执行 \fBthen\fP \fIlist\fP。 否则，依次执行每个 \fBelif\fP
\fIlist\fP，如果其退出状态为零，则执行对应的 \fBthen\fP \fIlist\fP，命令完成。 否则，执行 \fBelse\fP \fIlist\fP (如果存在)。
退出状态是最后执行的命令的退出状态，如果没有条件测试为真则为零。
.TP 
\fBwhile\fP \fIlist\-1\fP; \fBdo\fP \fIlist\-2\fP; \fBdone\fP
.PD 0
.TP 
\fBuntil\fP \fIlist\-1\fP; \fBdo\fP \fIlist\-2\fP; \fBdone\fP
.PD
只要列表 \fIlist\-1\fP 中的最后一个命令返回退出状态为零，\fBwhile\fP 命令就会连续执行列表 \fIlist\-2\fP。 \fBuntil\fP 命令与
\fBwhile\fP 命令相同，只是测试被否定: 只要 \fIlist\-1\fP 中的最后一个命令返回非零退出状态，就会执行 \fIlist\-2\fP。
\fBwhile\fP 和 \fBuntil\fP 命令的退出状态是在 \fIlist\-2\fP 中执行的最后一个命令的退出状态，如果没有执行则为零。
.SS Coprocesses
\fIcoprocess\fP 是前面带有 \fBcoproc\fP 保留字的 shell 命令。 协进程在子 shell 中异步执行，就好像命令已使用 \fB&\fP
控制运算符终止一样，在执行 shell 和协进程之间建立双向管道。
.PP
协同处理的格式为:
.RS
.PP
\fBcoproc\fP [\fINAME\fP] \fIcommand\fP [\fIredirections\fP]
.RE
.PP
这将创建一个名为 \fINAME\fP 的协进程。 如果未提供 \fINAME\fP，则默认名称为 \fBCOPROC\fP。 如果 \fIcommand\fP 是
\fIsimple command\fP (见上文)，则不得提供 \fINAME\fP; 否则，它被解释为简单命令的第一个词。 执行协程时，shell 在执行
shell 的上下文中创建一个名为 \fINAME\fP 的数组变量 (参见下面的 \fBArrays\fP)。 \fIcommand\fP
的标准输出通过管道连接到正在执行的 shell 中的文件描述符，并将该文件描述符分配给 \fINAME\fP[0]。 \fIcommand\fP
的标准输入通过管道连接到正在执行的 shell 中的文件描述符，并将该文件描述符分配给 \fINAME\fP[1]。 此管道在命令指定的任何重定向之前建立
(请参见下面的
.SM
\fBREDIRECTION\fP)。 文件描述符可以用作 shell 命令的参数和使用标准字扩展的重定向。
除了那些为执行命令和进程替换而创建的文件描述符外，文件描述符在子 shell 中不可用。 shell 的进程 ID 产生以执行协进程，可作为变量
\fINAME\fP_PID 的值使用。\fBwait\fP 内置命令可用于等待协进程终止。
.PP
由于协同进程是作为异步命令创建的，因此 \fBcoproc\fP 命令总是返回成功。 协程的返回状态是 \fIcommand\fP 的退出状态。
.SS "Shell Function Definitions"
shell 函数是一个像简单命令一样调用的对象，并使用一组新的位置参数执行复合命令。 Shell 函数声明如下:
.TP 
\fIfname\fP () \fIcompound\-command\fP [\fIredirection\fP]
.PD 0
.TP 
\fBfunction\fP \fIfname\fP [()] \fIcompound\-command\fP [\fIredirection\fP]
.PD
这定义了一个名为 \fIfname\fP 的函数。 保留字 \fBfunction\fP 是可选的。 如果提供了 \fBfunction\fP 保留字，则括号是可选的。
函数的 \fIbody\fP 是复合指令 \fIcompound\-command\fP (见上文 \fBCompound Commands\fP)。 该命令通常是 {
and } 之间的命令 \fIlist\fP，但也可以是上面 \fBCompound Commands\fP 下列出的任何命令，但有一个例外: 如果使用
\fBfunction\fP 保留字，但未提供括号，则需要大括号。 只要将 \fIfname\fP 指定为简单命令的名称，就会执行
\fIcompound\-command\fP。 在 \fIposix mode\fP 中时，\fIfname\fP 必须是有效的 shell \fIname\fP，并且不能是
POSIX \fIspecial builtins\fP 之一的名称。 在默认模式下，一个函数名称可以是任何不包含 \fB$\fP 的未加引号的 shell 单词。
执行函数时，会执行在定义函数时指定的任何重定向 (请参见下面的
.SM
\fBREDIRECTION\fP)。
一个函数定义的退出状态为零，除非出现语法错误或同名的只读函数已经存在。 执行时，一个函数的退出状态是主体中执行的最后一个命令的退出状态。 (参见下面的
.SM
\fBFUNCTIONS\fP。)
.SH COMMENTS
在非交互式 shell 或交互式 shell 中，其中启用了 \fBshopt\fP 内置的 \fBinteractive_comments\fP 选项
(请参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)，以 \fB#\fP 开头的单词会导致该单词和该行上的所有剩余字符被忽略。
未启用 \fBinteractive_comments\fP 选项的交互式 shell 不允许注释。 \fBinteractive_comments\fP
选项在交互式 shells 中默认打开。
.SH QUOTING
\fIQuoting\fP 用于去除某些字符或单词对 shell 的特殊含义。
引号可用于禁用对特殊字符的特殊处理，以防止保留字被识别为保留字，并防止参数扩展。
.PP
.SM
\fBDEFINITIONS\fP 下面列出的每一个 \fImetacharacters\fP 对 shell
都有特殊的意义，如果要代表它自己就必须加引号。
.PP
当使用命令历史扩展功能时 (参见下面的
.SM
\fBHISTORY EXPANSION\fP)，必须引用 \fIhistory expansion\fP
字符 (通常为 \fB!\fP) 以防止历史扩展。
.PP
存在三种引用机制: \fIescape character\fP、单引号和双引号。
.PP
不带引号的反斜杠 (\fB\e\fP) 是 \fIescape character\fP。 它保留下一个字符的字符值，<newline> 除外。
如果出现 \fB\e\fP<newline> 对，并且反斜杠本身未被引用，则 \fB\e\fP<newline> 被视为续行
(即，它从输入流中删除并被有效地忽略)。
.PP
将字符括在单引号中会保留引号内每个字符的字符值。 单引号之间不能出现单引号，即使前面有反斜杠也是如此。
.PP
用双引号括起字符会保留引号内所有字符的字符值，但 \fB$\fP、\fB\`\fP、\fB\e\fP 和启用历史扩展时的 \fB!\fP 除外。 当 shell 在
\fIposix mode\fP 中时，双引号内的 \fB!\fP 没有特殊含义，即使启用了历史扩展。 字符 \fB$\fP 和 \fB\`\fP 在双引号内保留其特殊含义。
仅当反斜杠后跟以下字符之一时，反斜杠才保留其特殊含义: \fB$\fP、\fB\`\fP、\^\fB"\fP\^、\fB\e\fP 或
\fB<newline>\fP。 双引号可以通过在其前面加上反斜杠来在双引号内引用。
如果启用，将执行历史扩展，除非使用反斜杠对出现在双引号中的 \fB!\fP 进行转义。 \fB!\fP 前面的反斜杠没有被删除。
.PP
特殊参数 \fB*\fP 和 \fB@\fP 在双引号中具有特殊含义 (参见下面的
.SM
\fBPARAMETERS\fP)。
.PP
\fB$\fP\(aq\fIstring\fP\(aq 形式的词被特殊对待。 该词扩展为 \fIstring\fP，并按照 ANSI C 标准的规定替换反斜杠转义字符。
反斜杠转义序列 (如果存在) 按如下方式解码:
.RS
.PD 0
.TP 
\fB\ea\fP
警报 (bell)
.TP 
\fB\eb\fP
backspace
.TP 
\fB\ee\fP
.TP 
\fB\eE\fP
转义字符
.TP 
\fB\ef\fP
换页
.TP 
\fB\en\fP
新队
.TP 
\fB\er\fP
回车
.TP 
\fB\et\fP
水平制表符
.TP 
\fB\ev\fP
垂直制表符
.TP 
\fB\e\e\fP
backslash
.TP 
\fB\e\(aq\fP
单引号
.TP 
\fB\e"\fP
双引号
.TP 
\fB\e?\fP
问号
.TP 
\fB\e\fP\fInnn\fP
值为八进制值 \fInnn\fP (一到三个八进制数字) 的八位字符
.TP 
\fB\ex\fP\fIHH\fP
值为十六进制值 \fIHH\fP (一个或两个十六进制数字) 的八位字符
.TP 
\fB\eu\fP\fIHHHH\fP
值为十六进制值 \fIHHHH\fP (一到四位十六进制数字) 的 Unicode (ISO/IEC 10646) 字符
.TP 
\fB\eU\fP\fIHHHHHHHH\fP
值为十六进制值 \fIHHHHHHHH\fP (一到八个十六进制数字) 的 Unicode (ISO/IEC 10646) 字符
.TP 
\fB\ec\fP\fIx\fP
一个 control\-\fIx\fP 字符
.PD
.RE
.LP
扩展后的结果是单引号，就好像美元符号不存在一样。
.PP
前面带有美元符号 (\fB$\fP"\fIstring\fP") 的双引号字符串将导致根据当前语言环境翻译字符串。 \fIgettext\fP 基础结构使用
\fBLC_MESSAGES\fP 和 \fBTEXTDOMAIN\fP shell 变量执行消息目录查找和翻译。 如果当前语言环境是 \fBC\fP 或
\fBPOSIX\fP，或者如果没有可用的翻译，美元符号将被忽略。 如果字符串被翻译和替换，则替换用双引号引起来。
.SH PARAMETERS
\fIparameter\fP 是存储值的实体。 它可以是 \fIname\fP、数字或下面 \fBSpecial Parameters\fP 下列出的特殊字符之一。
\fIvariable\fP 是由 \fIname\fP 表示的参数。 一个变量有一个 \fIvalue\fP 和零个或多个 \fIattributes\fP。 使用
\fBdeclare\fP 内置命令分配属性 (请参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP) 中的 \fBdeclare\fP。
.PP
如果参数已被赋值，则该参数被设置。 空字符串是有效值。 设置变量后，只能使用 \fBunset\fP 内置命令取消设置 (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.PP
\fIvariable\fP 可以通过以下形式的语句分配给
.RS
.PP
\fIname\fP=[\fIvalue\fP]
.RE
.PP
如果未给出 \fIvalue\fP，则为变量分配空字符串。 所有 \fIvalues\fP 都经过波浪线扩展、参数和变量扩展、命令替换、算术扩展和引号删除
(参见下面的
.SM
\fBEXPANSION\fP)。 如果变量设置了 \fBinteger\fP 属性，则 \fIvalue\fP
被计算为算术表达式，即使未使用 $((...)) 扩展 (参见下面的 \fBArithmetic Expansion\fP)。 不执行单词拆分，但
\fB"$@"\fP 除外，如下面在 \fBSpecial Parameters\fP 下解释的那样。 不执行路径名扩展。 对于
\fBalias\fP、\fBdeclare\fP、\fBtypeset\fP、\fBexport\fP、\fBreadonly\fP 和 \fBlocal\fP 内置命令
(\fIdeclaration\fP 命令，赋值语句也可能显示为参数)。 在 \fIposix mode\fP 中时，这些内置命令可能出现在 \fBcommand\fP
内置命令的一个或多个实例之后的命令中，并保留这些赋值语句属性。
.PP
在赋值语句为 shell 变量或数组索引赋值的上下文中，+= 运算符可用于追加或添加到变量的先前值。 这包括对接受赋值的内置命令 (例如
\fBdeclare\fP 语句 (\fIdeclaration\fP 命令) 的参数。 当 += 应用于已设置 \fIinteger\fP
属性的变量时，\fIvalue\fP 将作为算术表达式求值并添加到变量的当前值，该值也会被求值。 当 += 使用复合赋值应用于数组变量时 (请参见下面的
\fBArrays\fP)，变量的值不会被取消设置 (就像使用 = 时一样)，并且新值将从大于数组最大索引的 1 开始追加到数组 (对于索引数组)
或作为，追加，键值对添加到关联数组中。 当应用于字符串值变量时，\fIvalue\fP 被扩展并追加到变量的值。
.PP
可以使用 \fBdeclare\fP 或 \fBlocal\fP 内置命令的 \fB\-n\fP 选项为变量分配 \fInameref\fP 属性 (请参见下面的
\fBdeclare\fP 和 \fBlocal\fP 的说明) 以创建 \fInameref\fP，或引用另一个变量。 这允许间接操纵变量。 每当 nameref
变量被引用、分配、取消设置或修改其属性时 (除了使用或更改 \fInameref\fP 属性本身)，操作实际上是在 nameref 变量值指定的变量上执行的。
shell 函数中通常使用 nameref 来引用其名称作为参数传递给函数的变量。 例如，如果将变量名作为第一个参数传递给 shell 函数，则运行
.sp .5
.RS
.if  t \f(CWdeclare -n ref=$1\fP
.if  n declare -n ref=$1
.RE
.sp .5
在函数内部创建一个 nameref 变量 \fBref\fP，其值是作为第一个参数传递的变量名称。 对 \fBref\fP
的引用和赋值，以及对其属性的更改，被视为对名称作为 \fB$1\fP 传递的变量的引用、赋值和属性修改。 如果 \fBfor\fP 循环中的控制变量具有
nameref 属性，则单词列表可以是 shell 变量的列表，并在循环执行时依次为列表中的每个单词建立一个名称引用。 数组变量不能赋予
\fBnameref\fP 属性。 但是，nameref 变量可以引用数组变量和下标数组变量。 可以使用 \fBunset\fP 内置的 \fB\-n\fP 选项取消设置
Namerefs。 否则，如果 \fBunset\fP 以 nameref 变量的名称作为参数执行，则 nameref 变量引用的变量将被取消设置。
.SS "Positional Parameters"
\fIpositional parameter\fP 是由一个或多个数字表示的参数，而不是单个数字 0。 位置参数在调用时从 shell
的参数分配，并且可以使用 \fBset\fP 内置命令重新分配。 位置参数不能赋值给语言句。 当执行 shell 函数时，位置参数会被临时替换 (参见下面的
.SM
\fBFUNCTIONS\fP)。
.PP
当由一个以上的数字组成的位置参数被扩展时，它必须用大括号括起来 (见下面的
.SM
\fBEXPANSION\fP)。
.SS "Special Parameters"
shell 对几个参数进行了特殊处理。 这些参数仅供参考; 不允许分配给他们。
.PD 0
.TP 
\fB*\fP
从一个开始扩展到位置参数。 当扩展不在双引号内时，每个位置参数都会扩展为一个单独的词。
在执行它的上下文中，这些词会受到进一步的词拆分和路径名扩展的影响。 当扩展发生在双引号内时，它扩展为单个单词，每个参数的值由
.SM
\fBIFS\fP
特殊变量的第一个字符分隔。 也就是说，"\fB$*\fP" 等同于 "\fB$1\fP\fIc\fP\fB$2\fP\fIc\fP\fB...\fP"，其中 \fIc\fP 是
.SM
\fBIFS\fP 变量值的第一个字符。 如果
.SM
\fBIFS\fP 未设置，则参数以空格分隔。 如果
.SM
\fBIFS\fP
为空，参数将在没有中间分隔符的情况下连接。
.TP 
\fB@\fP
从一个开始扩展到位置参数。 在执行分词的上下文中，这会将每个位置参数扩展为一个单独的词; 如果不在双引号内，这些词会被分词。
在不执行单词拆分的上下文中，这会扩展为单个单词，每个位置参数由空格分隔。 当扩展发生在双引号内时，每个参数都会扩展为一个单独的词。 即 "\fB$@\fP"
等同于 "\fB$1\fP" "\fB$2\fP" ...
如果双引号扩展出现在一个单词中，则第一个参数的扩展与原始单词的开头部分连接，最后一个参数的扩展与原始单词的最后部分连接。
当没有位置参数时，"\fB$@\fP" 和 \fB$@\fP 展开为空 (即，它们被删除)。
.TP 
\fB#\fP
扩展为十进制位置参数的数量。
.TP 
\fB?\fP
扩展到最近执行的前台管道的退出状态。
.TP 
\fB\-\fP
扩展到调用时指定的当前选项标志，由 \fBset\fP 内置命令或由 shell 本身设置的选项 (例如 \fB\-i\fP 选项)。
.TP 
\fB$\fP
扩展为 shell 的进程 ID。 在 () 子 shell 中，它扩展为当前 shell 的进程 ID，而不是子 shell。
.TP 
\fB!\fP
扩展为最近放入后台的作业的进程 ID，无论是作为异步命令执行还是使用 \fBbg\fP 内置 (请参见下面的
.SM
\fBJOB CONTROL\fP)。
.TP 
\fB0\fP
扩展为 shell 或 shell 脚本的名称。 这是在 shell 初始化时设置的。 如果使用命令文件调用 \fBbash\fP，则 \fB$0\fP
设置为该文件的名称。 如果 \fBbash\fP 以 \fB\-c\fP 选项启动，则 \fB$0\fP 设置为要执行的字符串之后的第一个参数 (如果存在的话)。
否则，它被设置为用于调用 \fBbash\fP 的文件名，由参数零给出。
.PD
.SS "Shell Variables"
以下变量由 shell 设置:
.PP
.PD 0
.TP 
\fB_\fP
在 shell 启动时，设置为用于调用在环境或参数列表中传递的正在执行的 shell 或 shell 脚本的路径名。
随后，扩展到最后一个参数到前面在前台执行的简单命令，扩展后。 还设置为用于调用执行的每个命令并放置在导出到该命令的环境中的完整路径名。
检查邮件时，此参数保存当前正在检查的邮件文件的名称。
.TP 
\fBBASH\fP
扩展为用于调用此 \fBbash\fP 实例的完整文件名。
.TP 
\fBBASHOPTS\fP
已启用的 shell 选项的冒号分隔列表。 列表中的每个单词都是 \fBshopt\fP 内置命令的 \fB\-s\fP 选项的有效参数 (请参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.SM
\fBBASHOPTS\fP 中出现的选项是由 \fBshopt\fP 报告为 \fIon\fP
的选项。 如果此变量在 \fBbash\fP 启动时的环境中，则列表中的每个 shell 选项都将在读取任何启动文件之前启用。 该变量是只读的。
.TP 
\fBBASHPID\fP
扩展为当前 \fBbash\fP 进程的进程 ID。 这在某些情况下不同于 \fB$$\fP，例如不需要重新初始化 \fBbash\fP 的子外壳。 分配给
.SM
\fBBASHPID\fP 无效。 如果 \fBBASHPID\fP 未设置，它将失去其特殊属性，即使它随后被重置。
.TP 
\fBBASH_ALIASES\fP
一个关联数组变量，其成员对应于由 \fBalias\fP 内置维护的内部别名列表。 添加到此数组的元素出现在别名列表中;
但是，取消设置数组元素目前不会导致从别名列表中删除别名。 如果 \fBBASH_ALIASES\fP 未设置，它将失去其特殊属性，即使它随后被重置。
.TP 
\fBBASH_ARGC\fP
一个数组变量，其值为当前 \fBbash\fP 执行调用栈中每一帧的参数个数。 当前子程序的参数个数 (shell 函数或用 \fB.\fP 或
\fBsource\fP) 执行的脚本在栈顶。 执行子程序时，传递的参数个数被压入
.SM
\fBBASH_ARGC\fP。 shell
仅在扩展调试模式下设置
.SM
\fBBASH_ARGC\fP (请参见下面对 \fBshopt\fP 内置的 \fBextdebug\fP 选项的描述)。 在
shell 开始执行脚本后设置 \fBextdebug\fP，或在未设置 \fBextdebug\fP 时引用此变量，可能会导致值不一致。
.TP 
\fBBASH_ARGV\fP
一个数组变量，包含当前 \fBbash\fP 执行调用栈中的所有参数。 最后一个子程序调用的最终参数在栈顶; 初始调用的第一个参数在底部。
执行子程序时，提供的参数将被推送到
.SM
\fBBASH_ARGV\fP。 shell 仅在扩展调试模式下设置
.SM
\fBBASH_ARGV\fP
(请参见下面对 \fBshopt\fP 内置的 \fBextdebug\fP 选项的描述)。 在 shell 开始执行脚本后设置 \fBextdebug\fP，或在未设置
\fBextdebug\fP 时引用此变量，可能会导致值不一致。
.TP 
\fBBASH_ARGV0\fP
引用时，此变量扩展为 shell 或 shell 脚本的名称 (与 \fB$0\fP 相同; 请参见上面特殊参数 0 的说明)。 分配给
\fBBASH_ARGV0\fP 会导致分配的值也分配给 \fB$0\fP。 如果 \fBBASH_ARGV0\fP 未设置，它将失去其特殊属性，即使它随后被重置。
.TP 
\fBBASH_CMDS\fP
一个关联数组变量，其成员对应于由 \fBhash\fP 内置命令维护的内部命令哈希表。 添加到这个数组的元素出现在哈希表中;
但是，取消设置数组元素目前不会导致从哈希表中删除命令名称。 如果 \fBBASH_CMDS\fP 未设置，它将失去其特殊属性，即使它随后被重置。
.TP 
\fBBASH_COMMAND\fP
当前正在执行或将要执行的命令，除非 shell 正在执行命令作为陷阱的结果，在这种情况下，它是在陷阱时执行的命令。 如果 \fBBASH_COMMAND\fP
未设置，它将失去其特殊属性，即使它随后被重置。
.TP 
\fBBASH_EXECUTION_STRING\fP
\fB\-c\fP 调用选项的命令参数。
.TP 
\fBBASH_LINENO\fP
一个数组变量，其成员是源文件中调用
.SM
\fBFUNCNAME\fP 的每个对应成员的行号。 \fB${BASH_LINENO[\fP\fI$i\fP\fB]}\fP
是源文件 (\fB${BASH_SOURCE[\fP\fI$i+1\fP\fB]}\fP) 中调用 \fB${FUNCNAME[\fP\fI$i\fP\fB]}\fP 的行号
(如果在另一个 shell 函数中引用，则为 \fB${BASH_LINENO[\fP\fI$i\-1\fP\fB]}\fP)。 使用
.SM
\fBLINENO\fP
获取当前行号。
.TP 
\fBBASH_LOADABLES_PATH\fP
以冒号分隔的目录列表，shell 在其中查找由 \fBenable\fP 命令指定的可动态加载的内置函数。
.TP 
\fBBASH_REMATCH\fP
一个数组变量，其成员由 \fB=~\fP 二元运算符分配给 \fB[[\fP 条件命令。 索引为 0 的元素是匹配整个正则表达式的字符串部分。 索引为 \fIn\fP
的元素是匹配 \fIn\fPth 括号子表达式的字符串部分。
.TP 
\fBBASH_SOURCE\fP
一个数组变量，其成员是源文件名，其中定义了
.SM
\fBFUNCNAME\fP 数组变量中相应的 shell 函数名称。 shell 函数
\fB${FUNCNAME[\fP\fI$i\fP\fB]}\fP 在文件 \fB${BASH_SOURCE[\fP\fI$i\fP\fB]}\fP 中定义并从
\fB${BASH_SOURCE[\fP\fI$i+1\fP\fB]}\fP 调用。
.TP 
\fBBASH_SUBSHELL\fP
当 shell 开始在该环境中执行时，在每个子 shell 或子 shell 环境中递增 1。 初始值为 0。 如果 \fBBASH_SUBSHELL\fP
未设置，它将失去其特殊属性，即使它随后被重置。
.TP 
\fBBASH_VERSINFO\fP
一个只读数组变量，其成员保存此 \fBbash\fP 实例的版本信息。 分配给数组成员的值如下:
.sp .5
.RS
.TP  24
\fBBASH_VERSINFO[\fP0\fB]\fP
主版本号 (\fIrelease\fP).
.TP 
\fBBASH_VERSINFO[\fP1\fB]\fP
次要版本号 (\fIversion\fP).
.TP 
\fBBASH_VERSINFO[\fP2\fB]\fP
补丁级别。
.TP 
\fBBASH_VERSINFO[\fP3\fB]\fP
构建版本。
.TP 
\fBBASH_VERSINFO[\fP4\fB]\fP
发布状态 (例如，\fIbeta1\fP).
.TP 
\fBBASH_VERSINFO[\fP5\fB]\fP
.SM
\fBMACHTYPE\fP 的值。
.RE
.TP 
\fBBASH_VERSION\fP
扩展为描述此 \fBbash\fP 实例版本的字符串。
.TP 
\fBCOMP_CWORD\fP
包含当前游标位置的单词的 \fB${COMP_WORDS}\fP 索引。 此变量仅在由可编程完成工具调用的 shell 函数中可用 (参见下面的
\fBProgrammable Completion\fP)。
.TP 
\fBCOMP_KEY\fP
用于调用当前完成函数的键 (或键序列的最终键)。
.TP 
\fBCOMP_LINE\fP
当前命令行。 此变量仅在 shell 函数和由可编程完成工具调用的外部命令中可用 (参见下面的 \fBProgrammable Completion\fP)。
.TP 
\fBCOMP_POINT\fP
当前游标位置相对于当前命令开头的索引。 如果当前游标位置在当前命令的末尾，则该变量的值等于 \fB${#COMP_LINE}\fP。 此变量仅在 shell
函数和由可编程完成工具调用的外部命令中可用 (参见下面的 \fBProgrammable Completion\fP)。
.TP 
\fBCOMP_TYPE\fP
设置为对应于导致调用完成函数的完成类型尝试的整数值:
\fITAB\fP，用于正常完成，\fI?\fP，用于在连续选项卡后列出完成，\fI!\fP，用于列出部分单词完成的备选方案，\fI@\fP，列出 completions
如果单词不是未修改的，或者 \fI%\fP，用于菜单完成。 此变量仅在 shell 函数和由可编程完成工具调用的外部命令中可用 (参见下面的
\fBProgrammable Completion\fP)。
.TP 
\fBCOMP_WORDBREAKS\fP
\fBreadline\fP 库在执行单词完成时将其视为单词分隔符的字符集。 如果
.SM
\fBCOMP_WORDBREAKS\fP
未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBCOMP_WORDS\fP
一个数组变量 (参见下面的 \fBArrays\fP)，由当前命令行中的各个单词组成。 该行被拆分成单词，就像 \fBreadline\fP 将其拆分一样，使用
.SM
\fBCOMP_WORDBREAKS\fP 如上所述。 此变量仅在由可编程完成工具调用的 shell 函数中可用 (参见下面的
\fBProgrammable Completion\fP)。
.TP 
\fBCOPROC\fP
创建一个数组变量 (参见下面的 \fBArrays\fP) 以保存文件描述符，用于从未命名的协进程 (参见上面的 \fBCoprocesses\fP) 输出和输入。
.TP 
\fBDIRSTACK\fP
包含目录栈当前内容的数组变量 (参见下面的 \fBArrays\fP)。 目录按照 \fBdirs\fP 内置函数显示的顺序出现在栈中。
分配给此数组变量的成员可用于修改栈中已有的目录，但必须使用 \fBpushd\fP 和 \fBpopd\fP 内置函数来添加和删除目录。
分配给这个变量不会改变当前目录。 如果
.SM
\fBDIRSTACK\fP 未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBEPOCHREALTIME\fP
每次引用此参数时，它都会扩展为自 Unix 纪元以来的秒数 (将 \fItime\fP(3)) 视为具有微秒粒度的浮点值。 忽略对
.SM
\fBEPOCHREALTIME\fP 的分配。 如果
.SM
\fBEPOCHREALTIME\fP 未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBEPOCHSECONDS\fP
每次引用此参数时，它都会扩展为自 Unix 纪元以来的秒数 (请参见 \fItime\fP(3)).  忽略对
.SM
\fBEPOCHSECONDS\fP
的分配。 如果
.SM
\fBEPOCHSECONDS\fP 未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBEUID\fP
扩展为当前用户的有效用户 ID，在 shell 启动时初始化。 这个变量是只读的。
.TP 
\fBFUNCNAME\fP
一个数组变量，包含当前在执行调用栈中的所有 shell 函数的名称。 索引为 0 的元素是任何当前正在执行的 shell 函数的名称。 最底部的元素
(索引最高的元素) 是
.if  t \f(CW"main"\fP.
.if  n "main".
此变量仅在执行 shell 函数时存在。 分配给
.SM
\fBFUNCNAME\fP 无效。 如果
.SM
\fBFUNCNAME\fP
未设置，它将失去其特殊属性，即使随后被重置。
.if  t .sp 0.5
.if  n .sp 1
该变量可与 \fBBASH_LINENO\fP 和 \fBBASH_SOURCE\fP 一起使用。 \fBFUNCNAME\fP 的每个元素在
\fBBASH_LINENO\fP 和 \fBBASH_SOURCE\fP 中都有对应的元素来描述调用栈。 例如，\fB${FUNCNAME[\fP\fI$i\fP\fB]}\fP
是从行号为 \fB${BASH_LINENO[\fP\fI$i\fP\fB]}\fP 的文件 \fB${BASH_SOURCE[\fP\fI$i+1\fP\fB]}\fP 中调用的。
\fBcaller\fP 内置函数使用此信息显示当前调用栈。
.TP 
\fBGROUPS\fP
包含当前用户所属组列表的数组变量。 分配给
.SM
\fBGROUPS\fP 无效。 如果
.SM
\fBGROUPS\fP
未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBHISTCMD\fP
当前命令的历史编号或历史列表中的索引。 忽略对
.SM
\fBHISTCMD\fP 的分配。 如果
.SM
\fBHISTCMD\fP
未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBHOSTNAME\fP
自动设置为当前主机的名称。
.TP 
\fBHOSTTYPE\fP
自动设置为唯一描述执行 \fBbash\fP 的机器类型的字符串。 默认值取决于系统。
.TP 
\fBLINENO\fP
每次引用此参数时，shell 都会替换一个十进制数，表示脚本中的当前顺序行号 (从 1 开始) 或函数。 当不在脚本或函数中时，替换的值不保证有意义。
如果
.SM
\fBLINENO\fP 未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBMACHTYPE\fP
自动设置为以标准 GNU \fIcpu\-company\-system\fP 格式完整描述 \fBbash\fP 在其上执行的系统类型的字符串。 默认值取决于系统。
.TP 
\fBMAPFILE\fP
一个数组变量 (参见下面的 \fBArrays\fP) 创建用于保存 \fBmapfile\fP 内置函数在未提供变量名称时读取的文本。
.TP 
\fBOLDPWD\fP
\fBcd\fP 命令设置的先前工作目录。
.TP 
\fBOPTARG\fP
\fBgetopts\fP 内置命令处理的最后一个选项参数的值 (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.TP 
\fBOPTIND\fP
\fBgetopts\fP 内置命令要处理的下一个参数的索引 (见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.TP 
\fBOSTYPE\fP
自动设置为描述执行 \fBbash\fP 的操作系统的字符串。 默认值取决于系统。
.TP 
\fBPIPESTATUS\fP
一个数组变量 (参见下面的 \fBArrays\fP)，其中包含来自最近执行的前台管道 (可能仅包含一个命令) 中的进程的退出状态值列表。
.TP 
\fBPPID\fP
shell 的父进程 ID。 这个变量是只读的。
.TP 
\fBPWD\fP
\fBcd\fP 命令设置的当前工作目录。
.TP 
\fBRANDOM\fP
每次引用此参数时，它都会扩展为 0 到 32767 之间的随机整数。 给
.SM
\fBRANDOM\fP 赋值初始化 (seeds) 随机数序列。
如果
.SM
\fBRANDOM\fP 未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBREADLINE_LINE\fP
\fBreadline\fP 行缓冲区的内容，用于
.if  t \f(CWbind -x\fP
.if  n "bind -x"
(参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.TP 
\fBREADLINE_MARK\fP
标记 (保存的插入点) 在 \fBreadline\fP 行缓冲区中的位置，用于
.if  t \f(CWbind -x\fP
.if  n "bind -x"
(参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。 插入点和标记之间的字符通常称为 \fIregion\fP。
.TP 
\fBREADLINE_POINT\fP
插入点在 \fBreadline\fP 行缓冲区中的位置，用于
.if  t \f(CWbind -x\fP
.if  n "bind -x"
(参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.TP 
\fBREPLY\fP
当没有提供参数时，设置为 \fBread\fP 内置命令读取的输入行。
.TP 
\fBSECONDS\fP
每次引用此参数时，都会返回自 shell 调用以来的秒数。 如果一个值被分配给
.SM
\fBSECONDS\fP，则在随后的引用中返回的值是自分配后的秒数加上分配的值。 shell 调用的秒数和当前时间始终通过查询系统时钟来确定。 如果
.SM
\fBSECONDS\fP 未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBSHELLOPTS\fP
已启用的 shell 选项的冒号分隔列表。 列表中的每个单词都是 \fBset\fP 内置命令的 \fB\-o\fP 选项的有效参数 (请参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.SM
\fBSHELLOPTS\fP 中出现的选项是由 \fBset \-o\fP 报告为 \fIon\fP
的选项。 如果此变量在 \fBbash\fP 启动时的环境中，则列表中的每个 shell 选项都将在读取任何启动文件之前启用。 该变量是只读的。
.TP 
\fBSHLVL\fP
每次启动 \fBbash\fP 实例时递增 1。
.TP 
\fBSRANDOM\fP
每次引用此变量时，它都会扩展为一个 32 位伪随机数。随机数生成器在支持 \f(CW/dev/urandom\fP 或 \fIarc4random\fP
的系统上不是线性的，因此每个返回的数字与其前面的数字没有关系。 无法为随机数生成器设定种子，因此对该变量的赋值无效。 如果
.SM
\fBSRANDOM\fP 未设置，它将失去其特殊属性，即使随后被重置。
.TP 
\fBUID\fP
扩展为当前用户的用户 ID，在 shell 启动时初始化。 这个变量是只读的。
.PD
.PP
shell 使用以下变量。 在某些情况下，\fBbash\fP 会为变量分配一个默认值; 这些案例如下。
.PP
.PD 0
.TP 
\fBBASH_COMPAT\fP
该值用于设置 shell 的兼容级别。 有关各种兼容性级别及其影响的说明，请参见下面的
.SM
\fBSHELL COMPATIBILITY MODE\fP。 该值可以是对应于所需兼容性级别的十进制数 (例如，4.2) 或整数 (例如，42)。 如果 \fBBASH_COMPAT\fP
未设置或设置为空字符串，则兼容级别设置为当前版本的默认值。 如果 \fBBASH_COMPAT\fP 设置为不是有效兼容级别之一的值，则 shell
会打印一条错误消息并将兼容级别设置为当前版本的默认值。 有效值对应于下面
.SM
\fBBSHELL\fPCOMPATIBILITY\fBMODE\fP
下描述的兼容性级别。 例如，4.2 和 42 是对应 \fBcompat42\fP \fBshopt\fP 选项并将兼容级别设置为 42 的有效值。
当前版本也是一个有效值。
.TP 
\fBBASH_ENV\fP
如果在 \fBbash\fP 执行 shell 脚本时设置此参数，则其值将被解释为包含初始化 shell 的命令的文件名，如 \fI~/.bashrc\fP
中一样。
.SM
\fBBASH_ENV\fP 的值在被解释为文件名之前进行参数扩展、命令替换和算术扩展。
.SM
\fBPATH\fP
不用于搜索结果文件名。
.TP 
\fBBASH_XTRACEFD\fP
如果设置为对应于有效文件描述符的整数，\fBbash\fP 将写入时生成的跟踪输出
.if  t \f(CWset -x\fP
.if  n \fIset -x\fP
已启用该文件描述符。 当
.SM
\fBBASH_XTRACEFD\fP 未设置或分配新值时，文件描述符关闭。 取消设置
.SM
\fBBASH_XTRACEFD\fP 或为其分配空字符串会导致将跟踪输出发送到标准错误。 请注意，将
.SM
\fBBASH_XTRACEFD\fP 设置为
2 (标准错误文件描述符) 然后取消设置将导致标准错误被关闭。
.TP 
\fBCDPATH\fP
\fBcd\fP 命令的搜索路径。 这是一个以冒号分隔的目录列表，shell 在其中查找由 \fBcd\fP 命令指定的目标目录。 样本值为
.if  t \f(CW".:~:/usr"\fP.
.if  n ".:~:/usr".
.TP 
\fBCHILD_MAX\fP
设置要记住的 shell 退出子状态值的数量。 Bash 不允许将此值降低到低于 POSIX 规定的最小值，并且有一个最大值 (当前为 8192)
不能超过。 最小值取决于系统。
.TP 
\fBCOLUMNS\fP
由 \fBselect\fP 复合命令使用以确定打印选择列表时的终端宽度。 如果启用 \fBcheckwinsize\fP 选项或在收到
.SM
\fBSIGWINCH\fP 后在交互式 shell 中自动设置。
.TP 
\fBCOMPREPLY\fP
一个数组变量，\fBbash\fP 从中读取由可编程完成工具调用的 shell 函数生成的可能完成 (参见下面的 \fBProgrammable Completion\fP)。 每个数组元素包含一个可能的完成。
.TP 
\fBEMACS\fP
如果 \fBbash\fP 在 shell 以 value 开头的时候在环境中找到这个变量
.if  t \f(CWt\fP,
.if  n "t",
它假定 shell 在 Emacs shell 缓冲区中运行并禁用行编辑。
.TP 
\fBENV\fP
当在 \fIposix mode\fP 中调用交互式 shell 时，扩展和执行类似于
.SM
\fBBASH_ENV\fP (参见上面的
\fBINVOCATION\fP)。
.TP 
\fBEXECIGNORE\fP
以冒号分隔的 shell 模式列表 (请参见 \fBPattern Matching\fP) 定义使用 \fBPATH\fP 的命令搜索将忽略的文件名列表。
出于通过 \fBPATH\fP 查找完成和执行命令的目的，完整路径名与这些模式之一匹配的文件不被视为可执行文件。 这不会影响 \fB[\fP、\fBtest\fP 和
\fB[[\fP 命令的行为。 命令哈希表中的完整路径名不受 \fBEXECIGNORE\fP 的约束。 使用此变量忽略已设置可执行位但不是可执行文件的共享库文件。
模式匹配遵循 \fBextglob\fP shell 选项的设置。
.TP 
\fBFCEDIT\fP
\fBfc\fP 内置命令的默认编辑器。
.TP 
\fBFIGNORE\fP
执行文件名完成时要忽略的以冒号分隔的后缀列表 (请参见下面的
.SM
\fBREADLINE\fP)。 后缀与
.SM
\fBFIGNORE\fP
中的条目之一匹配的文件名被排除在匹配文件名列表之外。 样本值为
.if  t \f(CW".o:~"\fP.
.if  n ".o:~".
.TP 
\fBFUNCNEST\fP
如果设置为大于 0 的数值，则定义最大嵌套层数。 超出此嵌套级别的任意调用将导致当前命令终止。
.TP 
\fBGLOBIGNORE\fP
以冒号分隔的模式列表，定义路径名扩展要忽略的文件名集。 如果与路径名扩展模式匹配的文件名也与
.SM
\fBGLOBIGNORE\fP
中的模式之一匹配，则将其从匹配列表中删除。
.TP 
\fBHISTCONTROL\fP
以冒号分隔的值列表，控制命令如何保存在历史列表中。 如果值列表包含 \fIignorespace\fP，则以 \fBspace\fP
字符开头的行不会保存在历史列表中。 \fIignoredups\fP 的值导致不保存与先前历史条目匹配的行。 \fIignoreboth\fP 的值是
\fIignorespace\fP 和 \fIignoredups\fP 的简写。 \fIerasedups\fP
的值会导致与当前行匹配的所有先前行在保存该行之前从历史列表中删除。 不在上述列表中的任何值都将被忽略。 如果
.SM
\fBHISTCONTROL\fP
未设置，或不包含有效值，则 shell 解析器读取的所有行都将保存在历史列表中，以
.SM
\fBHISTIGNORE\fP 的值为准。
多行复合命令的第二行和后续行不进行测试，并且无论
.SM
\fBHISTCONTROL\fP 的值如何都添加到历史记录中。
.TP 
\fBHISTFILE\fP
保存命令历史记录的文件的名称 (参见下面的
.SM
\fBHISTORY\fP)。 默认值为 \fI~/.bash_history\fP。 如果未设置，则在
shell 退出时不会保存命令历史记录。
.TP 
\fBHISTFILESIZE\fP
历史文件中包含的最大行数。 当此变量被赋值时，历史文件将被截断，如有必要，通过删除最旧的条目来包含不超过该数量的行。 当 shell
退出时，历史文件在写入后也会被截断到这个大小。 如果值为 0，历史文件将被截断为零大小。 非数值和小于零的数值禁止截断。 shell
在读取任何启动文件后将默认值设置为 \fBHISTSIZE\fP 的值。
.TP 
\fBHISTIGNORE\fP
以冒号分隔的模式列表，用于决定哪些命令行应保存在历史列表中。 每个模式都锚定在行的开头，并且必须匹配完整的行 (没有，追加，隐含的 `\fB*\fP')。
在应用
.SM
\fBHISTCONTROL\fP 指定的检查后，每个模式都会针对该行进行测试。 除了正常的 shell 模式匹配字符外，`\fB&\fP'
匹配前面的历史行。`\fB&\fP' 可以使用反斜杠进行转义; 在尝试匹配之前删除反斜杠。 多行复合命令的第二行和后续行不进行测试，并且无论
.SM
\fBHISTIGNORE\fP 的值如何都添加到历史记录中。 模式匹配遵循 \fBextglob\fP shell 选项的设置。
.TP 
\fBHISTSIZE\fP
命令历史记录中要记住的命令数 (参见下面的
.SM
\fBHISTORY\fP)。 如果值为 0，则命令不会保存在历史列表中。
小于零的数值会导致每个命令都保存在历史列表中 (没有限制)。 shell 在读取任何启动文件后将默认值设置为 500。
.TP 
\fBHISTTIMEFORMAT\fP
如果此变量已设置且不为空，则其值将用作 \fIstrftime\fP(3) 的格式字符串，以打印与 \fBhistory\fP
内置函数显示的每个历史条目关联的时间戳。 如果设置了此变量，时间戳将写入历史文件，因此它们可以在 shell 会话中保留。
这使用历史注释字符将时间戳与其他历史行区分开来。
.TP 
\fBHOME\fP
当前用户的主目录; \fBcd\fP 内置命令的默认参数。 执行波浪号扩展时也会使用此变量的值。
.TP 
\fBHOSTFILE\fP
包含格式相同的文件名
.FN /etc/hosts
当 shell 需要完成主机名时应该读取它。 shell 运行时，可能的主机名补全列表可能会更改; 值更改后下次尝试主机名补全时，\fBbash\fP
会将新文件的内容添加到现有列表中。 如果
.SM
\fBHOSTFILE\fP 已设置，但没有值，或未命名可读文件，则 \fBbash\fP 尝试读取
.FN /etc/hosts
获取可能的主机名完成列表。 当
.SM
\fBHOSTFILE\fP 未设置时，主机名列表被清除。
.TP 
\fBIFS\fP
\fIInternal Field Separator\fP 用于扩展后的分词，并使用 \fBread\fP 内置命令将行分词。 默认值为
\*(lq<space><tab><newline>\*(rq。
.TP 
\fBIGNOREEOF\fP
控制交互式 shell 在收到
.SM
\fBEOF\fP 字符作为唯一输入时的操作。 如果设置，该值是连续的
.SM
\fBEOF\fP 字符数，在
\fBbash\fP 退出之前必须将其作为输入行上的第一个字符键入。 如果变量存在但没有数值，或没有值，则默认值为 10。 如果不存在，则
.SM
\fBEOF\fP 表示对 shell 的输入结束。
.TP 
\fBINPUTRC\fP
\fBreadline\fP 启动文件的文件名，覆盖默认值
.FN ~/.inputrc
(参见下面的
.SM
\fBREADLINE\fP)。
.TP 
\fBINSIDE_EMACS\fP
如果 shell 启动时该变量出现在环境中，则 \fBbash\fP 假定它在 Emacs shell 缓冲区内运行，并且可能会禁用行编辑，具体取决于
\fBTERM\fP 的值。
.TP 
\fBLANG\fP
用于确定未使用以 \fBLC_\fP 开头的变量专门选择的任何类别的语言环境类别。
.TP 
\fBLC_ALL\fP
此变量覆盖
.SM
\fBLANG\fP 的值和任何其他指定语言环境类别的 \fBLC_\fP 变量。
.TP 
\fBLC_COLLATE\fP
此变量确定对路径名扩展结果进行排序时使用的归类顺序，并确定范围表达式、等价类和路径名扩展和模式匹配中的归类序列的行为。
.TP 
\fBLC_CTYPE\fP
此变量确定字符的解释以及路径名扩展和模式匹配中字符类的行为。
.TP 
\fBLC_MESSAGES\fP
此变量确定用于翻译前面带有 \fB$\fP 的双引号字符串的语言环境。
.TP 
\fBLC_NUMERIC\fP
此变量确定用于数字格式化的语言环境类别。
.TP 
\fBLC_TIME\fP
此变量确定用于数据和时间格式化的语言环境类别。
.TP 
\fBLINES\fP
由 \fBselect\fP 复合命令使用以确定打印选择列表的列长度。 如果启用 \fBcheckwinsize\fP 选项或在收到
.SM
\fBSIGWINCH\fP 后在交互式 shell 中自动设置。
.TP 
\fBMAIL\fP
如果此参数设置为文件名或目录名且未设置
.SM
\fBMAILPATH\fP 变量，则 \fBbash\fP 通知用户邮件已到达指定文件或 Maildir
格式的目录。
.TP 
\fBMAILCHECK\fP
指定 \fBbash\fP 检查邮件的频率 (以秒为单位)。 默认值为 60 秒。 当需要检查邮件时，shell 会在显示主要提示之前检查邮件。
如果此变量未设置，或设置为不是大于或等于零的数字的值，则 shell 禁用邮件检查。
.TP 
\fBMAILPATH\fP
要检查邮件的以冒号分隔的文件名列表。 当邮件到达特定文件时要打印的消息可以通过用 `?` 将文件名与消息分开来指定。当在消息文本中使用时，\fB$_\fP
扩展为当前邮件文件的名称。 Example:
.RS
.PP
\fBMAILPATH\fP=\(aq/var/mail/bfox?"You have mail":~/shell\-mail?"$_ has
mail!"\(aq
.PP
\fBBash\fP 可以配置为为此变量提供默认值 (默认情况下没有值)，但它使用的用户邮件文件的位置是系统相关的
(例如，/var/mail/\fB$USER\fP).
.RE
.TP 
\fBOPTERR\fP
如果设置为值 1，\fBbash\fP 将显示由 \fBgetopts\fP 内置命令生成的错误消息 (请参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。 每次调用 shell 或执行 shell 脚本时，
.SM
\fBOPTERR\fP 都会初始化为 1。
.TP 
\fBPATH\fP
命令的搜索路径。 它是一个以冒号分隔的目录列表，shell 在其中查找命令 (参见下面的
.SM
\fBCOMMAND EXECUTION\fP)。
.SM
\fBPATH\fP 值中的零长度 (null) 目录名称表示当前目录。 空目录名称可能显示为两个相邻的冒号，或者显示为一个开头或结尾的冒号。
默认路径取决于系统，由安装 \fBbash\fP 的管理员设置。 一个共同的值观是
.na
.if  t \f(CW/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin\fP.
.if  n ``/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin''.
.ad
.TP 
\fBPOSIXLY_CORRECT\fP
如果此变量在 \fBbash\fP 启动时的环境中，则 shell 在读取启动文件之前进入 \fIposix mode\fP，就好像已提供 \fB\-\-posix\fP
调用选项一样。 如果在 shell 运行时设置，\fBbash\fP 启用 \fIposix mode\fP，就像命令一样
.if  t \f(CWset -o posix\fP
.if  n \fIset -o posix\fP
已被处决。 当 shell 输入 \fIposix mode\fP 时，如果尚未设置此变量，它会设置它。
.TP 
\fBPROMPT_COMMAND\fP
如果此变量已设置，并且是一个数组，则每个设置元素的值在发出每个主要提示之前作为命令执行。 如果已设置但不是数组变量，则其值将用作要执行的命令。
.TP 
\fBPROMPT_DIRTRIM\fP
如果设置为大于零的数字，则该值用作扩展 \fB\ew\fP 和 \fB\eW\fP 提示字符串转义时要保留的尾随目录组件的数量 (请参见下面的
.SM
\fBPROMPTING\fP)。 删除的字符将替换为省略号。
.TP 
\fBPS0\fP
此参数的值在读取命令后和执行命令之前由交互式 shells 展开 (参见下面的
.SM
\fBPROMPTING\fP) 并显示。
.TP 
\fBPS1\fP
此参数的值被扩展 (请参见下面的
.SM
\fBPROMPTING\fP) 并用作主要提示字符串。 默认值为 \*(lq\fB\es\-\ev\e$ \fP\*(rq。
.TP 
\fBPS2\fP
此参数的值与
.SM
\fBPS1\fP 一样扩展并用作辅助提示字符串。 默认为 \*(lq\fB> \fP\*(rq。
.TP 
\fBPS3\fP
该参数的值用作 \fBselect\fP 命令的提示符 (参见上面的
.SM
\fBSHELL GRAMMAR\fP)。
.TP 
\fBPS4\fP
此参数的值与
.SM
\fBPS1\fP 一样扩展，并且在执行跟踪期间显示的每个命令 \fBbash\fP 之前打印该值。
.SM
\fBPS4\fP
的扩展值的第一个字符根据需要被复制多次，以指示多个间接级别。 默认为 \*(lq\fB+ \fP\*(rq。
.TP 
\fBSHELL\fP
此变量扩展为 shell 的完整路径名。 如果在 shell 启动时没有设置，\fBbash\fP 会为其分配当前用户登录 shell 的完整路径名。
.TP 
\fBTIMEFORMAT\fP
此参数的值用作格式字符串，指定应如何显示前缀为 \fBtime\fP 保留字的管道的计时信息。 \fB%\fP 字符引入了一个扩展为时间值或其他信息的转义序列。
转义序列及其含义如下; 大括号表示可选部分。
.sp .5
.RS
.PD 0
.TP  10
\fB%%\fP
字面量 \fB%\fP。
.TP 
\fB%[\fP\fIp\fP\fB][l]R\fP
经过的时间 (以秒为单位)。
.TP 
\fB%[\fP\fIp\fP\fB][l]U\fP
在用户模式下花费的 CPU 秒数。
.TP 
\fB%[\fP\fIp\fP\fB][l]S\fP
在系统模式下花费的 CPU 秒数。
.TP 
\fB%P\fP
CPU 百分比，计算方式为 (%U + %S)/%R。
.PD
.RE
.IP
可选的 \fIp\fP 是指定 \fIprecision\fP 的数字，小数点后的小数位数。 值 0 导致不输出小数点或分数。 最多可以指定小数点后三位; 大于 3
的 \fIp\fP 值更改为 3。 如果未指定 \fIp\fP，则使用值 3。
.IP
可选的 \fBl\fP 指定更长的格式，包括分钟，格式为 \fIMM\fPm\fISS\fP.\fIFF\fPs。\fIp\fP 的值决定是否包含分数。
.IP
如果未设置此变量，则 \fBbash\fP 的行为就好像它具有值
\fB$\(aq\enreal\et%3lR\enuser\et%3lU\ensys\et%3lS\(aq\fP。 如果该值为空，则不显示计时信息。
显示格式字符串时会添加尾随换行符。
.PD 0
.TP 
\fBTMOUT\fP
如果设置为大于零的值，
.SM
\fBTMOUT\fP 将被视为 \fBread\fP 内置的默认超时。 当输入来自终点时，如果在
.SM
\fBTMOUT\fP 秒后输入没有到达，则 \fBselect\fP 命令终止。 在交互式 shell 中，该值被解释为发出主要提示后等待一行输入的秒数。
如果完整的输入行未到达，则 \fBBash\fP 在等待该秒数后终止。
.TP 
\fBTMPDIR\fP
如果设置，\fBbash\fP 将其值用作目录名称，\fBbash\fP 在该目录中创建临时文件供 shell 使用。
.TP 
\fBauto_resume\fP
此变量控制 shell 如何与用户和作业控制交互。 如果设置了此变量，则没有重定向的单个单词简单命令将被视为恢复现有已停止作业的候选者。 不允许有歧义;
如果有多个作业以键入的字符串开头，则选择最近访问的作业。 在此上下文中，已停止作业的 \fIname\fP 是用于启动它的命令行。 如果设置为值
\fIexact\fP，则提供的字符串必须与已停止作业的名称完全匹配; 如果设置为 \fIsubstring\fP，则提供的字符串需要匹配已停止作业名称的子字符串。
\fIsubstring\fP 值提供类似于 \fB%?\fP 作业标识符的功能 (请参见下面的
.SM
\fBJOB CONTROL\fP)。
如果设置为任何其他值，提供的字符串必须是已停止作业名称的前缀; 这提供了类似于 \fB%\fP\fIstring\fP 作业标识符的功能。
.TP 
\fBhistchars\fP
控制历史扩展和标记化的两个或三个字符 (参见下面的
.SM
\fBHISTORY EXPANSION\fP)。 第一个字符是 \fIhistory expansion\fP 字符，表示历史扩展开始的字符，通常为 `\fB!\fP'。第二个字符是 \fIquick substitution\fP
字符，用作重新运行先前输入的命令的简写，在命令中用一个字符串替换另一个字符串。默认为 `\fB^\fP'。
可选的第三个字符是表示当发现该行的其余部分是单词的第一个字符时是注释的字符，通常为 `\fB#\fP'。历史注释字符导致跳过行中剩余单词的历史替换。
它不一定会导致 shell 解析器将该行的其余部分视为注释。
.PD
.SS Arrays
\fBBash\fP 提供一维索引关联数组变量。 任何变量都可以用作索引数组; \fBdeclare\fP 内置函数将显式声明一个数组。
数组的大小没有最大限制，也没有对成员连续索引或分配的要求。 索引数组使用整数 (包括算术表达式) 引用并且从零开始; 使用任意字符串引用关联数组。
除非另有说明，索引数组索引必须是非 negative 整数。
.PP
如果使用语法 \fIname\fP[\fIsubscript\fP]=\fIvalue\fP 将任何变量分配给，则会自动创建一个索引数组。 \fIsubscript\fP
被视为必须求值为数字的算术表达式。 要显式声明索引数组，请使用 \fBdeclare \-a \fP\fIname\fP (请参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。 \fBdeclare \-a \fP\fIname\fP\fB[\fP\fIsubscript\fP\fB]\fP 也被接受;
\fIsubscript\fP 被忽略。
.PP
关联数组是使用 \fBdeclare \-A \fP\fIname\fP 创建的。
.PP
可以使用 \fBdeclare\fP 和 \fBreadonly\fP 内置函数为数组变量指定属性。 每个属性适用于数组的所有成员。
.PP
数组被分配给使用 \fIname\fP=\fB(\fPvalue\fI1\fP 形式的复合赋值... value\fIn\fP\fB)\fP，其中每个 \fIvalue\fP 的形式可能是
[\fIsubscript\fP]=\fIstring\fP。 索引数组赋值只需要 \fIstring\fP。 列表中的每个 \fIvalue\fP 都使用下面
.SM
\fBEXPANSION\fP 下描述的所有 shell 扩展进行扩展。 分配给索引数组时，如果提供了可选的括号和下标，则该索引将分配给;
否则，分配的元素的索引是语句分配的最后一个索引加一。 索引从零开始。
.PP
分配给关联数组时，复合分配中的单词可以是分配语句，需要下标，或者是解释为交替键和值序列的单词列表: \fIname\fP=\fB( \fP\fIkey1 value1 key2 value2\fP ...\fB)\fP。 它们的处理方式与 \fIname\fP=\fB(\fP [\fIkey1\fP]=\fIvalue1\fP
[\fIkey2\fP]=\fIvalue2\fP ...\fB)\fP 相同。 列表中的第一个词决定了其余词的解释方式; 列表中的所有分配必须属于同一类型。 使用
key/value 对时，key 不得缺失或为空; 最终缺失值被视为空字符串。
.PP
\fBdeclare\fP 内置函数也接受此语法。 可以使用上面介绍的 \fIname\fP[\fIsubscript\fP]=\fIvalue\fP 语法分配单个数组元素。
分配给索引数组时，如果 \fIname\fP 下标为 negative 数字，则该数字被解释为相对于比 \fIname\fP 的最大索引大 1 的值，因此
negative 索引从数组的末尾开始倒数，并且 \-1 的索引引用最后一个元素。
.PP
可以使用 ${\fIname\fP[\fIsubscript\fP]} 引用数组的任何元素。 需要大括号以避免与路径名扩展冲突。 如果 \fIsubscript\fP 是
\fB@\fP 或 \fB*\fP，则该词扩展到 \fIname\fP 的所有成员。 只有当单词出现在双引号内时，这些下标才会不同。 如果单词被双引号括起来，则
${\fIname\fP[*]} 扩展为单个单词，每个数组成员的值由
.SM
\fBIFS\fP 特殊变量的第一个字符分隔，而 ${\fIname\fP[@]} 将
\fIname\fP 的每个元素扩展为单独的单词。 当没有数组成员时，${\fIname\fP[@]} 展开为空。
如果双引号扩展出现在一个单词中，则第一个参数的扩展与原始单词的开头部分连接，最后一个参数的扩展与原始单词的最后部分连接。 这类似于特殊参数 \fB*\fP 和
\fB@\fP 的扩展 (参见上面的 \fBSpecial Parameters\fP)。 ${#\fIname\fP[\fIsubscript\fP]} 扩展到
${\fIname\fP[\fIsubscript\fP]} 的长度。 如果 \fIsubscript\fP 为 \fB*\fP 或 \fB@\fP，则扩展为数组中的元素数。
如果用于引用索引数组元素的 \fIsubscript\fP 的计算结果为小于零的数字，则它被解释为相对于大于数组最大索引的一个，因此 negative
索引从数组的末尾开始倒数，并且 \-1 引用最后一个元素的索引。
.PP
引用不带下标的数组变量等同于引用带下标 0 的数组。 使用有效下标对变量的任何引用都是合法的，并且 \fBbash\fP 将在必要时创建一个数组。
.PP
如果已为下标分配了值，则认为数组变量已设置。 空字符串是有效值。
.PP
可以获得数组的键 (indices) 以及值。 ${\fB!\fP\fIname\fP[\fI@\fP]} 和 ${\fB!\fP\fIname\fP[\fI*\fP]} 扩展为数组变量
\fIname\fP 中分配的索引。 双引号中的处理类似于特殊参数 \fI@\fP 和 \fI*\fP 在双引号中的扩展。
.PP
\fBunset\fP 内置函数用于销售数组。 \fBunset\fP \fIname\fP[\fIsubscript\fP] 销售索引 \fIsubscript\fP
处的数组元素，用于索引数组和关联数组。 索引数组的 Negative 下标按上述解释。 取消设置数组变量的最后一个元素不会取消设置变量。
\fBunset\fP \fIname\fP，其中 \fIname\fP 是一个数组，或 \fBunset\fP \fIname\fP[\fIsubscript\fP]，其中
\fIsubscript\fP 是 \fB*\fP 或 \fB@\fP，删除整个数组。
.PP
当使用带有下标的变量名作为命令的参数时，例如使用 \fBunset\fP，而不使用上述单词扩展语法，参数会受到路径名扩展的影响。
如果不需要扩展路径名，则应引用引用数。
.PP
\fBdeclare\fP、\fBlocal\fP 和 \fBreadonly\fP 内置函数都接受一个 \fB\-a\fP 选项来指定一个索引数组和一个 \fB\-A\fP
选项来指定一个关联数组。 如果提供了两个选项，则 \fB\-A\fP 优先。 \fBread\fP 内置函数接受 \fB\-a\fP
选项，将从标准输入读取的单词列表分配给数组。 \fBset\fP 和 \fBdeclare\fP 内置函数以允许它们作为赋值重用的方式显示数组值。
.SH EXPANSION
拆分成单词后在命令行上进行扩展。 执行的扩展有七种: \fIbrace expansion\fP、\fItilde expansion\fP、\fIparameter and variable expansion\fP、\fIcommand substitution\fP、\fIarithmetic expansion\fP、\fIword splitting\fP 和 \fIpathname expansion\fP。
.PP
展开的顺序是: 大括号展开; 波浪号扩展、参数和变量扩展、算术扩展和命令替换 (以从左到右的方式完成) ; 分词; 和路径名扩展。
.PP
在可以支持它的系统上，有一个额外的扩展可用: \fIprocess substitution\fP。 这与波浪号、参数、变量、算术扩展和命令替换同时执行。
.PP
执行这些扩展后，原始单词中出现的引号字符将被删除，除非它们本身被引号为 (\fIquote removal\fP)。
.PP
只有大括号展开、分词、路径名展开才能增加展开的词数; 其他扩展将单个单词扩展为单个单词。 唯一的例外是 "\fB$@\fP" 和
"\fB${\fP\fIname\fP\fB[@]}\fP" 的扩展，在大多数情况下，\fB$*\fP 和 \fB${\fP\fIname\fP\fB[*]}\fP 如上所述 (参见
.SM
\fBPARAMETERS\fP).
.SS "Brace Expansion"
\fIBrace expansion\fP 是一种可以生成任意字符串的机制。 这种机制类似于 \fIpathname expansion\fP，但生成的文件名不需要存在。 要进行大括号扩展的模式采用可选的 \fIpreamble\fP
形式，后跟一系列以逗号分隔的字符串或一对大括号之间的序列表达式，然后是可选的 \fIpostscript\fP。
序言作为前缀添加到大括号中包含的每个字符串，然后将后记追加到每个结果字符串，从左到右扩展。
.PP
大括号扩展可以嵌套。 每个扩展字符串的结果没有排序; 从左到右的顺序被保留。 例如，a\fB{\fPd,c,b\fB}\fPe 扩展为 `ade ace abe`。
.PP
序列表达式采用 \fB{\fP\fIx\fP\fB..\fP\fIy\fP\fB[..\fP\fIincr\fP\fB]}\fP 形式，其中 \fIx\fP 和 \fIy\fP
是整数或单个字符，\fIincr\fP (可选增量) 是整数。 当提供整数时，表达式将扩展为 \fIx\fP 和 \fIy\fP 之间的每个数字，包括端值。
提供的整数可以以 \fI0\fP 为前缀，以强制每个项具有相同的宽度。 当 \fIx\fP 或 \fIy\fP 以零开头时，shell
会尝试强制所有生成的术语包含相同数量的数字，并在必要时进行零填充。 当提供字符时，表达式会使用默认的 C 语言环境扩展到 \fIx\fP 和 \fIy\fP
之间的字典顺序的每个字符 (含)。 请注意，\fIx\fP 和 \fIy\fP 必须属于同一类型。 当提供增量时，它被用作每一项之间的差异。 默认增量为 1 或
\-1 (视情况而定)。
.PP
大括号扩展在任何其他扩展之前执行，并且任何其他扩展特有的字符都保留在结果中。 它是严格的文本。 \fBBash\fP
不对扩展的上下文或大括号之间的文本应用任何句法解释。
.PP
正确形成的大括号扩展必须包含未加引号的左大括号和右大括号，以及至少一个未加引号的逗号或有效的序列表达式。 任何错误形成的大括号扩展都保持不变。 \fB{\fP
或 \fB,\fP 可以用反斜杠引用，以防止将其视为大括号表达式的一部分。 为避免与参数扩展冲突，字符串 \fB${\fP 不被视为符合大括号扩展的条件，并且在关闭
\fB}\fP 之前禁止大括号扩展。
.PP
当要生成的字符串的公共前缀比上面的例子长时，这个结构通常用作速记:
.RS
.PP
mkdir /usr/local/src/bash/{old,new,dist,bugs}
.RE
or
.RS
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
.RE
.PP
大括号扩展引入了与 \fBsh\fP 历史版本的轻微不兼容。 当左括号或右括号作为单词的一部分出现时，\fBsh\fP
不会对其进行特殊处理，而是将它们保留在输出中。 由于大括号扩展，\fBBash\fP 从单词中删除了大括号。 例如，作为 \fIfile{1,2}\fP 输入到
\fBsh\fP 的单词在输出中显示相同。 \fBbash\fP 展开后，相同的字输出为 \fIfile1 file2\fP。 如果需要与 \fBsh\fP 严格兼容，请使用
\fB+B\fP 选项启动 \fBbash\fP 或使用 \fBset\fP 命令的 \fB+B\fP 选项禁用大括号扩展 (请参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.SS "Tilde Expansion"
如果单词以未加引号的波浪字符 (`\fB~\fP') 开头，则第一个未加引号的斜杠之前的所有字符 (或所有字符，如果没有未加引号的斜杠) 都被视为
\fItilde\-prefix\fP。 如果波浪号前缀中的字符均未被引用，则波浪号后的波浪号前缀中的字符将被视为可能的 \fIlogin name\fP。
如果此登录名是空字符串，波浪号将替换为 shell 参数
.SM
\fBHOME\fP 的值。 如果
.SM
\fBHOME\fP 未设置，则替换为执行
shell 的用户的主目录。 否则，波浪号前缀将替换为与指定登录名关联的主目录。
.PP
如果波浪号前缀是 `~+`，则 shell 变量
.SM
\fBPWD\fP 的值将替换波浪号前缀。如果波浪号前缀是 `~\-`，则 shell 变量
.SM
\fBOLDPWD\fP 的值 (如果已设置) 将被替换。如果波浪号前缀中波浪号后面的字符由数字 \fIN\fP 组成，可选地以 `+` 或 `\-`
为前缀，则波浪号前缀将替换为目录栈中的相应元素，因为它将显示由 \fBdirs\fP
内置调用，波浪号前缀作为参数调用。如果波浪号前缀中波浪号后面的字符由没有前导 `+` 或 `\-` 的数字组成，则假定为 `+`。
.PP
如果登录名无效，或者波浪号扩展失败，则单词不变。
.PP
检查每个变量赋值是否有紧跟在 \fB:\fP 或第一个 \fB=\fP 之后的未加引号的波浪号前缀。 在这些情况下，还会执行波浪线扩展。 因此，可以在
.SM
\fBPATH\fP、
.SM
\fBMAILPATH\fP 和
.SM
\fBCDPATH\fP 的分配中使用带波浪号的文件名，并且 shell 分配扩展值。
.PP
Bash 还对满足变量赋值条件的单词执行波浪线扩展 (如上文
.SM
\fBPARAMETERS\fP) 中所述，当它们在简单命令中显示为参数时。
Bash 在 \fIposix mode\fP 中不执行此操作，但上面列出的 \fIdeclaration\fP 命令除外。
.SS "Parameter Expansion"
`\fB$\fP' 字符引入了参数扩展、命令替换或算术扩展。
要扩展的参数名称或符号可以括在大括号中，大括号是可选的，但用于保护要扩展的变量免受紧随其后的字符的影响，这些字符可能被解释为名称的一部分。
.PP
使用大括号时，匹配的结束大括号是第一个 `\fB}\fP'，它没有被反斜杠转义或在带引号的字符串中，也不在嵌入式算术扩展、命令替换或参数扩展中。
.PP
.PD 0
.TP 
${\fIparameter\fP}
\fIparameter\fP 的值被替换。 当 \fIparameter\fP 是一个多于一位的位置参数，或者当 \fIparameter\fP
后跟一个不被解释为其名称的一部分的字符时，大括号是必需的。 \fIparameter\fP 是一个 shell 参数，如上所述 \fBPARAMETERS\fP)
或一个数组引用 (\fBArrays\fP)。
.PD
.PP
如果 \fIparameter\fP 的第一个字符是感叹号 (\fB!\fP)，而 \fIparameter\fP 不是 \fInameref\fP，则它引入了一个间接级别。
\fBBash\fP 将 \fIparameter\fP 剩余部分展开后形成的值作为新的 \fIparameter\fP; 然后将其展开，该值将用于其余的展开，而不是原始
\fIparameter\fP 的展开。 这称为 \fIindirect expansion\fP。 该值受波浪号扩展、参数扩展、命令替换和算术扩展的约束。 如果
\fIparameter\fP 是 nameref，这将扩展为 \fIparameter\fP 引用的参数的名称，而不是执行完整的间接扩展。 例外情况是下面描述的
${\fB!\fP\fIprefix\fP\fB*\fP} 和 ${\fB!\fP\fIname\fP[\fI@\fP]} 的扩展。 感叹号必须紧跟在左大括号之后，以引入间接性。
.PP
在下面的每种情况下，\fIword\fP 都要进行波浪号扩展、参数扩展、命令替换和算术扩展。
.PP
当不执行子字符串扩展时，使用下面记录的形式 (例如，\fB:\-\fP)、\fBbash\fP 测试未设置或为空的参数。 省略冒号会导致仅针对未设置的参数进行测试。
.PP
.PD 0
.TP 
${\fIparameter\fP\fB:\-\fP\fIword\fP}
\fBUse Default Values\fP.   如果 \fIparameter\fP 未设置或为空，则替换 \fIword\fP 的扩展。 否则，将替换
\fIparameter\fP 的值。
.TP 
${\fIparameter\fP\fB:=\fP\fIword\fP}
\fBAssign Default Values\fP.   如果 \fIparameter\fP 未设置或为空，则 \fIword\fP 的扩展分配给
\fIparameter\fP。 然后替换 \fIparameter\fP 的值。 位置参数和特殊参数不能以这种方式赋值。
.TP 
${\fIparameter\fP\fB:?\fP\fIword\fP}
\fBDisplay Error if Null or Unset\fP.   如果 \fIparameter\fP 为 null 或未设置，则 \fIword\fP
的扩展 (如果 \fIword\fP 不存在则为该效果的消息) 将写入标准错误并且 shell (如果它不是交互式的) 将退出。 否则，将替换
\fIparameter\fP 的值。
.TP 
${\fIparameter\fP\fB:+\fP\fIword\fP}
\fBUse Alternate Value\fP.   如果 \fIparameter\fP 为空或未设置，则不替换任何内容，否则替换 \fIword\fP 的扩展。
.TP 
${\fIparameter\fP\fB:\fP\fIoffset\fP}
.PD 0
.TP 
${\fIparameter\fP\fB:\fP\fIoffset\fP\fB:\fP\fIlength\fP}
.PD
\fBSubstring Expansion\fP.   从 \fIoffset\fP 指定的字符开始，最多扩展到 \fIparameter\fP 值的
\fIlength\fP 个字符。 如果 \fIparameter\fP 是 \fB@\fP、下标为 \fB@\fP 或 \fB*\fP
的索引数组或关联数组名称，则结果会有所不同，如下所述。 如果省略 \fIlength\fP，则扩展为 \fIparameter\fP 值的子字符串，从
\fIoffset\fP 指定的字符开始，一直延伸到该值的末尾。 \fIlength\fP 和 \fIoffset\fP 是算术表达式 (见下面的
.SM
\fBARITHMETIC EVALUATION\fP)。
.sp 1
如果 \fIoffset\fP 的计算结果为小于零的数字，则该值将用作距 \fIparameter\fP 值末尾的字符偏移量。 如果 \fIlength\fP
的计算结果为小于零的数字，则将其解释为距 \fIparameter\fP 值末尾的字符偏移量，而不是字符数，并且扩展是 \fIoffset\fP
与该结果之间的字符。 请注意，negative 偏移量必须与冒号分隔至少一个空格，以免与 \fB:\-\fP 扩展混淆。
.sp 1
如果 \fIparameter\fP 是 \fB@\fP，则结果是从 \fIoffset\fP 开始的 \fIlength\fP 位置参数。 negative
\fIoffset\fP 相对于大于最大位置参数的一个，因此 \-1 的偏移量计算为最后一个位置参数。 如果 \fIlength\fP
的计算结果为小于零的数字，则为扩展错误。
.sp 1
如果 \fIparameter\fP 是下标为 @或 * 的索引数组名称，则结果是以 ${\fIparameter\fP[\fIoffset\fP]} 开头的数组的
\fIlength\fP 成员。 negative \fIoffset\fP 是相对于比指定数组的最大索引大的一个。 如果 \fIlength\fP
的计算结果为小于零的数字，则为扩展错误。
.sp 1
应用于关联数组的子字符串扩展会产生未定义的结果。
.sp 1
除非使用位置参数，否则子字符串索引从零开始，在这种情况下，索引默认从 1 开始。 如果 \fIoffset\fP 为 0，并且使用了位置参数，则 \fB$0\fP
将作为前缀添加到列表中。
.TP 
${\fB!\fP\fIprefix\fP\fB*\fP}
.PD 0
.TP 
${\fB!\fP\fIprefix\fP\fB@\fP}
.PD
\fBNames matching prefix\fP.   扩展为名称以 \fIprefix\fP 开头的变量的名称，由
.SM
\fBIFS\fP
特殊变量的第一个字符分隔。 当使用 \fI@\fP 并且扩展出现在双引号内时，每个变量名称都会扩展为一个单独的词。
.TP 
${\fB!\fP\fIname\fP[\fI@\fP]}
.PD 0
.TP 
${\fB!\fP\fIname\fP[\fI*\fP]}
.PD
\fBList of array keys\fP.   如果 \fIname\fP 是一个数组变量，则扩展为 \fIname\fP 中分配的数组索引 (keys)
的列表。 如果 \fIname\fP 不是数组，则在设置 \fIname\fP 时扩展为 0，否则扩展为 null。 当使用 \fI@\fP
并且扩展出现在双引号内时，每个键都会扩展为一个单独的词。
.TP 
${\fB#\fP\fIparameter\fP}
\fBParameter length\fP.   替换 \fIparameter\fP 值的字符长度。 如果 \fIparameter\fP 为 \fB*\fP 或
\fB@\fP，则代入的值为位置参数的个数。 如果 \fIparameter\fP 是下标为 \fB*\fP 或 \fB@\fP 的数组名，则替换的值是数组中的元素数。 如果
\fIparameter\fP 是下标为 negative 数字的索引数组名称，则该数字被解释为相对于大于 \fIparameter\fP 的最大索引的一个，因此
negative 索引从数组的末尾开始倒数，\-1 的索引引用最后一个元素.
.TP 
${\fIparameter\fP\fB#\fP\fIword\fP}
.PD 0
.TP 
${\fIparameter\fP\fB##\fP\fIword\fP}
.PD
\fBRemove matching prefix pattern\fP.   \fIword\fP 被扩展以产生一个模式，就像在路径名扩展中一样，并使用下面
\fBPattern Matching\fP 中描述的规则与 \fIparameter\fP 的扩展值匹配。 如果模式与 \fIparameter\fP
值的开头匹配，则扩展的结果是 \fIparameter\fP 的扩展值，删除了最短匹配模式 (\*(lq\fB#\fP\*(rq 情况) 或最长匹配模式 (\*(lq\fB##\fP\*(rq
情况)。 如果 \fIparameter\fP 为 \fB@\fP 或 \fB*\fP，则依次对每个位置参数进行模式去除操作，展开后的结果列表。 如果
\fIparameter\fP 是下标为 \fB@\fP 或 \fB*\fP 的数组变量，则依次对数组的每个成员进行模式删除操作，扩展为结果列表。
.TP 
${\fIparameter\fP\fB%\fP\fIword\fP}
.PD 0
.TP 
${\fIparameter\fP\fB%%\fP\fIword\fP}
.PD
\fBRemove matching suffix pattern\fP.   \fIword\fP 被扩展以产生一个模式，就像在路径名扩展中一样，并使用下面
\fBPattern Matching\fP 中描述的规则与 \fIparameter\fP 的扩展值匹配。 如果模式与 \fIparameter\fP
的扩展值的尾部匹配，则扩展的结果是 \fIparameter\fP 的扩展值，其中删除了最短匹配模式 (\*(lq\fB%\fP\*(rq 情况) 或最长匹配模式
(\*(lq\fB%%\fP\*(rq 情况)。 如果 \fIparameter\fP 为 \fB@\fP 或 \fB*\fP，则依次对每个位置参数进行模式去除操作，展开后的结果列表。
如果 \fIparameter\fP 是下标为 \fB@\fP 或 \fB*\fP 的数组变量，则依次对数组的每个成员进行模式删除操作，扩展为结果列表。
.TP 
${\fIparameter\fP\fB/\fP\fIpattern\fP\fB/\fP\fIstring\fP}
\fBPattern substitution\fP.   \fIpattern\fP 被扩展以产生一个模式，就像在路径名扩展中一样，\fIParameter\fP
被扩展并且 \fIpattern\fP 与其值的最长匹配被替换为 \fIstring\fP。 使用下面 \fBPattern Matching\fP
中描述的规则执行匹配。 如果 \fIpattern\fP 以 \fB/\fP 开头，则 \fIpattern\fP 的所有匹配项都将替换为 \fIstring\fP。
通常只替换第一个匹配项。 如果 \fIpattern\fP 以 \fB#\fP 开头，则它必须匹配 \fIparameter\fP 扩展值的开头。 如果
\fIpattern\fP 以 \fB%\fP 开头，则它必须匹配 \fIparameter\fP 扩展值的末尾。 如果 \fIstring\fP 为空，则删除
\fIpattern\fP 的匹配项，并且可以省略 \fIpattern\fP 之后的 \fB/\fP。 如果启用 \fBnocasematch\fP shell
选项，则执行匹配时不考虑字母字符的大小写。 如果 \fIparameter\fP 是 \fB@\fP 或
\fB*\fP，则依次对每个位置参数进行替换操作，展开后的结果列表。 如果 \fIparameter\fP 是下标为 \fB@\fP 或 \fB*\fP
的数组变量，则代入操作依次应用于数组的每个成员，展开是结果列表。
.TP 
${\fIparameter\fP\fB^\fP\fIpattern\fP}
.PD 0
.TP 
${\fIparameter\fP\fB^^\fP\fIpattern\fP}
.TP 
${\fIparameter\fP\fB,\fP\fIpattern\fP}
.TP 
${\fIparameter\fP\fB,,\fP\fIpattern\fP}
.PD
\fBCase modification\fP.   此扩展修改了 \fIparameter\fP 中字母字符的大小写。 \fIpattern\fP
被扩展以产生一个模式，就像在路径名扩展中一样。 \fIparameter\fP 的扩展值中的每个字符都针对 \fIpattern\fP
进行测试，如果它与模式匹配，则转换其大小写。 该模式不应尝试匹配多个字符。 \fB^\fP 运算符将匹配 \fIpattern\fP 的小写字母转换为大写;
\fB,\fP 运算符将匹配的大写字母转换为小写字母。 \fB^^\fP 和 \fB,,\fP 扩展转换扩展值中的每个匹配字符; \fB^\fP 和 \fB,\fP
扩展仅匹配和转换扩展值中的第一个字符。 如果省略 \fIpattern\fP，则将其视为 \fB?\fP，匹配所有字符。 如果 \fIparameter\fP 为
\fB@\fP 或 \fB*\fP，则依次对每个位置参数进行大小写修改操作，扩展为结果列表。 如果 \fIparameter\fP 是一个下标为 \fB@\fP 或 \fB*\fP
的数组变量，则依次对数组的每个成员进行大小写修改操作，展开就是结果列表。
.TP 
${\fIparameter\fP\fB@\fP\fIoperator\fP}
\fBParameter transformation\fP.   扩展要么是 \fIparameter\fP 值的转换，要么是关于 \fIparameter\fP
本身的信息，具体取决于 \fIoperator\fP 的值。 每个 \fIoperator\fP 都是一个字母:
.sp 1
.RS
.PD 0
.TP 
\fBU\fP
扩展是一个字符串，它是 \fIparameter\fP 的值，小写字母字符转换为大写字母。
.TP 
\fBu\fP
扩展是一个字符串，它是 \fIparameter\fP 的值，如果第一个字符是字母，则将其转换为大写。
.TP 
\fBL\fP
扩展是一个字符串，它是 \fIparameter\fP 的值，将大写字母字符转换为小写字母。
.TP 
\fBQ\fP
扩展是一个字符串，它是 \fIparameter\fP 的值，以可重复用作输入的格式引用。
.TP 
\fBE\fP
扩展是一个字符串，它是 \fIparameter\fP 的值，带有与 \fB$'...'\fP 引用机制一样扩展的反斜杠转义序列。
.TP 
\fBP\fP
扩展是一个字符串，它是扩展 \fIparameter\fP 的值的结果，就好像它是一个提示字符串 (参见下面的 \fBPROMPTING\fP)。
.TP 
\fBA\fP
扩展是赋值语句或 \fBdeclare\fP 命令形式的字符串，如果对其进行评估，将重新创建 \fIparameter\fP 及其属性和值。
.TP 
\fBK\fP
生成 \fIparameter\fP 值的可能引用版本，除了它将索引数组和关联数组的值打印为引用键值对序列 (参见上面的 \fBArrays\fP)。
.TP 
\fBa\fP
扩展是一个字符串，由表示 \fIparameter\fP's 属性的标志值组成。
.PD
.PP
如果 \fIparameter\fP 为 \fB@\fP 或 \fB*\fP，则依次对每个位置参数进行运算，扩展为结果列表。 如果 \fIparameter\fP 是下标为
\fB@\fP 或 \fB*\fP 的数组变量，则依次对数组的每个成员进行运算，展开即为结果列表。
.sp 1
扩展的结果受如下所述的分词和路径名扩展的影响。
.RE
.SS "Command Substitution"
\fICommand substitution\fP 允许用命令的输出替换命令名。 有两种形式:
.RS
.PP
\fB$(\fP\fIcommand\fP\|\fB)\fP
.RE
or
.RS
\fB\`\fP\fIcommand\fP\fB\`\fP
.RE
.PP
\fBBash\fP 通过在子 shell 环境中执行 \fIcommand\fP 并将命令替换替换为命令的标准输出来执行扩展，并删除任何尾随换行符。
嵌入的换行符不会被删除，但它们可能会在分词时被删除。 命令替换 \fB$(cat \fP\fIfile\fP\fB)\fP 可以替换为等效但更快的 \fB$(< \fP\fIfile\fP\fB)\fP。
.PP
当使用旧式反引号替换形式时，反斜杠保留其字面量的含义，除非后跟 \fB$\fP、\fB\`\fP 或 \fB\e\fP。 前面没有反斜杠的第一个反引号终止命令替换。
当使用 $(\^\fIcommand\fP\|) 形式时，括号中的所有字符组成命令; 没有人受到特殊对待。
.PP
命令替换可以嵌套。 要在使用反引号形式时进行嵌套，请使用反斜杠转义内部反引号。
.PP
如果替换出现在双引号内，则不会对结果执行分词和路径名扩展。
.SS "Arithmetic Expansion"
算术展开允许计算算术表达式和替换结果。 算术展开的格式为:
.RS
.PP
\fB$((\fP\fIexpression\fP\fB))\fP
.RE
.PP
\fIexpression\fP 被视为在双引号内，但括号内的双引号未被特殊处理。 表达式中的所有 tokens 都经过参数和变量扩展、命令替换和引号删除。
结果被视为要评估的算术表达式。 算术展开可以嵌套。
.PP
评估是根据下面在
.SM
\fBARITHMETIC EVALUATION\fP 下列出的规则进行的。 如果 \fIexpression\fP 无效，则
\fBbash\fP 打印一条消息指示失败并且不发生替换。
.SS "Process Substitution"
\fIProcess substitution\fP 允许使用文件名引用进程的输入或输出。 它采用 \fB<(\fP\fIlist\^\fP\fB)\fP 或
\fB>(\fP\fIlist\^\fP\fB)\fP 的形式。 进程 \fIlist\fP 异步运行，其输入或输出显示为文件名。
作为扩展的结果，此文件名作为参数传递给当前命令。 如果使用 \fB>(\fP\fIlist\^\fP\fB)\fP 形式，写入文件将为 \fIlist\fP 提供输入。
如果使用 \fB<(\fP\fIlist\^\fP\fB)\fP 形式，则应读取作为参数传递的文件以获得 \fIlist\fP 的输出。 在支持命名管道
(\fIFIFOs\fP) 或命名打开文件的 \fB/dev/fd\fP 方法的系统上支持进程替换。
.PP
如果可用，进程替换与参数和变量扩展、命令替换和算术扩展同时执行。
.SS "Word Splitting"
shell 扫描 \fIword splitting\fP 双引号内没有发生的参数扩展、命令替换和算术扩展的结果。
.PP
shell 将
.SM
\fBIFS\fP 的每个字符视为分隔符，并将其他扩展的结果拆分为使用这些字符作为字段终止符的单词。 如果未设置
.SM
\fBIFS\fP，或其值恰好为默认值
\fB<space><tab><newline>\fP，则忽略先前扩展结果开头和结尾处的
\fB<space>\fP、\fB<tab>\fP 和 \fB<newline>\fP
序列，并且忽略不在开头或结尾用于分隔单词。 如果
.SM
\fBIFS\fP 的值不是默认值，则在单词的开头和结尾忽略空白字符
\fBspace\fP、\fBtab\fP 和 \fBnewline\fP 的序列，只要空白字符在
.SM
\fBIFS\fP 的值中 (一个
.SM
\fBIFS\fP
空白字符)。
.SM
\fBIFS\fP 中不是
.SM
\fBIFS\fP 空白字符的任何字符，连同任何相邻的
.SM
\fBIFS\fP
空白字符，界定一个字段。 一系列
.SM
\fBIFS\fP 空白字符也被视为分隔符。 如果
.SM
\fBIFS\fP 的值为
null，则不进行分词。
.PP
显式空参数 (\^\fB"\^"\fP 或 \^\fB\(aq\^\(aq\fP\^) 被保留并作为空字符串传递给命令。 不带引号的隐式 null
参数，由于没有值的参数的扩展而被删除。 如果没有值的参数在双引号内展开，则会产生空参数并将其保留并作为空字符串传递给命令。
当带引号的空参数作为扩展为非空的单词的一部分出现时，空参数将被删除。 即 \f(CW\-d\(aq\^\(aq\fP 这个词经过分词和去空参数后变成了
\f(CW\-d\fP。
.PP
请注意，如果没有发生扩展，则不会执行拆分。
.SS "Pathname Expansion"
单词拆分后，除非设置了 \fB\-f\fP 选项，否则 \fBbash\fP 会扫描每个单词以查找字符 \fB*\fP、\fB?\fP 和 \fB[\fP。
如果这些字符中的一个出现，并且没有被引用，那么这个词被认为是一个 \fIpattern\fP，并被一个按字母顺序排序的匹配模式的文件名列表替换 (见下面的
.SM
\fBPattern Matching\fP)。 如果找不到匹配的文件名，并且未启用 shell 选项 \fBnullglob\fP，则该词保持不变。
如果设置了 \fBnullglob\fP 选项，但未找到匹配项，则删除该词。 如果设置了 \fBfailglob\fP shell
选项，但未找到匹配项，则会打印一条错误消息并且不执行该命令。 如果启用了 shell 选项
\fBnocaseglob\fP，则执行匹配时不考虑字母字符的大小写。 当模式用于路径名扩展时，名称开头或紧跟在斜杠后面的字符 \fB\*(lq.\*(rq\fP
必须显式匹配，除非设置了 shell 选项 \fBdotglob\fP。 文件名 \fB\*(lq.\*(rq\fP 和 \fB\*(lq..\*(rq\fP 必须始终显式匹配，即使设置了
\fBdotglob\fP。 在其他情况下，不会特殊处理 \fB\*(lq.\*(rq\fP 字符。
匹配路径名时，斜杠字符必须始终与模式中的斜杠显式匹配，但在其他匹配上下文中，它可以与特殊模式字符匹配，如下面
.SM
\fBPattern Matching\fP 所述。 有关 \fBnocaseglob\fP、\fBnullglob\fP、\fBfailglob\fP 和 \fBdotglob\fP shell
选项的说明，请参见下面
.SM
\fBSHELL BUILTIN COMMANDS\fP 下的 \fBshopt\fP 说明。
.PP
.SM
\fBGLOBIGNORE\fP shell 变量可用于限制匹配 \fIpattern\fP 的文件名集。 如果设置了
.SM
\fBGLOBIGNORE\fP，则从匹配列表中删除每个也与
.SM
\fBGLOBIGNORE\fP 中的模式之一匹配的匹配文件名。 如果设置了
\fBnocaseglob\fP 选项，则在不考虑大小写的情况下执行与
.SM
\fBGLOBIGNORE\fP 中的模式的匹配。 当设置
.SM
\fBGLOBIGNORE\fP 且不为空时，文件名 \fB\*(lq.\*(rq\fP 和 \fB\*(lq..\*(rq\fP 始终被忽略。 但是，将
.SM
\fBGLOBIGNORE\fP 设置为非空值具有启用 \fBdotglob\fP shell 选项的效果，因此以 \fB\*(lq.\*(rq\fP 开头的所有其他文件名将匹配。
要获得忽略以 \fB\*(lq.\*(rq\fP 开头的文件名的旧行为，请将 \fB\*(lq.*\*(rq\fP 设为
.SM
\fBGLOBIGNORE\fP 中的模式之一。 当
.SM
\fBGLOBIGNORE\fP 未设置时，\fBdotglob\fP 选项被禁用。 模式匹配遵循 \fBextglob\fP shell 选项的设置。
.PP
\fBPattern Matching\fP
.PP
除下面描述的特殊模式字符外，出现在模式中的任何字符都与自身相匹配。 NUL 字符不能出现在模式中。 反斜杠转义以下字符; 匹配时会丢弃转义的反斜杠。
如果要按字面匹配，则必须引用特殊模式字符。
.PP
特殊模式字符的含义如下:
.PP
.PD 0
.RS
.TP 
\fB*\fP
匹配任何字符串，包括空字符串。 当启用 \fBglobstar\fP shell 选项并且在路径名扩展上下文中使用 \fB*\fP 时，用作单个模式的两个相邻
\fB*\fPs 将匹配所有文件以及零个或多个目录和子目录。 如果后面跟一个 \fB/\fP，两个相邻的 \fB*\fPs 将只匹配目录和子目录。
.TP 
\fB?\fP
匹配任何单个字符。
.TP 
\fB[...]\fP
匹配任何一个包含的字符。 由连字符分隔的一对字符表示 \fIrange expression\fP;
使用当前语言环境的整理顺序和字符集，匹配这两个字符之间的任何字符 (包括端值)。 如果 \fB[\fP 之后的第一个字符是 \fB!\fP 或
\fB^\fP，则匹配未包含的任何字符。 范围表达式中字符的排序顺序由当前语言环境和
.SM
\fBLC_COLLATE\fP 或
.SM
\fBLC_ALL\fP shell 变量 (如果设置) 的值决定。 要获得范围表达式的传统解释，其中 \fB[a\-d]\fP 等于 \fB[abcd]\fP，请将
\fBLC_ALL\fP shell 变量的值设置为 \fBC\fP，或启用 \fBglobasciiranges\fP shell 选项。 \fB\-\fP
可以通过将其作为集合中的第一个或最后一个字符来匹配。 \fB]\fP 可以通过将其作为集合中的第一个字符来匹配。
.br
.if  t .sp 0.5
.if  n .sp 1
在 \fB[\fP 和 \fB]\fP 中，可以使用语法 \fB[:\fP\fIclass\fP\fB:]\fP 指定 \fIcharacter classes\fP，其中
\fIclass\fP 是 POSIX 标准中定义的以下类之一:
.PP
.RS
.B
.if  n alnum alpha ascii blank cntrl digit graph lower print punct space upper word xdigit
.if  t alnum   alpha   ascii   blank   cntrl   digit   graph   lower   print   punct   space   upper   word   xdigit
.br
字符类匹配属于该类的任何字符。 \fBword\fP 字符类匹配字母、数字和字符 _。
.br
.if  t .sp 0.5
.if  n .sp 1
在 \fB[\fP 和 \fB]\fP 中，可以使用语法 \fB[=\fP\fIc\fP\fB=]\fP 指定 \fIequivalence class\fP，它匹配与字符 \fIc\fP
具有相同归类权重 (由当前语言环境定义) 的所有字符。
.br
.if  t .sp 0.5
.if  n .sp 1
在 \fB[\fP 和 \fB]\fP 中，语法 \fB[.\fP\fIsymbol\fP\fB.]\fP 匹配整理符号 \fIsymbol\fP。
.RE
.RE
.PD
.PP
如果使用内置的 \fBshopt\fP 启用了 \fBextglob\fP shell 选项，则可以识别几个扩展模式匹配运算符。
在下面的描述中，\fIpattern\-list\fP 是由 \fB|\fP 分隔的一个或多个模式的列表。 复合图案可以使用以下一种或多种子图案形成:
.sp 1
.PD 0
.RS
.TP 
\fB?(\fP\^\fIpattern\-list\^\fP\fB)\fP
匹配零次或一次出现的给定模式
.TP 
\fB*(\fP\^\fIpattern\-list\^\fP\fB)\fP
匹配给定模式的零次或多次出现
.TP 
\fB+(\fP\^\fIpattern\-list\^\fP\fB)\fP
匹配给定模式的一次或多次出现
.TP 
\fB@(\fP\^\fIpattern\-list\^\fP\fB)\fP
匹配给定模式之一
.TP 
\fB!(\fP\^\fIpattern\-list\^\fP\fB)\fP
匹配除给定模式之一以外的任何内容
.RE
.PD
.PP
针对长字符串的复杂扩展模式匹配速度很慢，尤其是当模式包含交替且字符串包含多个匹配项时。
对较短的字符串使用单独的匹配，或者使用字符串数组而不是单个长字符串，可能会更快。
.SS "Quote Removal"
在前面的扩展之后，所有未引起来的字符 \fB\e\fP、\fB\(aq\fP 和 \^\fB"\fP\^ 的出现都将被删除，这些字符不是由上述扩展之一产生的。
.SH REDIRECTION
在执行命令之前，它的输入和输出可能是使用由 shell 解释的特殊符号的 \fIredirected\fP。
重定向允许复制、打开、关闭命令的文件句柄，使之指向不同的文件，并且可以更改命令读取和写入的文件。 重定向也可用于修改当前 shell
执行环境中的文件句柄。 以下重定向运算符可能出现在 \fIsimple command\fP 之前或出现在 \fIsimple command\fP
中的任何位置，也可能跟在 \fIcommand\fP 之后。 重定向按照它们出现的顺序从左到右处理。
.PP
每个可能以文件描述符编号开头的重定向都可以改为以 {\fIvarname\fP} 形式的单词开头。 在这种情况下，对于除 >&\- 和 <&\-
之外的每个重定向运算符，shell 都会分配一个大于等于 10 的文件描述符，并将其赋值给 \fIvarname\fP。 如果 >&\- 或
<&\- 前面有 {\fIvarname\fP}，则 \fIvarname\fP 的值定义要关闭的文件描述符。 如果提供了
{\fIvarname\fP}，则重定向会在命令的作用域之外持续存在，从而允许 shell 程序员自己管理文件描述符。
.PP
在下面的描述中，如果省略文件描述符编号，并且重定向操作符的第一个字符是 \fB<\fP，则重定向是指标准输入 (文件描述符 0)。
如果重定向运算符的第一个字符是 \fB>\fP，则重定向指向标准输出 (文件描述符 1)。
.PP
以下描述中重定向运算符后面的词，除非另有说明，否则会进行大括号扩展、波浪符扩展、参数和变量扩展、命令替换、算术扩展、引号删除、路径名扩展和分词。
如果扩展到一个以上的单词，\fBbash\fP 会报错。
.PP
请注意，重定向的顺序很重要。 例如，命令
.RS
.PP
ls \fB>\fP 目录 2\fB>&\fP1
.RE
.PP
将标准输出和标准错误都定向到文件 \fIdirlist\fP，而命令
.RS
.PP
ls 2\fB>&\fP1 \fB>\fP dirlist
.RE
.PP
仅将标准输出定向到文件 \fIdirlist\fP，因为在标准输出重定向到 \fIdirlist\fP 之前，标准错误已从标准输出复制。
.PP
当在重定向中使用时，\fBBash\fP 会专门处理几个文件名，如下表所述。 如果运行 \fBbash\fP 的操作系统提供了这些特殊文件，bash 将使用它们;
否则它将使用下面描述的行为在内部模拟它们。
.RS
.PP
.PD 0
.TP 
\fB/dev/fd/\fP\fIfd\fP
如果 \fIfd\fP 是有效整数，则复制文件描述符 \fIfd\fP。
.TP 
\fB/dev/stdin\fP
文件描述符 0 重复。
.TP 
\fB/dev/stdout\fP
文件描述符 1 重复。
.TP 
\fB/dev/stderr\fP
文件描述符 2 重复。
.TP 
\fB/dev/tcp/\fP\fIhost\fP\fB/\fP\fIport\fP
如果 \fIhost\fP 是一个有效的主机名或 Internet 地址，而 \fIport\fP 是一个整数端口号或服务名称，则 \fBbash\fP 会尝试打开相应的
TCP 套接字。
.TP 
\fB/dev/udp/\fP\fIhost\fP\fB/\fP\fIport\fP
如果 \fIhost\fP 是有效的主机名或 Internet 地址，而 \fIport\fP 是整数端口号或服务名称，则 \fBbash\fP 会尝试打开相应的 UDP
套接字。
.PD
.RE
.PP
打开或创建文件失败会导致重定向失败。
.PP
使用大于 9 的文件描述符的重定向应该小心使用，因为它们可能与 shell 内部使用的文件描述符冲突。
.SS "Redirecting Input"
输入的重定向导致其名称由 \fIword\fP 扩展产生的文件打开以在文件描述符 \fIn\fP 上读取，如果未指定 \fIn\fP，则在标准输入 (文件描述符 0)
上打开。
.PP
重定向输入的一般格式是:
.RS
.PP
[\fIn\fP]\fB<\fP\fIword\fP
.RE
.SS "Redirecting Output"
输出重定向导致其名称由 \fIword\fP 扩展产生的文件打开以在文件描述符 \fIn\fP 上写入，如果未指定 \fIn\fP，则打开标准输出 (文件描述符 1)。
如果文件不存在，则创建它; 如果它确实存在，它将被截断为零大小。
.PP
重定向输出的一般格式是:
.RS
.PP
[\fIn\fP]\fB>\fP\fIword\fP
.RE
.PP
如果重定向运算符是 \fB>\fP，并且 \fBset\fP 内置的 \fBnoclobber\fP 选项已启用，如果名称由 \fIword\fP
扩展产生的文件存在并且是常规文件，则重定向将失败。 如果重定向操作符是 \fB>|\fP，或者重定向操作符是 \fB>\fP，并且没有启用
\fBset\fP 内置命令的 \fBnoclobber\fP 选项，则即使 \fIword\fP 命名的文件存在，也会尝试重定向。
.SS "Appending Redirected Output"
以这种方式重定向输出会导致其名称由 \fIword\fP 扩展产生的文件被打开以追加到文件描述符 \fIn\fP 上，或者如果未指定 \fIn\fP 则为标准输出
(文件描述符 1)。 如果该文件不存在，则创建它。
.PP
追加，输出的一般格式是:
.RS
.PP
[\fIn\fP]\fB>>\fP\fIword\fP
.RE
.SS "Redirecting Standard Output and Standard Error"
此构造允许将标准输出 (文件描述符 1) 和标准错误输出 (文件描述符 2) 重定向到名称为 \fIword\fP 扩展的文件。
.PP
重定向标准输出和标准错误有两种格式:
.RS
.PP
\fB&>\fP\fIword\fP
.RE
and
.RS
\fB>&\fP\fIword\fP
.RE
.PP
在这两种形式中，第一种是首选。 这在语义上等同于
.RS
.PP
\fB>\fP\fIword\fP 2\fB>&\fP1
.RE
.PP
使用第二种形式时，\fIword\fP 可能不会扩展为数字或 \fB\-\fP。 如果是这样，出于兼容性原因，将应用其他重定向运算符 (请参见下面的
\fBDuplicating File Descriptors\fP)。
.SS "Appending Standard Output and Standard Error"
此构造允许将标准输出 (文件描述符 1) 和标准错误输出 (文件描述符 2) 追加到名称为 \fIword\fP 扩展的文件。
.PP
追加，标准输出和标准错误的格式是:
.RS
.PP
\fB&>>\fP\fIword\fP
.RE
.PP
这在语义上等同于
.RS
.PP
\fB>>\fP\fIword\fP 2\fB>&\fP1
.RE
.PP
(见下面的 \fBDuplicating File Descriptors\fP)。
.SS "Here Documents"
这种类型的重定向指示 shell 从当前源读取输入，直到看到仅包含 \fIdelimiter\fP (没有尾随空白) 的行。
然后将到该点为止读取的所有行用作命令的标准输入 (或文件描述符 \fIn\fP，如果指定了 \fIn\fP)。
.PP
这里文档的格式是:
.RS
.PP
.nf
[\fIn\fP]\fB<<\fP[\fB\-\fP]\fIword\fP
        \fIhere\-document\fP
\fIdelimiter\fP
.fi
.RE
.PP
不对 \fIword\fP 执行参数和变量扩展、命令替换、算术扩展或路径名扩展。 如果引用 \fIword\fP 的任何部分，则 \fIdelimiter\fP 是
\fIword\fP 上引用删除的结果，此处文档中的行不会展开。 如果 \fIword\fP 不加引号，则 here\-document
的所有行都进行参数扩展、命令替换和算术扩展，忽略字符序列 \fB\e<newline>\fP，并且必须使用 \fB\e\fP 来引用字符
\fB\e\fP、\fB$\fP 和 \fB\`\fP。
.PP
如果重定向运算符是 \fB<<\-\fP，则从输入行和包含 \fIdelimiter\fP 的行中删除所有前导制表符。 这允许 shell 脚本中的
here\-documents 以自然的方式缩进。
.SS "Here Strings"
此处文档的变体，格式为:
.RS
.PP
.nf
[\fIn\fP]\fB<<<\fP\fIword\fP
.fi
.RE
.PP
\fIword\fP 经历波浪号扩展、参数和变量扩展、命令替换、算术扩展和引用删除。 不执行路径名扩展和分词。
结果作为单个字符串提供，并，追加，一个换行符，提供给命令的标准输入 (如果指定了 \fIn\fP，则为文件描述符 \fIn\fP)。
.SS "Duplicating File Descriptors"
重定向运算符
.RS
.PP
[\fIn\fP]\fB<&\fP\fIword\fP
.RE
.PP
用于复制输入文件描述符。 如果 \fIword\fP 扩展为一个或多个数字，则 \fIn\fP 表示的文件描述符将成为该文件描述符的副本。 如果 \fIword\fP
中的数字未指定为输入打开的文件描述符，则会发生重定向错误。 如果 \fIword\fP 的计算结果为 \fB\-\fP，则关闭文件描述符 \fIn\fP。 如果未指定
\fIn\fP，则使用标准输入 (文件描述符 0)。
.PP
运营商
.RS
.PP
[\fIn\fP]\fB>&\fP\fIword\fP
.RE
.PP
类似于复制输出文件描述符。 如果未指定 \fIn\fP，则使用标准输出 (文件描述符 1)。 如果 \fIword\fP
中的数字未指定为输出打开的文件描述符，则会发生重定向错误。 如果 \fIword\fP 的计算结果为 \fB\-\fP，则关闭文件描述符 \fIn\fP。
作为一种特殊情况，如果 \fIn\fP 被省略，并且 \fIword\fP 不扩展为一个或多个数字或 \fB\-\fP，则标准输出和标准错误将如前所述重定向。
.SS "Moving File Descriptors"
重定向运算符
.RS
.PP
[\fIn\fP]\fB<&\fP\fIdigit\fP\fB\-\fP
.RE
.PP
将文件描述符 \fIdigit\fP 移动到文件描述符 \fIn\fP，如果未指定 \fIn\fP，则移动到标准输入 (文件描述符 0)。 \fIdigit\fP 复制到
\fIn\fP 后关闭。
.PP
同样，重定向运算符
.RS
.PP
[\fIn\fP]\fB>&\fP\fIdigit\fP\fB\-\fP
.RE
.PP
将文件描述符 \fIdigit\fP 移动到文件描述符 \fIn\fP，如果未指定 \fIn\fP，则移动到标准输出 (文件描述符 1)。
.SS "Opening File Descriptors for Reading and Writing"
重定向运算符
.RS
.PP
[\fIn\fP]\fB<>\fP\fIword\fP
.RE
.PP
导致名称为 \fIword\fP 的扩展的文件打开以在文件描述符 \fIn\fP 上进行读写，如果未指定 \fIn\fP，则在文件描述符 0 上打开。
如果该文件不存在，则创建它。
.SH ALIASES
\fIAliases\fP 允许用字符串代替单词，当它用作简单命令的第一个单词时。 shell 维护一个别名列表，可以使用 \fBalias\fP 和
\fBunalias\fP 内置命令设置和取消设置 (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
每个简单命令的第一个单词 (如果未加引号) 将被检查以查看它是否具有别名。 如果是这样，该词将替换为别名的文本。 字符 \fB/\fP、\fB$\fP、\fB\`\fP
和 \fB=\fP 以及上面列出的任何 shell \fImetacharacters\fP 或引号字符不得出现在别名中。 替换文本可能包含任何有效的 shell
输入，包括 shell 元字符。 替换文本的第一个词被测试别名，但与被扩展的别名相同的词不会被第二次扩展。 这意味着可以将 \fBls\fP 别名为 \fBls \-F\fP，例如，\fBbash\fP 不会尝试递归扩展替换文本。 如果别名值的最后一个字符是
\fIblank\fP，那么还会检查别名后面的下一个命令字是否有别名扩展。
.PP
别名是用 \fBalias\fP 命令创建和列出的，用 \fBunalias\fP 命令删除的。
.PP
没有在替换文本中使用参数的机制。 如果需要参数，则应使用 shell 函数 (参见下面的
.SM
\fBFUNCTIONS\fP)。
.PP
当 shell 不交互时，别名不会扩展，除非使用 \fBshopt\fP 设置 \fBexpand_aliases\fP shell 选项 (参见下面
.SM
\fBSHELL BUILTIN COMMANDS\fP 下的 \fBshopt\fP 的描述)。
.PP
关于别名的定义和使用的规则有些混乱。 在执行该行上的任何命令或复合命令之前，\fBBash\fP 始终至少读取一个完整的输入行，以及构成复合命令的所有行。
别名在读取命令时扩展，而不是在执行命令时扩展。 因此，与另一个命令出现在同一行的别名定义在读取下一行输入之前不会生效。
该行别名定义之后的命令不受新别名的影响。 当执行函数时，此行为也是一个问题。
别名在读取一个函数定义时扩展，而不是在函数执行时扩展，因为函数定义本身就是一个命令。 因此，在执行任数之前，在任数中定义的别名不可用。
为安全起见，始终将别名定义放在单独的行中，并且不要在复合命令中使用 \fBalias\fP。
.PP
对于几乎所有用途，别名都被 shell 函数取代。
.SH FUNCTIONS
一个 shell 函数，如上文
.SM
\fBSHELL GRAMMAR\fP 下所述定义，存储一系列命令供以后执行。 当 shell
函数的名称用作简单命令名称时，将执行与该函数名称关联的命令列表。 函数在当前 shell 的上下文中执行; 没有创建新进程来解释它们 (将此与
shell 脚本的执行进行对比)。 当一个函数被执行时，函数中的参数成为函数执行过程中的位置参数。 更新特殊参数 \fB#\fP 以反映更改。 特殊参数
\fB0\fP 不变。 当函数执行时，
.SM
\fBFUNCNAME\fP 变量的第一个元素被设置为函数的名称。
.PP
shell 执行环境的所有其他方面在函数及其调用者之间是相同的，除了这些例外:
.SM
\fBDEBUG\fP 和 \fBRETURN\fP 陷阱 (参见下面
.SM
\fBSHELL BUILTIN COMMANDS\fP 下的 \fBtrap\fP 内置的描述) 不会被继承，除非函数已被赋予 \fBtrace\fP
属性 (见下面
.SM
\fBdeclare\fP builtin 的描述) 或者 \fBset\fP builtin 启用了 \fB\-o functrace\fP
shell 选项 (此时所有的函数都继承 \fBDEBUG\fP 和 \fBRETURN\fP 陷阱)，
.SM
\fBERR\fP 陷阱不被继承，除非 \fB\-o errtrace\fP shell 选项已启用。
.PP
变量局部于函数可以用 \fBlocal\fP 内置命令声明。 通常，变量和它们的值在函数和它的调用者之间共享。 如果变量被声明为
\fBlocal\fP，则变量的可见作用域仅限于该函数及其子代 (包括它调用的函数)。 本地变量 "shadow" 变量与前一个作用域声明的名称相同。
例如，在一个函数中声明的局部变量隐藏了一个同名的全局变量: 引用和赋值引用局部变量，使全局变量保持不变。 当函数返回时，全局变量再次可见。
.PP
shell 使用 \fIdynamic scoping\fP 来控制变量在函数中的可见性。
使用动态范围，可见变量及其值是导致执行达到当前函数的函数调用序列的结果。 一个函数看到的变量的值取决于它在调用者中的值，如果有的话，无论调用者是
"global" 作用域还是另一个 shell 函数。 这也是一个局部变量声明 "shadows" 的值，也是函数返回时恢复的值。
.PP
例如，如果变量 \fIvar\fP 在函数 \fIfunc1\fP 中被声明为局部变量，并且 \fIfunc1\fP 调用另一个函数 \fIfunc2\fP，则从
\fIfunc2\fP 中对 \fIvar\fP 的引用将从 \fIfunc1\fP 解析为局部变量 \fIvar\fP，隐藏任何名为 \fIvar\fP 的全局变量。
.PP
\fBunset\fP 内置函数也使用相同的动态作用域: 如果变量是当前作用域的局部变量，\fBunset\fP 将取消设置它; 否则 unset
将引用在任何调用操作域中找到的变量，如上所述。 如果当前本地作用域中的变量未设置，它将保持不变，直到它在该作用域中被重置或直到函数返回。
一旦函数返回，变量在前一个函数域中的任何实例都将变得可见。 如果 unset
作用于前一个作用域中的变量，则具有该名称且已被遮蔽的变量的任何实例都将变得可见。
.PP
\fBFUNCNEST\fP 变量，如果设置为大于 0 的数值，则定义最大函数嵌套级别。 超过限制的调用次数导致整个命令停止。
.PP
如果内置命令 \fBreturn\fP 在一个函数中执行，则函数完成并在函数调用后继续执行下一个命令。 与 \fBRETURN\fP
陷阱关联的任何命令都会在执行恢复之前执行。 当一个函数完成时，位置参数和特殊参数 \fB#\fP 的值将恢复到它们在函数执行之前的值。
.PP
函数名称和定义可以与 \fBdeclare\fP 或 \fBtypeset\fP 内置命令的 \fB\-f\fP 选项一起列出。 \fBdeclare\fP 或
\fBtypeset\fP 的 \fB\-F\fP 选项将仅列出函数名称 (如果启用了 \fBextdebug\fP shell 选项，还可以选择列出源文件和行号)。
函数可以导出，以便子外壳自动将它们定义为 \fBexport\fP 内置的 \fB\-f\fP 选项。 可以使用 \fBunset\fP 内置的 \fB\-f\fP
选项删除一个函数定义。
.PP
函数可能是递归的。 \fBFUNCNEST\fP 变量可用于限制函数调用栈的深度并限制函数调用的次数。 默认情况下，递归调用的次数没有限制。
.SH "ARITHMETIC EVALUATION"
shell 允许在某些情况下计算算术表达式 (参见 \fBlet\fP 和 \fBdeclare\fP 内置命令、\fB((\fP 复合命令和 \fBArithmetic Expansion\fP).  评估是在不检查溢出的固定宽度整数中完成的，尽管除以 0 会被捕获并标记为错误。 运算符及其优先级、结合律和值与 C
语言中的相同。 以下运算符列表按同等优先级运算符分组。 级别按优先级递减的顺序列出。
.PP
.PD 0
.TP 
\fIid\fP\fB++ \fP\fIid\fP\fB\-\-\fP
变量后递增和后递减
.TP 
\fB\- +\fP
一元减号和加号
.TP 
\fB++\fP\fIid\fP\fB \-\-\fP\fIid\fP
变量预递增和预递减
.TP 
\fB! ~\fP
逻辑和按位取反
.TP 
\fB**\fP
exponentiation
.TP 
\fB* / %\fP
乘法、除法、余数
.TP 
\fB+ \-\fP
加减法
.TP 
\fB<< >>\fP
左右移位
.TP 
\fB<= >= < >\fP
comparison
.TP 
\fB== !=\fP
平等与不平等
.TP 
\fB&\fP
按位与
.TP 
\fB^\fP
按位异或
.TP 
\fB|\fP
按位或
.TP 
\fB&&\fP
逻辑与
.TP 
\fB||\fP
逻辑或
.TP 
\fIexpr\fP\fB?\fP\fIexpr\fP\fB:\fP\fIexpr\fP
条件运算符
.TP 
\fB= *= /= %= += \-= <<= >>= &= ^= |=\fP
assignment
.TP 
\fIexpr1\fP\fB , \fP\fIexpr2\fP
comma
.PD
.PP
Shell 变量可以作为操作数; 参数扩展在计算表达式之前执行。 在表达式中，shell 变量也可以在不使用参数扩展语法的情况下通过名称引用。
在不使用参数扩展语法的情况下按名称引用时，为 null 或未设置的 shell 变量的计算结果为 0。
变量的值在被引用时作为算术表达式进行计算，或者在对使用 \fBdeclare \-i\fP 赋予 \fIinteger\fP 属性的变量赋值时进行计算。
空值的计算结果为 0。 shell 变量无需打开其 \fIinteger\fP 属性即可在表达式中使用。
.PP
整数常量遵循 C 语言定义，没有后缀或字符常量。 以 0 开头的常量被解释为八进制数。 前导 0x 或 0X 表示十六进制。 否则，数字采用
[\fIbase#\fP]n 形式，其中可选的 \fIbase\fP 是 2 到 64 之间的十进制数，表示算术基数，\fIn\fP 是该基数中的数字。 如果省略
\fIbase#\fP，则使用基数 10。 当指定 \fIn\fP 时，如果需要非数字，则大于 9 的数字按小写字母、大写字母、@、_ 的顺序表示。 如果
\fIbase\fP 小于或等于 36，可以互换使用小写和大写字母来表示 10 到 35 之间的数字。
.PP
运算符按优先顺序计算。 括号中的子表达式首先被评估，并且可以覆盖上面的优先级规则。
.SH "CONDITIONAL EXPRESSIONS"
\fB[[\fP 复合命令以及 \fBtest\fP 和 \fB[\fP 内置命令使用条件表达式来测试文件属性并执行字符串和算术比较。 \fBtest\fP 和 \fB[\fP
命令根据参数的数量确定它们的行为; 有关任何其他特定于命令的操作，请参见这些命令的说明。
.PP
表达式由以下一元或二元原色组成。 \fBBash\fP 对表达式中使用的几个文件名进行特殊处理。 如果运行 \fBbash\fP
的操作系统提供了这些特殊文件，bash 将使用它们; 否则它会在内部用这种行为模拟它们: 如果任何 \fIfile\fP 参数到其中一个主要是
\fI/dev/fd/n\fP 的形式，那么文件描述符 \fIn\fP 被检查。 如果 \fIfile\fP 引用其中一个主项是
\fI/dev/stdin\fP、\fI/dev/stdout\fP 或 \fI/dev/stderr\fP 之一，则分别检查文件描述符 0、1 或 2。
.PP
除非另有说明，否则对文件进行操作的原语遵循符号链接并对链接的目标进行操作，而不是对链接本身进行操作。
.if  t .sp 0.5
.if  n .sp 1
当与 \fB[[\fP 一起使用时，\fB<\fP 和 \fB>\fP 运算符使用当前语言环境按字典顺序排序。 \fBtest\fP 命令使用 ASCII
排序进行排序。
.sp 1
.PD 0
.TP 
\fB\-a \fP\fIfile\fP
如果 \fIfile\fP 存在则为真。
.TP 
\fB\-b \fP\fIfile\fP
如果 \fIfile\fP 存在并且是块特殊文件则为真。
.TP 
\fB\-c \fP\fIfile\fP
如果 \fIfile\fP 存在并且是字符特殊文件，则为真。
.TP 
\fB\-d \fP\fIfile\fP
如果 \fIfile\fP 存在并且是一个目录，则为真。
.TP 
\fB\-e \fP\fIfile\fP
如果 \fIfile\fP 存在则为真。
.TP 
\fB\-f \fP\fIfile\fP
如果 \fIfile\fP 存在并且是常规文件，则为真。
.TP 
\fB\-g \fP\fIfile\fP
如果 \fIfile\fP 存在并且是 set\-group\-id 则为真。
.TP 
\fB\-h \fP\fIfile\fP
如果 \fIfile\fP 存在并且是符号链接则为真。
.TP 
\fB\-k \fP\fIfile\fP
如果 \fIfile\fP 存在且其 `粘性` 位已设置，则为真。
.TP 
\fB\-p \fP\fIfile\fP
如果 \fIfile\fP 存在并且是命名管道 (FIFO)，则为真。
.TP 
\fB\-r \fP\fIfile\fP
如果 \fIfile\fP 存在且可读则为真。
.TP 
\fB\-s \fP\fIfile\fP
如果 \fIfile\fP 存在且大小大于零，则为真。
.TP 
\fB\-t \fP\fIfd\fP
如果文件描述符 \fIfd\fP 已打开并且指向一个终点，则为真。
.TP 
\fB\-u \fP\fIfile\fP
如果 \fIfile\fP 存在并且设置了它的 set\-user\-id 位则为真。
.TP 
\fB\-w \fP\fIfile\fP
如果 \fIfile\fP 存在且可写则为真。
.TP 
\fB\-x \fP\fIfile\fP
如果 \fIfile\fP 存在且可执行则为真。
.TP 
\fB\-G \fP\fIfile\fP
如果 \fIfile\fP 存在并且由有效组 ID 拥有，则为真。
.TP 
\fB\-L \fP\fIfile\fP
如果 \fIfile\fP 存在并且是符号链接则为真。
.TP 
\fB\-N \fP\fIfile\fP
如果 \fIfile\fP 存在并且自上次读取后已被修改，则为真。
.TP 
\fB\-O \fP\fIfile\fP
如果 \fIfile\fP 存在并且由有效用户 ID 拥有，则为真。
.TP 
\fB\-S \fP\fIfile\fP
如果 \fIfile\fP 存在并且是套接字则为真。
.TP 
\fIfile1\fP \fB\-ef\fP \fIfile2\fP
如果 \fIfile1\fP 和 \fIfile2\fP 引用相同的设备和 inode 编号，则为真。
.TP 
\fIfile1\fP \-\fBnt\fP \fIfile2\fP
如果 \fIfile1\fP 比 \fIfile2\fP 更新 (根据修改日期)，或者如果 \fIfile1\fP 存在而 \fIfile2\fP 不存在，则为真。
.TP 
\fIfile1\fP \-\fBot\fP \fIfile2\fP
如果 \fIfile1\fP 早于 \fIfile2\fP，或者 \fIfile2\fP 存在而 \fIfile1\fP 不存在，则为真。
.TP 
\fB\-o \fP\fIoptname\fP
如果启用了 shell 选项 \fIoptname\fP，则为真。 请参见下面 \fBset\fP 内置的 \fB\-o\fP 选项说明下的选项列表。
.TP 
\fB\-v \fP\fIvarname\fP
如果设置了 shell 变量 \fIvarname\fP (已分配一个值)，则为真。
.TP 
\fB\-R \fP\fIvarname\fP
如果设置了 shell 变量 \fIvarname\fP 并且是名称引用则为真。
.TP 
\fB\-z \fP\fIstring\fP
如果 \fIstring\fP 的长度为零，则为真。
.TP 
\fIstring\fP
.PD 0
.TP 
\fB\-n \fP\fIstring\fP
.PD
如果 \fIstring\fP 的长度不为零，则为真。
.TP 
\fIstring1\fP \fB==\fP \fIstring2\fP
.PD 0
.TP 
\fIstring1\fP \fB=\fP \fIstring2\fP
.PD
如果字符串相等则为真。 \fB=\fP 应与 \fBtest\fP 命令一起使用，以实现 POSIX 一致性。 当与 \fB[[\fP 命令一起使用时，这将执行上述
(\fBCompound Commands\fP) 中描述的模式匹配。
.TP 
\fIstring1\fP \fB!=\fP \fIstring2\fP
如果字符串不相等则为真。
.TP 
\fIstring1\fP \fB<\fP \fIstring2\fP
如果 \fIstring1\fP 按字典顺序排序在 \fIstring2\fP 之前，则为真。
.TP 
\fIstring1\fP \fB>\fP \fIstring2\fP
如果 \fIstring1\fP 按字典顺序在 \fIstring2\fP 之后排序，则为真。
.TP 
\fIarg1 \fP\fBOP\fP\fI arg2\fP
.SM
\fBOP\fP 是 \fB\-eq\fP、\fB\-ne\fP、\fB\-lt\fP、\fB\-le\fP、\fB\-gt\fP 或 \fB\-ge\fP 之一。 如果 \fIarg1\fP
等于、不等于、小于、小于或等于、大于或大于或等于 \fIarg2\fP，则这些算术二进制运算符分别返回真。 \fIArg1\fP 和 \fIarg2\fP 可以是正整数或
Z0 负整数。 当与 \fB[[\fP 命令一起使用时，\fIArg1\fP 和 \fIArg2\fP 被计算为算术表达式 (参见上面的
.SM
\fBARITHMETIC EVALUATION\fP)。
.PD
.SH "SIMPLE COMMAND EXPANSION"
当执行一个简单的命令时，shell 会按照以下顺序从左到右执行以下扩展、赋值和重定向。
.IP 1.
解析器标记为变量赋值 (命令名称前面的那些) 和重定向的词被保存以供以后处理。
.IP 2.
不是变量赋值或重定向的词被扩展。 如果扩展后还有单词，则第一个单词作为命令名称，其余单词为参数。
.IP 3.
重定向按照上面
.SM
\fBREDIRECTION\fP 下的描述执行。
.IP 4.
每个变量赋值中 \fB=\fP 之后的文本在分配给变量之前会经历波浪号扩展、参数扩展、命令替换、算术扩展和引号删除。
.PP
如果没有命令名称结果，则变量赋值会影响当前的 shell 环境。 否则，变量会添加到执行命令的环境中，不会影响当前的 shell 环境。
如果任何赋值尝试将值赋给只读变量，则会发生错误，并且命令以非零状态退出。
.PP
如果没有命令名称结果，则执行重定向，但不影响当前的 shell 环境。 重定向错误导致命令以非零状态退出。
.PP
如果扩展后有命令名，则执行如下所述。 否则，命令退出。 如果其中一个扩展包含命令替换，则该命令的退出状态是执行的最后一个命令替换的退出状态。
如果没有命令替换，命令以零状态退出。
.SH "COMMAND EXECUTION"
将命令拆分为单词后，如果它生成一个简单的命令和一个可选的参数列表，则会执行以下操作。
.PP
如果命令名称不包含斜杠，则 shell 会尝试定位它。 如果存在同名的 shell 函数，则如上文
.SM
\fBFUNCTIONS\fP
中所述调用该函数。 如果名称不匹配一个函数，则 shell 在 shell 内置列表中搜索它。 如果找到匹配项，则调用该内置函数。
.PP
如果名称既不是 shell 函数也不是内置函数，并且不包含斜杠，则 \fBbash\fP 搜索
.SM
\fBPATH\fP
的每个元素以查找包含该名称的可执行文件的目录。 \fBBash\fP 使用哈希表来记住可执行文件的完整路径名 (参见下面
.SM
\fBSHELL BUILTIN COMMANDS\fP 下的 \fBhash\fP)。 只有在哈希表中找不到命令时，才会对
.SM
\fBPATH\fP 中的目录进行完整搜索。
如果搜索不成功，shell 将搜索一个名为 \fBcommand_not_found_handle\fP 的定义的 shell 函数。
如果该函数存在，则在单独的执行环境中调用它，原始命令和原始命令的参数作为它的参数，函数的退出状态成为该子 shell 的退出状态。 如果未定义该数，则
shell 会打印一条错误消息并返回退出状态 127。
.PP
如果搜索成功，或者如果命令名称包含一个或多个斜杠，则 shell 会在单独的执行环境中执行指定的程序。 参数 0
设置为给定的名称，命令的其余参数设置为给定的参数 (如果有)。
.PP
如果由于文件不是可执行格式而导致执行失败，并且文件不是目录，则假定为 \fIshell script\fP，即包含 shell 命令的文件。 生成一个子
shell 来执行它。 这个子 shell 重新初始化自己，这样效果就好像调用了一个新的 shell 来处理脚本，除了父级记住的命令位置 (参见下面
.SM
\fBSHELL BUILTIN COMMANDS\fP) 下的 \fBhash\fP 由子级保留。
.PP
如果程序是以 \fB#!\fP 开头的文件，则第一行的其余部分指定程序的解释器。 shell 在本身不处理这种可执行格式的操作系统上执行指定的解释器。
解释器的参数由一个可选的参数组成，在程序第一行的解释器名称之后，然后是程序的名称，然后是命令参数，如果有的话。
.SH "COMMAND EXECUTION ENVIRONMENT"
shell 有一个 \fIexecution environment\fP，它由以下部分组成:
.IP \(bu
在调用时打开由 shell 继承的文件，由提供给 \fBexec\fP 内置的重定向修改
.IP \(bu
当前工作目录，由 \fBcd\fP、\fBpushd\fP 或 \fBpopd\fP 设置，或在调用时由 shell 继承
.IP \(bu
由 \fBumask\fP 设置或从 shell 的父级继承的文件创建模式掩码
.IP \(bu
\fBtrap\fP 设置的电流陷阱
.IP \(bu
通过变量赋值或 \fBset\fP 或从环境中的 shell 的父级继承的 shell 参数
.IP \(bu
shell 函数在执行期间定义或从环境中的 shell 的父级继承
.IP \(bu
调用时启用的选项 (默认情况下或使用命令行参数) 或 \fBset\fP
.IP \(bu
\fBshopt\fP 启用的选项
.IP \(bu
shell 用 \fBalias\fP 定义的别名
.IP \(bu
各种进程 ID，包括后台作业的 ID、\fB$$\fP 的值和
.SM
\fBPPID\fP 的值
.PP
当要执行除内置命令或 shell 函数以外的简单命令时，将在由以下内容组成的单独执行环境中调用它。 除非另有说明，否则这些值是从 shell 继承的。
.if  n .sp 1
.IP \(bu
shell 的打开文件，加上重定向到命令指定的任何修改和添加
.IP \(bu
当前工作目录
.IP \(bu
文件创建模式掩码
.IP \(bu
shell 变量和函数标记为导出，以及为命令导出的变量，在环境中传递
.IP \(bu
shell 捕获的陷阱被重置为从 shell 的父级继承的值，shell 忽略的陷阱被忽略
.PP
在此单独环境中调用的命令不会影响 shell 的执行环境。
.PP
命令替换、用括号分组的命令和异步命令在与 shell 环境重复的子 shell 环境中调用，除了 shell 捕获的陷阱被重置为 shell
在调用时从其父级继承的值。 作为管道的一部分调用的内置命令也在子 shell 环境中执行。 对子 shell 环境所做的更改不会影响 shell
的执行环境。
.PP
为执行命令替换而生成的子 shell 从父 shell 继承 \fB\-e\fP 选项的值。 当不在 \fIposix mode\fP 中时，\fBbash\fP
会清除此类子外壳中的 \fB\-e\fP 选项。
.PP
如果命令后跟 \fB&\fP 并且作业控制未激活，则该命令的默认标准输入是空文件 \fI/dev/null\fP。 否则，调用的命令会继承调用 shell
的文件描述符，如重定向所修改的那样。
.SH ENVIRONMENT
当程序被调用时，它会得到一个名为 \fIenvironment\fP 的字符串数组。 这是 \fIname\fP\-\fIvalue\fP 对的列表，形式为
\fIname\fP=\fIvalue\fP。
.PP
shell 提供了几种操纵环境的方法。 在调用时，shell 扫描它自己的环境并为找到的每个名称创建一个参数，自动将其标记为 \fIexport\fP
给子进程。 执行的命令继承环境。 \fBexport\fP 和 \fBdeclare \-x\fP 命令允许在环境中添加和删除参数和函数。
如果修改了环境中参数的值，新值将成为环境的一部分，取代旧值。 任何执行的命令继承的环境包括 shell 的初始环境，其值可以在 shell 中修改，减去
\fBunset\fP 命令删除的任何对，加上通过 \fBexport\fP 和 \fBdeclare \-x\fP 命令添加的任何对。
.PP
任何 \fIsimple command\fP 或函数的环境都可以通过在其前面加上参数分配来临时扩充，如上文
.SM
\fBPARAMETERS\fP
中所述。 这些赋值语句只影响该命令看到的环境。
.PP
如果设置了 \fB\-k\fP 选项 (请参见下面的 \fBset\fP 内置命令)，则 \fIall\fP
参数分配将放置在命令的环境中，而不仅仅是那些在命令名称之前的参数。
.PP
当 \fBbash\fP 调用外部命令时，变量 \fB_\fP 被设置为命令的完整文件名，并在其环境中传递给该命令。
.SH "EXIT STATUS"
执行命令的退出状态是 \fIwaitpid\fP 系统调用或等价函数返回的值。 退出状态介于 0 和 255 之间，但是，如下所述，shell 可能会特别使用
125 以上的值。 shell 内置命令和复合命令的退出状态也限制在这个范围内。 在某些情况下，shell 将使用特殊值来指示特定的故障模式。
.PP
出于 shell 的目的，以零退出状态退出的命令已成功。 退出状态为零表示成功。 非零退出状态表示失败。 当命令因致命信号 \fIN\fP
而终止时，\fBbash\fP 使用 128+\fIN\fP 的值作为退出状态。
.PP
如果未找到命令，则为执行该命令而创建的子进程将返回状态 127。 如果找到命令但不可执行，则返回状态为 126。
.PP
如果命令因扩展或重定向期间的错误而失败，则退出状态大于零。
.PP
Shell 内置命令如果成功则返回状态 0 (\fItrue\fP)，如果执行时发生错误则返回非零 (\fIfalse\fP)。 所有内置函数都返回退出状态 2
以指示使用不正确，通常是无效选项或缺少参数。
.PP
\fBBash\fP 本身返回最后执行的命令的退出状态，除非发生语法错误，在这种情况下它以非零值退出。 另请参见下面的 \fBexit\fP 内置命令。
.SH SIGNALS
当 \fBbash\fP 是交互式的，在没有任何陷阱的情况下，它会忽略
.SM
\fBSIGTERM\fP (这样 \fBkill 0\fP 就不会杀死一个交互式的
shell)，并且捕获并处理
.SM
\fBSIGINT\fP (这样内置的 \fBwait\fP 是可中断的)。 在所有情况下，\fBbash\fP 都会忽略
.SM
\fBSIGQUIT\fP。 如果作业控制有效，\fBbash\fP 将忽略
.SM
\fBSIGTTIN\fP、
.SM
\fBSIGTTOU\fP
和
.SM
\fBSIGTSTP\fP。
.PP
\fBbash\fP 运行的非内置命令将信号处理程序设置为 shell 从其父级继承的值。 当作业控制无效时，除了这些继承的处理程序外，异步命令还会忽略
.SM
\fBSIGINT\fP 和
.SM
\fBSIGQUIT\fP。 由于命令替换而运行的命令会忽略键盘生成的作业控制信号
.SM
\fBSIGTTIN\fP、
.SM
\fBSIGTTOU\fP 和
.SM
\fBSIGTSTP\fP。
.PP
shell 在收到
.SM
\fBSIGHUP\fP 时默认退出。 在退出之前，交互式 shell 将
.SM
\fBSIGHUP\fP
重新发送到所有正在运行或已停止的作业。 停止的作业被发送
.SM
\fBSIGCONT\fP 以确保它们收到
.SM
\fBSIGHUP\fP。 为防止
shell 向特定作业发送信号，应使用 \fBdisown\fP 内置函数将其从作业表中删除 (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP) 或使用 \fBdisown \-h\fP 标记为不接收
.SM
\fBSIGHUP\fP。
.PP
如果已使用 \fBshopt\fP 设置 \fBhuponexit\fP shell 选项，则当交互式登录 shell 退出时，\fBbash\fP 会向所有作业发送
.SM
\fBSIGHUP\fP。
.PP
如果 \fBbash\fP 正在等待命令完成并接收到已设置陷阱的信号，则在命令完成之前不会执行陷阱。 当 \fBbash\fP 正在通过 \fBwait\fP
内置等待异步命令时，接收到已设置陷阱的信号将导致 \fBwait\fP 内置立即返回并返回大于 128 的退出状态，然后立即执行陷阱。
.SH "JOB CONTROL"
\fIJob control\fP 指的是有选择地停止 (\fIsuspend\fP) 进程的执行并在稍后继续 (\fIresume\fP) 它们的执行的能力。
用户通常通过操作系统内核的最终驱动程序和 \fBbash\fP 共同提供的交互界面来使用此功能。
.PP
shell 将 \fIjob\fP 与每个管道相关联。 它保留一个当前正在执行的作业表，可以用 \fBjobs\fP 命令列出。 当 \fBbash\fP 异步启动作业时
(在 \fIbackground\fP) 中，它会打印如下一行:
.RS
.PP
[1] 25647
.RE
.PP
表示此作业是作业号 1，并且与此作业关联的管道中最后一个进程的进程 ID 是 25647。 单个管道中的所有进程都是同一作业的成员。 \fBBash\fP
使用 \fIjob\fP 抽象作为作业控制的基础。
.PP
为了便于实现作业控制的用户界面，操作系统保留了 \fIcurrent terminal process group ID\fP 的概念。 该进程组的成员
(进程组 ID 等于当前最终进程组 ID 的进程) 接收键盘产生的信号，如
.SM
\fBSIGINT\fP。 据说这些进程在
\fIforeground\fP 中。 \fIBackground\fP 进程是那些其进程组 ID 不同于最终端的进程; 这样的过程不受键盘产生的信号的影响。
只允许前台进程读取，或者，如果用户使用 \f(CWstty tostop\fP 指定，则写入终端。 试图读取 (当 \f(CWstty tostop\fP 生效时写入)
终端的后台进程会被内核的终端驱动程序发送一个
.SM
\fBSIGTTIN (SIGTTOU)\fP 信号，除非被捕获，否则该进程将挂起该进程。
.PP
如果运行 \fBbash\fP 的操作系统支持作业控制，则 \fBbash\fP 包含使用它的工具。 在进程运行时键入 \fIsuspend\fP 字符 (通常为
\fB^Z\fP、Control\-Z) 会导致该进程停止并将控制返回给 \fBbash\fP。 键入 \fIdelayed suspend\fP 字符 (通常是
\fB^Y\fP，Control\-Y) 会导致进程在尝试从最终端读取输入时停止，并且控制权将返回到 \fBbash\fP。 然后用户可以操纵该作业的状态，使用
\fBbg\fP 命令在后台继续它，使用 \fBfg\fP 命令在前台继续它，或者使用 \fBkill\fP 命令终止它。 \fB^Z\fP
立即生效，并具有导致挂起输出和提前输入被丢弃的额外副作用。
.PP
在 shell 中有很多方法可以引用作业。 字符 \fB%\fP 引入了工作规范 (\fIjobspec\fP)。 作业编号 \fIn\fP 可能被称为 \fB%n\fP。
还可以使用用于启动它的名称的前缀，或使用出现在其命令行中的子字符串来引用作业。 例如，\fB%ce\fP 表示命令名称以 \fBce\fP 开头的已停止作业。
如果前缀匹配多个作业，则 \fBbash\fP 报告错误。 另一方面，使用 \fB%?ce\fP 是指在其命令行中包含字符串 \fBce\fP 的任何作业。
如果子字符串匹配多个作业，则 \fBbash\fP 报告错误。 符号 \fB%%\fP 和 \fB%+\fP 指的是 shell 对 \fIcurrent job\fP
的概念，这是在前台或后台启动时停止的最后一个作业。 可以使用 \fB%\-\fP 引用 \fIprevious job\fP。 如果只有一个作业，\fB%+\fP 和
\fB%\-\fP 都可以用来指代那个作业。 在与作业相关的输出中 (例如，\fBjobs\fP 命令的输出)，当前作业始终标记为 \fB+\fP，而前一个作业标记为
\fB\-\fP。 单个 % (没有随附的工作规范) 也指当前工作。
.PP
只需简单地命名一个作业就可以将其调到前台: \fB%1\fP 是 \fB\*(lqfg %1\*(rq\fP 的同义词，将作业 1 从后台调到前台。 同样，\fB\*(lq%1 &\*(rq\fP 在后台恢复 job 1，相当于 \fB\*(lqbg %1\*(rq\fP。
.PP
只要作业更改状态，shell 就会立即学习。 通常，\fBbash\fP 会等到即将打印提示时再报告作业状态的变化，以免中断任何其他输出。 如果启用
\fBset\fP 内置命令的 \fB\-b\fP 选项，\fBbash\fP 会立即报告此类更改。
.SM
\fBSIGCHLD\fP
上的任何陷阱都会为每个退出的子节点执行。
.PP
如果在作业停止时尝试退出 \fBbash\fP (或者，如果使用内置的 \fBshopt\fP 启用了 \fBcheckjobs\fP shell 选项，正在运行)，则
shell 会打印一条警告消息，并且如果启用了 \fBcheckjobs\fP 选项，则会列出作业以及他们的状态。 然后可以使用 \fBjobs\fP
命令检查它们的状态。 如果在没有干预命令的情况下第二次尝试退出，则 shell 不会打印另一个警告，并且终止任何已停止的作业。
.PP
当 shell 正在等待使用 \fBwait\fP 内置的作业或进程，并且启用了作业控制时，\fBwait\fP 将在作业更改状态时返回。\fB\-f\fP 选项使
\fBwait\fP 等到作业或进程终止后再返回。
.SH PROMPTING
交互执行时，\fBbash\fP 在准备读取命令时显示一级提示符
.SM
\fBPS1\fP，在需要更多输入完成命令时显示二级提示符
.SM
\fBPS2\fP。 \fBBash\fP 在读取命令之后但在执行命令之前显示
.SM
\fBPS0\fP。 当启用 \fB\-x\fP 选项时，\fBBash\fP
在跟踪每个命令之前如上所述显示
.SM
\fBPS4\fP。 \fBBash\fP
允许通过插入一些反斜杠转义的特殊字符来自定义这些提示字符串，这些特殊字符被解码如下:
.RS
.PD 0
.TP 
\fB\ea\fP
一个 ASCII 铃字符 (07)
.TP 
\fB\ed\fP
"Weekday Month Date" 格式的日期 (例如 "Tue May 26")
.TP 
\fB\eD{\fP\fIformat\fP\fB}\fP
\fIformat\fP 传递给 \fIstrftime\fP(3)，结果插入到提示字符串中; 空的 \fIformat\fP 会导致特定于语言环境的时间表示。
大括号是必需的
.TP 
\fB\ee\fP
ASCII 转义字符 (033)
.TP 
\fB\eh\fP
主机名到第一个 '.'
.TP 
\fB\eH\fP
主机名
.TP 
\fB\ej\fP
当前由 shell 管理的作业数
.TP 
\fB\el\fP
shell 终端设备名称的基本名称
.TP 
\fB\en\fP
newline
.TP 
\fB\er\fP
回车
.TP 
\fB\es\fP
shell 的名称，\fB$0\fP 的基本名称 (最后一个斜杠后面的部分)
.TP 
\fB\et\fP
24 小时制 HH:MM:SS 格式的当前时间
.TP 
\fB\eT\fP
12 小时制 HH:MM:SS 格式的当前时间
.TP 
\fB\e@\fP
12 小时制 am/pm 格式的当前时间
.TP 
\fB\eA\fP
24 小时制 HH:MM 格式的当前时间
.TP 
\fB\eu\fP
当前用户的用户名
.TP 
\fB\ev\fP
\fBbash\fP 的版本 (例如 2.00)
.TP 
\fB\eV\fP
\fBbash\fP 的发布，版本 + 补丁级别 (例如，2.00.0)
.TP 
\fB\ew\fP
当前工作目录，
.SM
\fB$HOME\fP 缩写为波浪号 (使用
.SM
\fBPROMPT_DIRTRIM\fP 变量的值)
.TP 
\fB\eW\fP
当前工作目录的基本名称，
.SM
\fB$HOME\fP 缩写为波浪号
.TP 
\fB\e!\fP
该命令的历史编号
.TP 
\fB\e#\fP
该命令的命令号
.TP 
\fB\e$\fP
如果有效 UID 为 0，则为 \fB#\fP，否则为 \fB$\fP
.TP 
\fB\e\fP\fInnn\fP
八进制数 \fInnn\fP 对应的字符
.TP 
\fB\e\e\fP
反斜杠
.TP 
\fB\e[\fP
开始一系列非打印字符，可用于将最终控制序列嵌入到提示中
.TP 
\fB\e]\fP
结束一系列非打印字符
.PD
.RE
.PP
命令号和历史号通常是不同的: 命令的历史号是它在历史列表中的位置，可能包括从历史文件中恢复的命令 (见下面的
.SM
\fBHISTORY\fP)，而命令号是在历史文件中的位置在当前 shell 会话期间执行的命令序列。
字符串解码后，通过参数扩展、命令替换、算术扩展、去掉引号等方式进行扩展，以 \fBpromptvars\fP shell 选项的值为准 (见下文
.SM
\fBSHELL BUILTIN COMMANDS\fP 下 \fBshopt\fP 命令的说明)。
如果字符串的转义部分出现在命令替换中或包含单词扩展的特殊字符，这可能会产生不需要的副作用。
.SH READLINE
这是在使用交互式 shell 时处理读取输入的库，除非在 shell 调用时给出了 \fB\-\-noediting\fP 选项。 当使用 \fBread\fP 内置的
\fB\-e\fP 选项时，也使用行编辑。 默认情况下，行编辑命令类似于 Emacs。 还提供了 vi 风格的行编辑界面。 使用内置 \fBset\fP 的 \fB\-o emacs\fP 或 \fB\-o vi\fP 选项可以随时启用行编辑 (请参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。 要在
shell 运行后关闭行编辑，请使用内置 \fBset\fP 的 \fB+o emacs\fP 或 \fB+o vi\fP 选项。
.SS "Readline Notation"
在本节中，Emacs 风格的符号用于表示击键。 控制键用 C\-\fIkey\fP 表示，例如，C\-n 表示 Control\-N。 同样，\fImeta\fP 密钥由
M\-\fIkey\fP 表示，因此 M\-x 表示 Meta\-X。 (在没有 \fImeta\fP 键的键盘上，M\-\fIx\fP 表示 ESC \fIx\fP，即按
Escape 键，然后按 \fIx\fP 键。这使 ESC 成为 \fImeta prefix\fP。组合 M\-C\-\fIx\fP 表示
ESC\-Control\-\fIx\fP，或者按下 Escape 键，然后按住 Control 键，同时按下 \fIx\fP 钥匙。)
.PP
Readline 命令可以被赋予数字 \fIarguments\fP，它通常作为重复计数。 然而，有时，重要的是参数的符号。 将 negative
参数传递给正向作用的命令 (例如，\fBkill\-line\fP) 导致该命令反向作用。 与参数行为不同的命令如下所示。
.PP
当命令被描述为 \fIkilling\fP 文本时，删除的文本将被保存以备可能的 future 检索 (\fIyanking\fP)。 杀死的文本保存在
\fIkill ring\fP 中。 连续击杀会使文字累积为一个元，可以一次性全部抽出。 不终止文本的命令将终止环上的文本块分开。
.SS "Readline Initialization"
通过将命令放入初始化文件 (\fIinputrc\fP 文件) 来自定义 Readline。 该文件的名称取自
.SM
\fBINPUTRC\fP 变量的值。
如果未设置该变量，则默认值为 \fI~/.inputrc\fP。 如果该文件不存在或无法读取，最终默认为 \fI/etc/inputrc\fP。 当使用
readline 库的程序启动时，会读取初始化文件，并设置键绑定和变量。 readline 初始化文件中只允许使用一些基本结构。 空行被忽略。 以
\fB#\fP 开头的行是注释。 以 \fB$\fP 开头的行表示条件构造。 其他行表示键绑定和变量设置。
.PP
可以使用 \fIinputrc\fP 文件更改默认键绑定。 使用此库的其他程序可能会添加自己的命令和绑定。
.PP
例如，放置
.RS
.PP
M\-Control\-u: 通用参数
.RE
or
.RS
C\-Meta\-u: 通用参数
.RE
进入 \fIinputrc\fP 将使 MCu 执行 readline 命令 \fIuniversal\-argument\fP。
.PP
可识别以下符号字符名称:
\fIRUBOUT\fP、\fIDEL\fP、\fIESC\fP、\fILFD\fP、\fINEWLINE\fP、\fIRET\fP、\fIRETURN\fP、\fISPC\fP、\fISPACE\fP 和
\fITAB\fP。
.PP
除了命令名称之外，readline 还允许将键绑定到按下键时插入的字符串 (\fImacro\fP).
.SS "Readline Key Bindings"
\fIinputrc\fP 文件中控制键绑定的语法很简单。 所需要的只是命令的名称或宏的文本以及它应该绑定到的键序列。 该名称可以通过以下两种方式之一指定:
作为符号键名称，可能带有 \fIMeta\-\fP 或 \fIControl\-\fP 前缀，或作为键序列。
.PP
当使用 \fBkeyname\fP:\^\fIfunction\-name\fP 或 \fImacro\fP 形式时，\fIkeyname\fP 是用英文拼写的密钥名称。 例如:
.sp
.RS
Control\-u: 通用参数
.br
Meta\-Rubout: backward\-kill\-word
.br
Control\-o: "> output"
.RE
.LP
在上面的例子中，\fIC\-u\fP 绑定了任数 \fBuniversal\-argument\fP，\fIM\-DEL\fP 绑定了任数
\fBbackward\-kill\-word\fP，\fIC\-o\fP 绑定了右侧表示的宏 (即插入文字
.if  t \f(CW> output\fP
.if  n ``> output''
入行)。
.PP
在第二种形式中，\fB"keyseq"\fP:\^\fIfunction\-name\fP 或 \fImacro\fP，\fBkeyseq\fP 与上面的 \fBkeyname\fP
的不同之处在于表示整个键序列的字符串可以通过将序列放在双引号内来指定。 可以使用一些 GNU Emacs
样式的键转义，如下例所示，但无法识别符号字符名称。
.sp
.RS
"\eC\-u": 通用参数
.br
"\eC\-x\eC\-r": 重新读取初始化文件
.br
"\ee[11~": "Function Key 1"
.RE
.PP
在此示例中，\fIC\-u\fP 再次绑定到函数 \fBuniversal\-argument\fP。 \fIC\-x C\-r\fP 绑定函数
\fBre\-read\-init\-file\fP，\fIESC [ 1 1 ~\fP 绑定插入文字
.if  t \f(CWFunction Key 1\fP.
.if  n ``Function Key 1''.
.PP
全套 GNU Emacs 风格的转义序列是
.RS
.PD 0
.TP 
\fB\eC\-\fP
控制前缀
.TP 
\fB\eM\-\fP
元前缀
.TP 
\fB\ee\fP
转义字符
.TP 
\fB\e\e\fP
backslash
.TP 
\fB\e"\fP
字面量 "
.TP 
\fB\e\(aq\fP
字面量 \(aq
.RE
.PD
.PP
除了 GNU Emacs 样式的转义序列之外，还有第二组反斜杠转义可用:
.RS
.PD 0
.TP 
\fB\ea\fP
警报 (bell)
.TP 
\fB\eb\fP
backspace
.TP 
\fB\ed\fP
delete
.TP 
\fB\ef\fP
换页
.TP 
\fB\en\fP
newline
.TP 
\fB\er\fP
回车
.TP 
\fB\et\fP
水平制表符
.TP 
\fB\ev\fP
垂直制表符
.TP 
\fB\e\fP\fInnn\fP
值为八进制值 \fInnn\fP (一到三位) 的八位字符
.TP 
\fB\ex\fP\fIHH\fP
值为十六进制值 \fIHH\fP (一个或两个十六进制数字) 的八位字符
.RE
.PD
.PP
输入宏的文本时，必须使用单引号或双引号来表示宏的定义。 未加引号的文本假定为一个函数名称。 在宏体中，上面描述的反斜杠转义被扩展。
反斜杠将引用宏文本中的任何其他字符，包括 " 和 \(aq.
.PP
\fBBash\fP 允许使用 \fBbind\fP 内置命令显示或修改当前的 readline 键绑定。 通过使用 \fBset\fP 内置命令的 \fB\-o\fP
选项，可以在交互使用期间切换编辑模式 (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.SS "Readline Variables"
Readline 具有变量，可用于进一步自定义其行为。 变量可以在 \fIinputrc\fP 文件中设置，格式如下
.RS
.PP
\fBset\fP \fIvariable\-name\fP \fIvalue\fP
.RE
或使用 \fBbind\fP 内置命令 (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。
.PP
除非另有说明，否则 readline 变量可以取值 \fBOn\fP 或 \fBOff\fP (不考虑大小写)。 无法识别的变量名将被忽略。
当读取变量值时，空值或空值，"on" (case\-insensitive) 和 "1" 等同于 \fBOn\fP。 所有其他值都等同于 \fBOff\fP。
变量及其默认值是:
.PP
.PD 0
.TP 
\fBbell\-style (audible)\fP
控制当 readline 想要敲响终点铃时发生的事情。 如果设置为 \fBnone\fP，readline 永远不会响铃。 如果设置为
\fBvisible\fP，readline 将使用一个可见的铃铛 (如果有的话)。 如果设置为 \fBaudible\fP，readline 会尝试敲响终端的铃。
.TP 
\fBbind\-tty\-special\-chars (On)\fP
如果设置为 \fBOn\fP，readline 尝试将内核的终端驱动程序特殊处理的控制字符绑定到它们的 readline 等价物。
.TP 
\fBblink\-matching\-paren (Off)\fP
如果设置为 \fBOn\fP，readline 会尝试在插入右括号时将游标短暂地移动到左括号。
.TP 
\fBcolored\-completion\-prefix (Off)\fP
如果设置为 \fBOn\fP，则在列出补全时，readline 会使用不同的颜色显示可能补全集的公共前缀。 颜色定义取自 \fBLS_COLORS\fP
环境变量的值。
.TP 
\fBcolored\-stats (Off)\fP
如果设置为 \fBOn\fP，readline 会使用不同的颜色显示可能的完成，以指示其文件类型。 颜色定义取自 \fBLS_COLORS\fP 环境变量的值。
.TP 
\fBcomment\-begin (\*(lq#\*(rq)\fP
执行 readline \fBinsert\-comment\fP 命令时插入的字符串。 该命令在 emacs 模式下绑定到 \fBM\-#\fP，在 vi
命令模式下绑定到 \fB#\fP。
.TP 
\fBcompletion\-display\-width (\-1)\fP
执行完成时用于显示可能匹配项的屏幕列数。 如果该值小于 0 或大于最终屏幕宽度，则该值将被忽略。 值为 0 将导致每行显示一个匹配项。 默认值为 \-1。
.TP 
\fBcompletion\-ignore\-case (Off)\fP
如果设置为 \fBOn\fP，readline 将以不区分大小写的方式执行文件名匹配和完成。
.TP 
\fBcompletion\-map\-case (Off)\fP
如果设置为 \fBOn\fP，并且启用了 \fBcompletion\-ignore\-case\fP，则在执行不区分大小写的文件名匹配和完成时，readline
会将连字符 (\fI\-\fP) 和下划线 (\fI_\fP) 视为等效的。
.TP 
\fBcompletion\-prefix\-display\-length (0)\fP
未经修改显示的可能完成列表的公共前缀的字符长度。 当设置为大于零的值时，在显示可能的完成时，长于此值的公共前缀将替换为省略号。
.TP 
\fBcompletion\-query\-items (100)\fP
这决定了何时询问用户查看由 \fBpossible\-completions\fP 命令生成的可能完成的数量。 它可以设置为大于或等于零的任何整数值。
如果可能完成的数量大于或等于该变量的值，readline 将询问用户是否希望查看它们; 否则，它们将简单地列在最终端。
.TP 
\fBconvert\-meta (On)\fP
如果设置为 \fBOn\fP，readline 会将第八位设置为 ASCII 键序列的字符通过剥离第八位并添加转义字符作为前缀 (实际上，使用转义作为
\fImeta prefix\fP).  默认值为 \fIOn\fP，但如果语言环境包含八位字符，readline 会将其设置为 \fIOff\fP。
.TP 
\fBdisable\-completion (Off)\fP
如果设置为 \fBOn\fP，readline 将禁止字完成。 完成字符将被插入到行中，就好像它们已被映射到 \fBself\-insert\fP 一样。
.TP 
\fBecho\-control\-characters (On)\fP
当设置为 \fBOn\fP 时，在表明它们支持它的操作系统上，readline 回显对应于从键盘生成的信号的字符。
.TP 
\fBediting\-mode (emacs)\fP
控制 readline 是否以一组类似于 \fIEmacs\fP 或 \fIvi\fP 的键绑定开始。 \fBediting\-mode\fP 可以设置为 \fBemacs\fP
或 \fBvi\fP。
.TP 
\fBemacs\-mode\-string (@)\fP
如果启用了 \fIshow\-mode\-in\-prompt\fP 变量，则当 emacs 编辑模式处于活动状态时，该字符串会立即显示在主提示的最后一行之前。
该值像键绑定一样扩展，因此可以使用标准的元和控制前缀集以及反斜杠转义序列。 使用 \e1 和 \e2
转义开始和结束非打印字符序列，这可用于将最终控制序列嵌入到模式字符串中。
.TP 
\fBenable\-bracketed\-paste (On)\fP
当设置为 \fBOn\fP 时，readline 将以一种方式配置最终端，使其能够将每个粘贴作为单个字符串插入编辑缓冲区，而不是将每个字符视为从键盘读取。
这可以防止粘贴的字符被解释为编辑命令。
.TP 
\fBenable\-keypad (Off)\fP
当设置为 \fBOn\fP 时，readline 将在调用时尝试启用应用程序键盘。 一些系统需要它来启用箭头键。
.TP 
\fBenable\-meta\-key (On)\fP
当设置为 \fBOn\fP 时，readline 将尝试启用最终端声称在调用时支持的任何元修饰键。 在许多终端上，元密钥用于发送八位字符。
.TP 
\fBexpand\-tilde (Off)\fP
如果设置为 \fBOn\fP，则当 readline 尝试单词完成时执行波浪线扩展。
.TP 
\fBhistory\-preserve\-point (Off)\fP
如果设置为 \fBOn\fP，历史代码会尝试将点放置在使用 \fBprevious\-history\fP 或 \fBnext\-history\fP
检索到的每条历史行的相同位置。
.TP 
\fBhistory\-size (unset)\fP
设置历史列表中保存的最大历史条目数。 如果设置为零，则删除任何现有的历史记录条目并且不保存任何新条目。 如果设置为小于零的值，则历史条目的数量不受限制。
默认情况下，历史条目数设置为 \fBHISTSIZE\fP shell 变量的值。 如果尝试将 \fIhistory\-size\fP
设置为非数字值，则历史条目的最大数量将设置为 500。
.TP 
\fBhorizontal\-scroll\-mode (Off)\fP
当设置为 \fBOn\fP 时，使 readline 使用单行显示，当它变得比屏幕宽度长时，在单个屏幕行上水平滚动输入而不是换行。 此设置会自动为
height 的终端启用 1.
.TP 
\fBinput\-meta (Off)\fP
如果设置为 \fBOn\fP，readline 将启用八位输入 (即，它不会从读取的字符中去除第八位)，无论最终端声称它可以支持什么。 名称
\fBmeta\-flag\fP 是此变量的同义词。 默认值为 \fIOff\fP，但如果语言环境包含八位字符，readline 会将其设置为 \fIOn\fP。
.TP 
\fBisearch\-terminators (\*(lqC\-[C\-J\*(rq)\fP
应该终止增量搜索而不随后将字符作为命令执行的字符串。 如果这个变量没有被赋值，字符 \fIESC\fP 和 \fIC\-J\fP 将终止增量搜索。
.TP 
\fBkeymap (emacs)\fP
设置当前的 readline 键盘映射。 有效的键映射名称集是 \fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi, vi\-command\fP 和 \fIvi\-insert\fP。 \fIvi\fP 等同于 \fIvi\-command\fP;
\fIemacs\fP 等同于 \fIemacs\-standard\fP。 默认值为 \fIemacs\fP; \fBediting\-mode\fP 的值也会影响默认键盘映射。
.TP 
\fBkeyseq\-timeout (500)\fP
指定 \fIreadline\fP 在读取不明确的键序列时等待字符的持续时间
(可以使用到目前为止的输入读取形成完整的键序列，或者可以采用额外的输入来完成更长的键序列)。 如果在超时时间内没有收到输入，\fIreadline\fP
将使用较短但完整的键序列。 该值以毫秒为单位指定，因此值为 1000 意味着 \fIreadline\fP 将等待一秒钟以等待其他输入。
如果此变量设置为小于或等于零的值，或者设置为非数字值，则 \fIreadline\fP 将等待直到按下另一个键来决定完成哪个键序列。
.TP 
\fBmark\-directories (On)\fP
如果设置为 \fBOn\fP，完整的目录名称将，追加，一个斜杠。
.TP 
\fBmark\-modified\-lines (Off)\fP
如果设置为 \fBOn\fP，则显示已修改的历史记录行时前面带有星号 (\fB*\fP)。
.TP 
\fBmark\-symlinked\-directories (Off)\fP
如果设置为 \fBOn\fP，作为目录符号链接的完整名称将，追加，一个斜杠 (受 \fBmark\-directories\fP) 的值限制)。
.TP 
\fBmatch\-hidden\-files (On)\fP
当设置为 \fBOn\fP 时，此变量会导致 readline 匹配名称以 `.` 开头的文件。(隐藏文件) 执行文件名完成时。如果设置为 \fBOff\fP，前导
`.' 必须由用户在要完成的文件名中提供。
.TP 
\fBmenu\-complete\-display\-prefix (Off)\fP
如果设置为 \fBOn\fP，菜单完成会在循环列表之前显示可能完成列表的公共前缀 (可能为空)。
.TP 
\fBoutput\-meta (Off)\fP
如果设置为 \fBOn\fP，readline 将显示第八位直接设置的字符，而不是作为元前缀转义序列。 默认值为
\fIOff\fP，但如果语言环境包含八位字符，readline 会将其设置为 \fIOn\fP。
.TP 
\fBpage\-completions (On)\fP
如果设置为 \fBOn\fP，readline 使用内部 \fImore\fP\-like 寻呼机一次显示一屏可能的完成。
.TP 
\fBprint\-completions\-horizontally (Off)\fP
如果设置为 \fBOn\fP，readline 将显示匹配项的完成，这些匹配项按字母顺序水平排序，而不是在屏幕下方。
.TP 
\fBrevert\-all\-at\-newline (Off)\fP
如果设置为 \fBOn\fP，当执行 \fBaccept\-line\fP 时，readline 将在返回之前撤消对历史行的所有更改。
默认情况下，可以修改历史行并在对 \fBreadline\fP 的调用中保留单个撤消列表。
.TP 
\fBshow\-all\-if\-ambiguous (Off)\fP
这改变了完成函数的默认行为。 如果设置为 \fBOn\fP，具有不止一种可能完成的单词会导致立即列出匹配项而不是响铃。
.TP 
\fBshow\-all\-if\-unmodified (Off)\fP
这会以类似于 \fBshow\-all\-if\-ambiguous\fP 的方式改变完成函数的默认行为。 如果设置为
\fBOn\fP，具有多个可能完成但没有任何可能部分完成 (可能完成不共享公共前缀) 的单词会导致立即列出匹配项而不是响铃。
.TP 
\fBshow\-mode\-in\-prompt (Off)\fP
如果设置为 \fBOn\fP，则在提示的开头添加一个字符串，指示编辑模式: emacs、vi 命令或 vi 插入。 模式字符串是用户可设置的
(例如，\fIemacs\-mode\-string\fP).
.TP 
\fBskip\-completed\-text (Off)\fP
如果设置为 \fBOn\fP，这将改变在行中插入单个匹配项时的默认完成行为。 它仅在单词中间执行补全时有效。 如果启用，则 readline
不会插入与要完成的单词中点之后的字符匹配的完成字符，因此不会复制游标后面的单词部分。
.TP 
\fBvi\-cmd\-mode\-string ((cmd))\fP
如果启用了 \fIshow\-mode\-in\-prompt\fP 变量，则当 vi
编辑模式处于活动状态且处于命令模式时，该字符串会立即显示在主提示符的最后一行之前。
该值像键绑定一样扩展，因此可以使用标准的元和控制前缀集以及反斜杠转义序列。 使用 \e1 和 \e2
转义开始和结束非打印字符序列，这可用于将最终控制序列嵌入到模式字符串中。
.TP 
\fBvi\-ins\-mode\-string ((ins))\fP
如果启用了 \fIshow\-mode\-in\-prompt\fP 变量，则当 vi
编辑模式处于活动状态且处于插入模式时，该字符串会立即显示在主提示符的最后一行之前。
该值像键绑定一样扩展，因此可以使用标准的元和控制前缀集以及反斜杠转义序列。 使用 \e1 和 \e2
转义开始和结束非打印字符序列，这可用于将最终控制序列嵌入到模式字符串中。
.TP 
\fBvisible\-stats (Off)\fP
如果设置为 \fBOn\fP，则在列出可能的完成时，表示 \fIstat\fP(2) 报告的文件类型的字符将追加到文件名。
.PD
.SS "Readline Conditional Constructs"
Readline 实现了一种在本质上类似于 C 预处理器的条件编译特性的 特性它允许作为测试结果执行键绑定和变量设置。 使用了四个解析器指令。
.IP \fB$if\fP
The
\fB$if\fP
构造允许绑定基于
编辑模式，正在使用的终端，或正在使用的应用程序
阅读线。测试文本，在任何比较运算符之后，
 延伸到行尾;
除非另有说明，否则不需要任何字符来隔离它。
.RS
.IP \fBmode\fP
\fB$if\fP 指令的 \fBmode=\fP 形式用于测试 readline 是处于 emacs 还是 vi 模式。 这可以与 \fBset keymap\fP
命令结合使用，例如，仅当 readline 以 emacs 模式启动时才在 \fIemacs\-standard\fP 和 \fIemacs\-ctlx\fP
键盘映射中设置绑定。
.IP \fBterm\fP
\fBterm=\fP 形式可用于包含最终端特定的键绑定，可能用于绑定最终端的函数键输出的键序列。 \fB=\fP 右侧的词同时针对最终端的全名和第一个 \fB\-\fP
之前的最终端名称部分进行了测试。 例如，这允许 \fIsun\fP 匹配 \fIsun\fP 和 \fIsun\-cmd\fP。
.IP \fBversion\fP
\fBversion\fP 测试可用于与特定的 readline 版本进行比较。 \fBversion\fP 扩展到当前的 readline 版本。
比较运算符的集合包括 \fB=\fP, (和 \fB==\fP), \fB!=\fP, \fB<=\fP, \fB>=\fP, \fB<\fP, and
\fB>\fP.  运算符右侧提供的版本号由主版本号、可选的小数点和可选的次版本组成 (例如，\fB7.1\fP). 如果省略次要版本，则假定为 \fB0\fP。
运算符可以用空格与字符串 \fBversion\fP 和版本号参数分开。
.IP \fBapplication\fP
\fBapplication\fP 构造用于包含特定于应用程序的设置。 每个使用 readline 库的程序都会设置 \fIapplication name\fP，并且初始化文件可以测试特定值。 这可用于将键序列绑定到对特定程序有用的号码。 例如，以下命令添加一个键序列，引用 \fBbash\fP:
中的当前或上一个词
.sp 1
.RS
.nf
\fB$if\fP 重击
# 引用当前或上一个词
"\eC\-xq": "\eeb\e"\eef\e""
\fB$endif\fP
.fi
.RE
.IP \fIvariable\fP
\fIvariable\fP 构造为 readline 变量和值提供简单的相等性测试。 允许的比较运算符是 \fI=\fP、\fI==\fP 和 \fI!=\fP。
变量名必须用空格与比较运算符分开; 运算符可以用空格与右侧的值分隔开。 string 和 boolean 变量都可以被测试。布尔变量必须针对值
\fIon\fP 和 \fIoff\fP 进行测试。
.RE
.IP \fB$endif\fP
如前面的示例所示，此命令终止 \fB$if\fP 命令。
.IP \fB$else\fP
如果测试失败，则执行 \fB$if\fP 指令的此分支中的命令。
.IP \fB$include\fP
该指令将单个文件名作为参数并从该文件中读取命令和绑定。 例如，以下指令将读取 \fI/etc/inputrc\fP:
.sp 1
.RS
.nf
\fB$include\fP \^ \fI/etc/inputrc\fP
.fi
.RE
.SS Searching
Readline 提供了用于在命令历史记录 (参见下面的
.SM
\fBHISTORY\fP) 中搜索包含指定字符串的行的命令。 有两种搜索模式:
\fIincremental\fP 和 \fInon\-incremental\fP。
.PP
增量搜索在用户完成输入搜索字符串之前开始。 当输入搜索字符串的每个字符时，readline 显示历史记录中与目前输入的字符串匹配的下一个条目。
增量搜索只需要找到所需历史条目所需的字符数。 \fBisearch\-terminators\fP 变量值中出现的字符用于终止增量搜索。 如果该变量未被赋值，则
Escape 和 Control\-J 字符将终止增量搜索。 Control\-G 将停止增量搜索并恢复原始行。
当搜索终止时，包含搜索字符串的历史条目成为当前行。
.PP
要在历史列表中查找其他匹配条目，请根据需要键入 Control\-S 或 Control\-R。
这将在历史记录中向后或向前搜索与目前键入的搜索字符串匹配的下一个条目。 绑定到 readline 命令的任何其他键序列将终止搜索并执行该命令。
例如，\fInewline\fP 将终止搜索并接受该行，从而执行历史列表中的命令。
.PP
Readline 会记住最后一个增量搜索字符串。 如果键入两个 Control\-R 而没有任何中间字符定义新的搜索字符串，则使用任何记住的搜索字符串。
.PP
非增量搜索在开始搜索匹配的历史行之前读取整个搜索字符串。 搜索字符串可以由用户键入，也可以是当前行内容的一部分。
.SS "Readline Command Names"
以下是命令名称的列表以及它们绑定到的默认键序列。 默认情况下未绑定没有附带键序列的命令名称。 下面的说明中，\fIpoint\fP
是指当前游标位置，\fImark\fP 是指 \fBset\-mark\fP 命令保存的游标位置。 点和标记之间的文本称为 \fIregion\fP。
.SS "Commands for Moving"
.PD 0
.TP 
\fBbeginning\-of\-line (C\-a)\fP
移动到当前行的开头。
.TP 
\fBend\-of\-line (C\-e)\fP
移动到行尾。
.TP 
\fBforward\-char (C\-f)\fP
向前移动一个字符。
.TP 
\fBbackward\-char (C\-b)\fP
向后移动一个字符。
.TP 
\fBforward\-word (M\-f)\fP
向前移动到下一个单词的末尾。 单词由字母数字字符 (字母和数字) 组成。
.TP 
\fBbackward\-word (M\-b)\fP
移回当前或上一个单词的开头。 单词由字母数字字符 (字母和数字) 组成。
.TP 
\fBshell\-forward\-word\fP
向前移动到下一个单词的末尾。 单词由非引号 shell 元字符分隔。
.TP 
\fBshell\-backward\-word\fP
移回当前或上一个单词的开头。 单词由非引号 shell 元字符分隔。
.TP 
\fBprevious\-screen\-line\fP
尝试将点移动到前一个物理屏幕行上的同一物理屏幕列。如果当前 Readline
行不占用超过一行的物理行，或者如果点不大于提示的长度加上屏幕宽度，这将不会产生预期的效果。
.TP 
\fBnext\-screen\-line\fP
尝试将点移动到下一个物理屏幕行上的同一物理屏幕列。如果当前 Readline 行不占用超过一行的物理行，或者如果当前 Readline
行的长度不大于提示长度加上屏幕宽度，这将不会产生预期的效果。
.TP 
\fBclear\-display (M\-C\-l)\fP
清除屏幕，如果可能的话，清除终端的回滚缓冲区，然后重新绘制当前行，将当前行留在屏幕顶部。
.TP 
\fBclear\-screen (C\-l)\fP
清除屏幕，然后重新绘制当前行，将当前行留在屏幕顶部。 使用参数，刷新当前行而不清除屏幕。
.TP 
\fBredraw\-current\-line\fP
刷新当前行。
.PD
.SS "Commands for Manipulating the History"
.PD 0
.TP 
\fBaccept\-line (Newline, Return)\fP
无论游标在哪里，都接受该行。 如果这一行不为空，则根据
.SM
\fBHISTCONTROL\fP 变量的状态添加到历史列表中。
如果该行是修改后的历史行，则将历史行恢复到其原始状态。
.TP 
\fBprevious\-history (C\-p)\fP
从历史列表中获取上一个命令，在列表中向后移动。
.TP 
\fBnext\-history (C\-n)\fP
从历史列表中获取下一个命令，在列表中向前移动。
.TP 
\fBbeginning\-of\-history (M\-<)\fP
移动到历史记录的第一行。
.TP 
\fBend\-of\-history (M\->)\fP
移动到输入历史的末尾，即当前正在输入的行。
.TP 
\fBreverse\-search\-history (C\-r)\fP
从当前行开始向后搜索，并根据需要 `向上` 移动历史记录。 这是增量搜索。
.TP 
\fBforward\-search\-history (C\-s)\fP
从当前行开始向前搜索，并根据需要 `向下` 浏览历史记录。 这是增量搜索。
.TP 
\fBnon\-incremental\-reverse\-search\-history (M\-p)\fP
使用对用户提供的字符串的非增量搜索从当前行开始向后搜索历史记录。
.TP 
\fBnon\-incremental\-forward\-search\-history (M\-n)\fP
使用非增量搜索用户提供的字符串向前搜索历史记录。
.TP 
\fBhistory\-search\-forward\fP
在历史中向前搜索当前行的开头和点之间的字符串。 这是一个非增量搜索。
.TP 
\fBhistory\-search\-backward\fP
在历史中向后搜索当前行开头和点之间的字符串。 这是一个非增量搜索。
.TP 
\fBhistory\-substring\-search\-backward\fP
在历史记录中向后搜索当前行开头和当前游标位置之间的字符串 (\fIpoint\fP).  搜索字符串可以匹配历史行中的任何位置。 这是一个非增量搜索。
.TP 
\fBhistory\-substring\-search\-forward\fP
在历史中向前搜索当前行的开头和点之间的字符串。 搜索字符串可以匹配历史行中的任何位置。 这是一个非增量搜索。
.TP 
\fByank\-nth\-arg (M\-C\-y)\fP
将第一个参数插入到上一个命令 (通常是上一行的第二个单词) 处。 使用参数 \fIn\fP，插入前一个命令中的 \fIn\fPth 字 (前一个命令中的字以字 0
开头)。 negative 参数从上一个命令的末尾插入 \fIn\fPth 字。 一旦计算出参数 \fIn\fP，就如同指定了 "!\fIn\fP"
历史扩展一样提取参数。
.TP 
\fByank\-last\-arg (M\-.\^, M\-_\^)\fP
将最后一个参数插入到上一个命令 (上一个历史条目的最后一个单词)。 使用数字参数，其行为与 \fByank\-nth\-arg\fP 完全相同。 对
\fByank\-last\-arg\fP 的连续调用通过历史列表向后移动，依次插入每行的最后一个词 (或由参数指定的词到第一个调用)。
提供给这些连续调用的任何数字参数决定了在历史中移动的方向。 negative 参数切换历史的方向 (向后或向前)。
历史扩展工具用于提取最后一个单词，就好像指定了 "!$" 历史扩展一样。
.TP 
\fBshell\-expand\-line (M\-C\-e)\fP
像 shell 一样展开该行。 这会执行别名和历史扩展以及所有 shell 字扩展。 有关历史扩展的说明，请参见下面的
.SM
\fBHISTORY EXPANSION\fP。
.TP 
\fBhistory\-expand\-line (M\-^)\fP
对当前行执行历史扩展。 有关历史扩展的说明，请参见下面的
.SM
\fBHISTORY EXPANSION\fP。
.TP 
\fBmagic\-space\fP
对当前行进行历史扩展，插入一个空格。 有关历史扩展的说明，请参见下面的
.SM
\fBHISTORY EXPANSION\fP。
.TP 
\fBalias\-expand\-line\fP
在当前行上执行别名扩展。 有关别名扩展的说明，请参见上面的
.SM
\fBALIASES\fP。
.TP 
\fBhistory\-and\-alias\-expand\-line\fP
在当前行上执行历史和别名扩展。
.TP 
\fBinsert\-last\-argument (M\-.\^, M\-_\^)\fP
\fByank\-last\-arg\fP 的同义词。
.TP 
\fBoperate\-and\-get\-next (C\-o)\fP
接受当前行以执行并从历史记录中获取相对于当前行的下一行以进行编辑。 数字参数 (如果提供) 指定要使用的历史条目而不是当前行。
.TP 
\fBedit\-and\-execute\-command (C\-x C\-e)\fP
在当前命令行调用编辑器，并将结果作为 shell 命令执行。 \fBBash\fP 尝试作为编辑器依次调用
.SM
、\fB$VISUAL\fP、
.SM
、\fB$EDITOR\fP 和 \fIemacs\fP。
.PD
.SS "Commands for Changing Text"
.PD 0
.TP 
\fIend\-of\-file\fP\fB (usually C\-d)\fP
指示文件结束的字符，例如，由
.if  t \f(CWstty\fP.
.if  n ``stty''.
如果在行中没有字符时读取此字符，并且 point 在行首，则 Readline 将其解释为输入结束并返回
.SM
\fBEOF\fP。
.TP 
\fBdelete\-char (C\-d)\fP
删除点处的字符。 如果这个函数绑定到与 tty \fBEOF\fP 字符相同的字符，如 \fBC\-d\fP 通常，请参见上面的效果。
.TP 
\fBbackward\-delete\-char (Rubout)\fP
删除游标后面的字符。 当给定一个数字参数时，将删除的文本保存在 kill ring 上。
.TP 
\fBforward\-backward\-delete\-char\fP
删除游标下的字符，除非游标在行尾，在这种情况下游标后面的字符被删除。
.TP 
\fBquoted\-insert (C\-q, C\-v)\fP
将键入的下一个字符逐字添加到该行。 例如，这是插入 \fBC\-q\fP 等字符的方法。
.TP 
\fBtab\-insert (C\-v TAB)\fP
插入制表符。
.TP 
\fBself\-insert (a,\ b,\ A,\ 1,\ !,\ ...)\fP
插入输入的字符。
.TP 
\fBtranspose\-chars (C\-t)\fP
将点之前的字符向前拖动到点的字符上方，同时向前移动点。 如果 point 位于行尾，则调换 point 之前的两个字符。 Negative 参数无效。
.TP 
\fBtranspose\-words (M\-t)\fP
将点之前的词拖过点之后的词，同时将点移到该词上方。 如果点在行尾，则调换行中的最后两个单词。
.TP 
\fBupcase\-word (M\-u)\fP
将当前 (或后续) 单词大写。 使用 negative 参数，将前一个单词大写，但不要移动点。
.TP 
\fBdowncase\-word (M\-l)\fP
将当前 (或后续) 单词小写。 使用 negative 参数，小写前一个单词，但不移动点。
.TP 
\fBcapitalize\-word (M\-c)\fP
将当前 (或后续) 单词大写。 使用 negative 参数，将前一个单词大写，但不要移动点。
.TP 
\fBoverwrite\-mode\fP
切换覆盖模式。 使用显式正数参数，切换到覆盖模式。 使用显式非正数参数，切换到插入模式。 此命令仅影响 \fBemacs\fP 模式; \fBvi\fP
模式确实以不同方式覆盖。 对 \fIreadline()\fP 的每个调用都以插入模式启动。 在覆盖模式下，绑定到 \fBself\-insert\fP
的字符会替换点处的文本，而不是将文本推到右侧。 绑定到 \fBbackward\-delete\-char\fP 的字符用空格替换点之前的字符。
默认情况下，此命令未绑定。
.PD
.SS "Killing and Yanking"
.PD 0
.TP 
\fBkill\-line (C\-k)\fP
删除从点到行尾的文本。
.TP 
\fBbackward\-kill\-line (C\-x Rubout)\fP
倒退到行首。
.TP 
\fBunix\-line\-discard (C\-u)\fP
.\" There is no real difference between this and backward-kill-line
从点向后杀到行首。 被杀死的文本保存在 kill\-ring 上。
.TP 
\fBkill\-whole\-line\fP
杀死当前行上的所有字符，无参数在哪里。
.TP 
\fBkill\-word (M\-d)\fP
从点到当前单词的结尾，或者如果在单词之间，到下一个单词的结尾。 字边界与 \fBforward\-word\fP 使用的相同。
.TP 
\fBbackward\-kill\-word (M\-Rubout)\fP
杀掉点后面的字。 字边界与 \fBbackward\-word\fP 使用的相同。
.TP 
\fBshell\-kill\-word\fP
从点到当前单词的结尾，或者如果在单词之间，到下一个单词的结尾。 字边界与 \fBshell\-forward\-word\fP 使用的相同。
.TP 
\fBshell\-backward\-kill\-word\fP
杀掉点后面的字。 字边界与 \fBshell\-backward\-word\fP 使用的相同。
.TP 
\fBunix\-word\-rubout (C\-w)\fP
删除点后面的单词，使用空格作为单词边界。 被杀死的文本保存在 kill\-ring 上。
.TP 
\fBunix\-filename\-rubout\fP
删除点后面的单词，使用空格和斜杠字符作为单词边界。 被杀死的文本保存在 kill\-ring 上。
.TP 
\fBdelete\-horizontal\-space (M\-\e)\fP
删除点周围的所有空格和制表符。
.TP 
\fBkill\-region\fP
杀死当前区域的文本。
.TP 
\fBcopy\-region\-as\-kill\fP
将区域中的文本复制到终止缓冲区。
.TP 
\fBcopy\-backward\-word\fP
将 point 之前的单词复制到 kill 缓冲区。 字边界与 \fBbackward\-word\fP 相同。
.TP 
\fBcopy\-forward\-word\fP
将后面的单词复制到 kill 缓冲区。 字边界与 \fBforward\-word\fP 相同。
.TP 
\fByank (C\-y)\fP
滴回 kill ring 的顶部进入缓冲点。
.TP 
\fByank\-pop (M\-y)\fP
旋转 kill ring，滴回新的 top。 仅适用于 \fByank\fP 或 \fByank\-pop\fP。
.PD
.SS "Numeric Arguments"
.PD 0
.TP 
\fBdigit\-argument (M\-0, M\-1, ..., M\-\-)\fP
将这个数字添加到已经累积的参数中，或者开始一个新的参数。 M\-\- 开始一个 negative 参数。
.TP 
\fBuniversal\-argument\fP
这是另一种指定参数的方法。 如果此命令后跟一个或多个数字，可选地带有前导减号，则这些数字定义参数。 如果命令后跟数字，则再次执行
\fBuniversal\-argument\fP 结束数字参数，否则将被忽略。
作为一种特殊情况，如果此命令后紧跟一个既不是数字也不是减号的字符，则下一个命令的参数将乘以四。
参数最初是一个，所以第一次执行这个函数会使参数计数为四，第二次使参数计数为十六，依此类推。
.PD
.SS Completing
.PD 0
.TP 
\fBcomplete (TAB)\fP
尝试对 point 之前的文本执行补全。 \fBBash\fP 尝试完成将文本视为变量 (如果文本以 \fB$\fP) 开头，用户名 (如果文本以 \fB~\fP)
开头)，主机名 (如果文本以 \fB@\fP) 开头)，或命令 (包括别名和函数)。 如果这些都不匹配，则尝试文件名补全。
.TP 
\fBpossible\-completions (M\-?)\fP
在要点之前列出文本的可能补全。
.TP 
\fBinsert\-completions (M\-*)\fP
在 \fBpossible\-completions\fP 生成的点之前插入文本的所有完成。
.TP 
\fBmenu\-complete\fP
类似于 \fBcomplete\fP，但用可能完成列表中的单个匹配项替换要完成的单词。 重复执行 \fBmenu\-complete\fP
遍历可能完成的列表，依次插入每个匹配项。 完成列表最后敲响铃 (以 \fBbell\-style\fP) 的设置为准，恢复原文。 \fIn\fP 的参数将 \fIn\fP
在匹配列表中的位置向前移动; negative 参数可用于在列表中向后移动。 此命令旨在绑定到 \fBTAB\fP，但默认情况下未绑定。
.TP 
\fBmenu\-complete\-backward\fP
与 \fBmenu\-complete\fP 相同，但在可能完成的列表中向后移动，就好像 \fBmenu\-complete\fP 已被赋予 negative 参数。
默认情况下，此命令未绑定。
.TP 
\fBdelete\-char\-or\-list\fP
如果不在行的开头或结尾，则删除游标下的字符 (如 \fBdelete\-char\fP).  如果在行尾，则与 \fBpossible\-completions\fP
的行为相同。 默认情况下，此命令未绑定。
.TP 
\fBcomplete\-filename (M\-/)\fP
尝试对点之前的文本完成文件名补全。
.TP 
\fBpossible\-filename\-completions (C\-x /)\fP
列出点之前文本的可能完成，将其视为文件名。
.TP 
\fBcomplete\-username (M\-~)\fP
尝试完成点之前的文本，将其视为用户名。
.TP 
\fBpossible\-username\-completions (C\-x ~)\fP
在点之前列出文本的可能完成，将其视为用户名。
.TP 
\fBcomplete\-variable (M\-$)\fP
尝试完成点之前的文本，将其视为 shell 变量。
.TP 
\fBpossible\-variable\-completions (C\-x $)\fP
列出 point 之前文本的可能补全，将其视为 shell 变量。
.TP 
\fBcomplete\-hostname (M\-@)\fP
尝试完成点之前的文本，将其视为主机名。
.TP 
\fBpossible\-hostname\-completions (C\-x @)\fP
在点之前列出文本的可能完成，将其视为主机名。
.TP 
\fBcomplete\-command (M\-!)\fP
尝试完成 point 之前的文本，将其视为命令名称。 命令补全尝试将文本与别名、保留字、shell 函数、shell
内置函数以及最后的可执行文件名按该顺序进行匹配。
.TP 
\fBpossible\-command\-completions (C\-x !)\fP
列出点之前文本的可能完成，将其视为命令名称。
.TP 
\fBdynamic\-complete\-history (M\-TAB)\fP
尝试完成点之前的文本，将文本与历史列表中的行进行比较以寻找可能的完成匹配项。
.TP 
\fBdabbrev\-expand\fP
尝试对 point 之前的文本进行菜单补全，将文本与历史列表中的行进行比较以寻找可能的补全匹配项。
.TP 
\fBcomplete\-into\-braces (M\-{)\fP
执行文件名补全并插入用大括号括起来的可能补全列表，以便 shell 可以使用该列表 (请参见上面的 \fBBrace Expansion\fP)。
.PD
.SS "Keyboard Macros"
.PD 0
.TP 
\fBstart\-kbd\-macro (C\-x (\^)\fP
开始保存在当前键盘宏中输入的字符。
.TP 
\fBend\-kbd\-macro (C\-x )\^)\fP
停止保存输入到当前键盘宏的字符并存储定义。
.TP 
\fBcall\-last\-kbd\-macro (C\-x e)\fP
重新执行上次定义的键盘宏，使宏中的字符看起来就像在键盘上键入的一样。
.TP 
\fBprint\-last\-kbd\-macro ()\fP
打印以适合 \fIinputrc\fP 文件的格式定义的最后一个键盘宏。
.PD
.SS Miscellaneous
.PD 0
.TP 
\fBre\-read\-init\-file (C\-x C\-r)\fP
读入 \fIinputrc\fP 文件的内容，并合并在那里找到的任何绑定或变量赋值。
.TP 
\fBabort (C\-g)\fP
终止当前编辑命令，并敲响终止铃 (以 \fBbell\-style\fP).
.TP 
\fBdo\-lowercase\-version (M\-A, M\-B, M\-\fP\fIx\fP\fB, ...)\fP
如果元化字符 \fIx\fP 为大写，则运行对应的元化小写字符绑定的命令。 如果 \fIx\fP 已经是小写，则行为未定义。
.TP 
\fBprefix\-meta (ESC)\fP
Metafy 下一个输入的字符。
.SM
\fBESC\fP \fBf\fP 等同于 \fBMeta\-f\fP。
.TP 
\fBundo (C\-_, C\-x C\-u)\fP
增量撤消，分别记住每一行。
.TP 
\fBrevert\-line (M\-r)\fP
撤消对该行所做的所有更改。 这就像执行 \fBundo\fP 命令足够多次以将线路返回到其初始状态。
.TP 
\fBtilde\-expand (M\-&)\fP
对当前单词执行波浪号扩展。
.TP 
\fBset\-mark (C\-@, M\-<space>)\fP
将标记设置为点。 如果提供数字参数，则标记设置到该位置。
.TP 
\fBexchange\-point\-and\-mark (C\-x C\-x)\fP
用标记交换点。 当前游标位置设置为保存的位置，旧游标位置保存为标记。
.TP 
\fBcharacter\-search (C\-])\fP
读取一个字符并将点移动到该字符的下一个出现处。 negative 计数搜索以前出现的情况。
.TP 
\fBcharacter\-search\-backward (M\-C\-])\fP
读取一个字符并将点移动到该字符的前一个出现处。 negative 计数搜索后续出现。
.TP 
\fBskip\-csi\-sequence\fP
读取足够多的字符以使用多键序列，例如为 Home 和 End 等键定义的序列。 这样的序列以控制序列指示符 (CSI) 开始，通常是
ESC\-[。如果此序列绑定到 "\e["，则生成此类序列的键将无效，除非明确绑定到 readline 命令，而不是将杂散字符插入编辑缓冲区。
默认情况下这是未绑定的，但通常绑定到 ESC\-[。
.TP 
\fBinsert\-comment (M\-#)\fP
如果没有数字参数，readline \fBcomment\-begin\fP 变量的值将插入到当前行的开头。 如果提供了数字参数，则此命令用作切换:
如果行首的字符与 \fBcomment\-begin\fP 的值不匹配，则插入该值，否则从行首删除 \fBcomment\-begin\fP 中的字符。
在任何一种情况下，该行都会被接受，就好像输入了换行符一样。 \fBcomment\-begin\fP 的默认值导致此命令使当前行成为 shell 注释。
如果数字参数导致注释字符被删除，则该行将由 shell 执行。
.TP 
\fBglob\-complete\-word (M\-g)\fP
point 之前的单词被视为路径名扩展的模式，并隐式，追加，了一个星号。 此模式用于生成可能完成的匹配文件名列表。
.TP 
\fBglob\-expand\-word (C\-x *)\fP
点之前的单词被视为路径名扩展的模式，并插入匹配文件名列表，替换单词。 如果提供了数字参数，则在路径名扩展之前，追加，一个星号。
.TP 
\fBglob\-list\-expansions (C\-x g)\fP
显示 \fBglob\-expand\-word\fP 生成的扩展列表，并重新绘制线条。 如果提供了数字参数，则在路径名扩展之前，追加，一个星号。
.TP 
\fBdump\-functions\fP
将所有函数及其键绑定打印到 readline 输出流。 如果提供了数字参数，则输出的格式将使其成为 \fIinputrc\fP 文件的一部分。
.TP 
\fBdump\-variables\fP
将所有可设置的 readline 变量及其值打印到 readline 输出流。 如果提供了数字参数，则输出的格式将使其成为 \fIinputrc\fP
文件的一部分。
.TP 
\fBdump\-macros\fP
打印绑定到宏的所有 readline 键序列及其输出的字符串。 如果提供了数字参数，则输出的格式将使其成为 \fIinputrc\fP 文件的一部分。
.TP 
\fBdisplay\-shell\-version (C\-x C\-v)\fP
显示有关 \fBbash\fP 当前实例的版本信息。
.PD
.SS "Programmable Completion"
当尝试对具有完成规范的命令 (\fIcompspec\fP) 已使用 \fBcomplete\fP 内置定义 (请参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP) 定义了 \fIcompspec\fP) (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)
) 执行单词完成时，将调用可编程完成功能。
.PP
首先，识别命令名称。 如果命令字是空字符串 (在空行的开头尝试完成)，则使用 \fBcomplete\fP 的 \fB\-E\fP 选项定义的任何 compspec。
如果已为该命令定义了 compspec，则 compspec 用于生成该词的可能补全列表。 如果命令字是完整路径名，则首先搜索完整路径名的
compspec。 如果没有找到完整路径名的 compspec，则会尝试为最后一个斜杠后面的部分找到 compspec。 如果这些搜索未产生
compspec，则使用 \fBcomplete\fP 的 \fB\-D\fP 选项定义的任何 compspec 将用作默认值。 如果没有默认的
compspec，作为最后的手段，\fBbash\fP 会尝试对命令字进行别名扩展，并尝试从任何成功的扩展中为命令字找到 compspec。
.PP
一旦找到一个 compspec，它就被用来生成匹配词的列表。 如果未找到 compspec，则执行上述 \fBCompleting\fP 下的默认
\fBbash\fP 完成。
.PP
首先，使用 compspec 指定的操作。 仅返回以要完成的单词为前缀的匹配项。 当 \fB\-f\fP 或 \fB\-d\fP
选项用于文件名或目录名完成时，shell 变量
.SM
\fBFIGNORE\fP 用于过滤匹配项。
.PP
接下来生成 \fB\-G\fP 选项的路径名扩展模式指定的任何补全。 模式生成的词不需要与正在完成的词相匹配。 不使用
.SM
\fBGLOBIGNORE\fP
shell 变量来过滤匹配项，而是使用
.SM
\fBFIGNORE\fP 变量。
.PP
接下来，考虑指定为 \fB\-W\fP 选项的参数的字符串。 该字符串首先使用
.SM
\fBIFS\fP 特殊变量中的字符作为分隔符进行拆分。 Shell
引用很荣幸。 然后使用大括号扩展、波浪符扩展、参数和变量扩展、命令替换和算术扩展来扩展每个单词，如上文
.SM
\fBEXPANSION\fP 中所述。
使用上述 \fBWord Splitting\fP 下描述的规则拆分结果。 扩展的结果与正在完成的词进行前缀匹配，匹配的词成为可能的完成。
.PP
生成这些匹配项后，调用任何 shell 函数或使用 \fB\-F\fP 和 \fB\-C\fP 选项指定的命令。 调用命令或函数时，
.SM
\fBCOMP_LINE\fP、
.SM
\fBCOMP_POINT\fP、
.SM
\fBCOMP_KEY\fP 和
.SM
\fBCOMP_TYPE\fP
变量的赋值如上文 \fBShell Variables\fP 中所述。 如果调用 shell 函数，则还会设置
.SM
\fBCOMP_WORDS\fP 和
.SM
\fBCOMP_CWORD\fP 变量。 当调用函数或命令时，第一个参数 (\fB$1\fP) 是正在完成参数的命令的名称，第二个参数 (\fB$2\fP)
是正在完成的单词，第三个参数 (\fB$3\fP) 是当前正在完成的单词之前的单词命令行。 不对正在完成的单词执行生成的完成过滤;
函数或命令可以完全自由地生成匹配项。
.PP
首先调用用 \fB\-F\fP 指定的任何函数。 函数可以使用任何 shell 工具，包括下面描述的 \fBcompgen\fP 内置函数，来生成匹配项。
它必须将可能的补全放在
.SM
\fBCOMPREPLY\fP 数组变量中，每个数组元素一个。
.PP
接下来，在等效于命令替换的环境中调用使用 \fB\-C\fP 选项指定的任何命令。 它应该将完成列表打印到标准输出，每行一个。
如有必要，可以使用反斜杠来转义换行符。
.PP
生成所有可能的补全后，将使用 \fB\-X\fP 选项指定的任何过滤器应用于列表。 过滤器是用于路径名扩展的模式; 模式中的 \fB&\fP
将替换为正在完成的单词的文本。 一个字面量 \fB&\fP 可以用反斜杠转义; 在尝试匹配之前删除反斜杠。 任何与模式匹配的完成将从列表中删除。 前导
\fB!\fP 否定模式; 在这种情况下，任何与模式不匹配的补全都将被删除。 如果启用 \fBnocasematch\fP shell
选项，则执行匹配时不考虑字母字符的大小写。
.PP
最后，将使用 \fB\-P\fP 和 \fB\-S\fP 选项指定的任何前缀和后缀添加到完成列表的每个成员，并将结果作为可能完成的列表返回给 readline
完成代码。
.PP
如果先前应用的操作未生成任何匹配项，并且在定义 compspec 时向 \fBcomplete\fP 提供了 \fB\-o dirnames\fP
选项，则会尝试完成目录名称。
.PP
如果在定义 compspec 时将 \fB\-o plusdirs\fP 选项提供给
\fBcomplete\fP，则会尝试完成目录名称并将任何匹配项添加到其他操作的结果中。
.PP
默认情况下，如果找到一个 compspec，无论它生成什么，都会作为完整的可能完成集返回到完成代码。 不尝试默认的 \fBbash\fP
完成，并且禁用文件名完成的读取行默认值。 如果在定义 compspec 时将 \fB\-o bashdefault\fP 选项提供给
\fBcomplete\fP，则在 compspec 未生成匹配项时尝试 \fBbash\fP 默认完成。 如果在定义 compspec 时将 \fB\-o default\fP 选项提供给 \fBcomplete\fP，则在 compspec (以及，如果尝试，默认的 \fBbash\fP 完成)
没有生成匹配项的情况下，将执行 readline 的默认完成。
.PP
当 compspec 指示需要完成目录名称时，可编程完成函数强制 readline 将斜杠追加到完成的名称，这些名称是指向目录的符号链接，受
\fBmark\-directories\fP readline 变量的值约束，而不管 \fBmark\-symlinked\-directories\fP
readline 变量的设置.
.PP
有一些支持动态修改补全。 这在与 \fBcomplete \-D\fP 指定的默认完成结合使用时最有用。 shell
函数有可能作为完成处理程序执行，以指示应该通过返回退出状态 124 来重试完成。 如果 shell 函数返回 124，并更改与正在尝试完成的命令关联的
compspec (在执行函数时作为第一个参数提供)，可编程完成从头开始重新启动，并尝试为寻找新的 compspec 那个命令。
这允许在尝试完成时动态构建一组完成，而不是一次加载所有完成。
.PP
例如，假设有一个 compspecs 库，每个都保存在一个与命令名称相对应的文件中，以下默认完成函数将动态加载完成:
.PP
\f(CW_completion_loader()\fP
.br
\f(CW{\fP
.br
\f(CW	. "/etc/bash_completion.d/$1.sh" >/dev/null 2>&1 && return 124\fP
.br
\f(CW}\fP
.br
\f(CWcomplete \-D \-F _completion_loader \-o bashdefault \-o default\fP
.br
\fP
.SH HISTORY
当启用 \fBset\fP 内置的 \fB\-o history\fP 选项时，shell 提供对 \fIcommand history\fP
的访问，即先前键入的命令列表。
.SM
\fBHISTSIZE\fP 变量的值用作要保存在历史列表中的命令数。 最后
.SM
\fBHISTSIZE\fP 命令的文本 (默认 500) 被保存。 shell 在参数和变量扩展之前将每个命令存储在历史列表中 (参见上面的
.SM
\fBEXPANSION\fP)，但在执行历史扩展之后，以 shell 变量
.SM
\fBHISTIGNORE\fP 和
.SM
\fBHISTCONTROL\fP 的值为准。
.PP
启动时，历史从变量
.SM
\fBHISTFILE\fP (默认 \fI~/.bash_history\fP).x) 命名的文件中初始化。 如有必要，由
.SM
\fBHISTFILE\fP 的值命名的文件将被截断，以包含不超过
.SM
\fBHISTFILESIZE\fP 的值指定的行数。 如果
\fBHISTFILESIZE\fP 未设置或设置为 null、非数值或小于零的数值，则不会截断历史文件。
读取历史文件时，以历史注释字符开头紧跟数字的行被解释为后续历史行的时间戳。 根据
.SM
\fBHISTTIMEFORMAT\fP
变量的值，可选择显示这些时间戳。 当启用了历史记录的 shell 退出时，最后的
.SM
\fB$HISTSIZE\fP 行从历史列表复制到
.SM
\fB$HISTFILE\fP。 如果启用了 \fBhistappend\fP shell 选项 (参见下面
.SM
\fBSHELL BUILTIN COMMANDS\fP 下对 \fBshopt\fP 的描述)，这些行将追加到历史文件中，否则历史文件将被覆盖。 如果
.SM
\fBHISTFILE\fP 未设置，或者历史文件不可写，则不保存历史。 如果设置了
.SM
\fBHISTTIMEFORMAT\fP
变量，时间戳将写入历史文件，用历史注释字符标记，因此它们可以在 shell 会话中保留。 这使用历史注释字符将时间戳与其他历史行区分开来。
保存历史后，历史文件被截断为不超过
.SM
\fBHISTFILESIZE\fP 行。 如果
.SM
\fBHISTFILESIZE\fP
未设置，或设置为 null、非数值或小于零的数值，则不会截断历史文件。
.PP
内置命令 \fBfc\fP (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP) 可用于列出或编辑并重新执行历史列表的一部分。
\fBhistory\fP 内置函数可用于显示或修改历史列表以及操作历史文件。 使用命令行编辑时，搜索命令在提供对历史列表的访问的每种编辑模式中可用。
.PP
shell 允许控制将哪些命令保存在历史列表中。
.SM
\fBHISTCONTROL\fP 和
.SM
\fBHISTIGNORE\fP
变量可以设置为使 shell 仅保存输入命令的一个子集。 \fBcmdhist\fP shell 选项，如果启用，会导致 shell
尝试将多行命令的每一行保存在同一历史记录条目中，并在必要时添加分号以保持语法正确性。 \fBlithist\fP shell 选项导致 shell
使用嵌入的换行符而不是分号来保存命令。 有关设置和取消设置 shell 选项的信息，请参见下面
.SM
\fBSHELL BUILTIN COMMANDS\fP 下的 \fBshopt\fP 内置说明。
.SH "HISTORY EXPANSION"
shell 支持历史扩展特性类似于 \fBcsh\fP 中的历史扩展。 本节介绍可用的语法，特性。 此特性默认为交互式 shells 启用，并且可以使用
\fBset\fP 内置命令的 \fB+H\fP 选项禁用 (参见下面的
.SM
\fBSHELL BUILTIN COMMANDS\fP)。 非交互式
shells 默认不执行历史扩展。
.PP
历史扩展将历史列表中的单词引入输入流，从而使重复命令、将前一个命令的参数插入当前输入行或快速修复前一个命令中的错误变得容易。
.PP
历史扩展在读取完整行后立即执行，在 shell 将其分解为单词之前，并且在不考虑前面行的引用的情况下单独对每一行执行。 它分两部分进行。
第一个是确定在替换期间使用历史列表中的哪一行。 第二种是选择该行的部分内容以包含在当前行中。 从历史记录中选择的行是
\fIevent\fP，该行中被操作的部分是 \fIwords\fP。 可以使用各种 \fImodifiers\fP 来操作选定的单词。
该行以与读取输入时相同的方式被分成单词，因此被引号包围的几个 \fImetacharacter\fP\-separated 单词被认为是一个单词。
历史扩展由历史扩展字符的出现引入，默认为 \^\fB!\fP\^。 只有反斜杠 (\^\fB\e\fP\^)
和单引号可以引用历史扩展字符，但如果历史扩展字符紧接在双引号字符串中的右双引号之前，也将被视为被引用。
.PP
如果紧跟在历史扩展字符之后，有几个字符会禁止历史扩展，即使它没有被引用: 空格、制表符、换行符、回车和 \fB=\fP。 如果启用 \fBextglob\fP
shell 选项，\fB(\fP 也将禁止扩展。
.PP
可使用内置 \fBshopt\fP 设置的几个 shell 选项可用于定制历史扩展的行为。 如果启用了 \fBhistverify\fP shell 选项
(请参见下面对 \fBshopt\fP 内置函数的描述)，并且正在使用 \fBreadline\fP，则历史替换不会立即传递给 shell 解析器。
相反，扩展行被重新加载到 \fBreadline\fP 编辑缓冲区以进行进一步修改。 如果正在使用 \fBreadline\fP，并且启用了
\fBhistreedit\fP shell 选项，则失败的历史替换将重新加载到 \fBreadline\fP 编辑缓冲区中以进行更正。 \fBhistory\fP
内置命令的 \fB\-p\fP 选项可用于在使用历史扩展之前查看历史扩展将执行的操作。 \fBhistory\fP 内置的 \fB\-s\fP
选项可用于将命令添加到历史列表的末尾而不实际执行它们，以便它们可用于后续调用。
.PP
shell 允许控制历史扩展机制使用的各种字符 (参见上面 \fBShell Variables\fP) 下对 \fBhistchars\fP 的描述)。
shell 在写入历史文件时使用历史注释符来标记历史时间戳。
.SS "Event Designators"
事件指示符是对历史列表中命令行条目的引用。 除非引用是绝对的，否则事件是相对于历史列表中的当前位置的。
.PP
.PD 0
.TP 
\fB!\fP
开始历史替换，除非后跟 \fBblank\fP、换行符、回车符、= 或 ( (当使用 \fBshopt\fP 内置启用 \fBextglob\fP shell 选项时)。
.TP 
\fB!\fP\fIn\fP
请参见命令行 \fIn\fP。
.TP 
\fB!\-\fP\fIn\fP
参考当前指令减去 \fIn\fP。
.TP 
\fB!!\fP
参考前面的命令。 这是 `!\-1` 的同义词。
.TP 
\fB!\fP\fIstring\fP
参考历史列表中以 \fIstring\fP 开头的当前位置之前的最近命令。
.TP 
\fB!?\fP\fIstring\fP\fB[?]\fP
参考包含 \fIstring\fP 的历史列表中当前位置之前的最近命令。 如果 \fIstring\fP 后面紧跟着一个换行符，则尾随的 \fB?\fP 可以省略。
如果缺少 \fIstring\fP，则使用最近搜索的字符串; 如果没有以前的搜索字符串，这是一个错误。
.TP 
\fB\d\s+2^\s-2\u\fP\fIstring1\fP\fB\d\s+2^\s-2\u\fP\fIstring2\fP\fB\d\s+2^\s-2\u\fP
快速替换。 重复前面的命令，将 \fIstring1\fP 替换为 \fIstring2\fP。 相当于
\*(lq!!:s\d\s+2^\s-2\u\fIstring1\fP\d\s+2^\s-2\u\fIstring2\fP\d\s+2^\s-2\u\*(rq (见下面的
\fBModifiers\fP)。
.TP 
\fB!#\fP
到目前为止输入的整个命令行。
.PD
.SS "Word Designators"
单词指示符用于从事件中选择所需的单词。 \fB:\fP 将事件规范与字指示符分开。 如果单词标识符以 \fB^\fP、\fB$\fP、\fB*\fP、\fB\-\fP 或 \fB%\fP
开头，则可以省略。 单词从行首开始编号，第一个单词用 0 (zero) 表示。 单词被插入到当前行中，由单个空格分隔。
.PP
.PD 0
.TP 
\fB0 (zero)\fP
第零个字。 对于 shell，这是命令字。
.TP 
\fIn\fP
\fIn\fPth 字。
.TP 
\fB^\fP
第一个参数。 也就是说，词 1.
.TP 
\fB$\fP
最后一个字。 这通常是最后一个参数，但如果行中只有一个词，则会扩展到第零个词。
.TP 
\fB%\fP
最近的 `?\fIstring\fP?' 搜索匹配的第一个单词，如果搜索字符串以属于单词一部分的字符开头。
.TP 
\fIx\fP\fB\-\fP\fIy\fP
一系列单词; `\-\fIy\fP' 是 `0\-\fIy\fP' 的缩写。
.TP 
\fB*\fP
除了第零个单词之外的所有单词。 这是 `\fI1\-$\fP' 的同义词。如果事件中只有一个单词，则使用 \fB*\fP 不是错误; 在这种情况下返回空字符串。
.TP 
\fBx*\fP
缩写 \fIx\-$\fP。
.TP 
\fBx\-\fP
像 \fBx*\fP 一样缩写 \fIx\-$\fP，但省略最后一个词。 如果缺少 \fBx\fP，则默认为 0.
.PD
.PP
如果在没有指定事件的情况下提供了字指示符，则前一个命令将用作事件。
.SS Modifiers
在可选的单词指示符之后，可能会出现一系列的一个或多个以下修饰符，每个修饰符前面都有一个 `: `。这些修改或编辑从历史事件中选择的一个或多个单词。
.PP
.PD 0
.TP 
\fBh\fP
删除尾随的文件名部分，只留下头部。
.TP 
\fBt\fP
删除所有领先的文件名组件，留下尾巴。
.TP 
\fBr\fP
删除 \fI.xxx\fP 形式的尾随后缀，保留基本名称。
.TP 
\fBe\fP
删除除尾随后缀之外的所有内容。
.TP 
\fBp\fP
打印新命令但不执行它。
.TP 
\fBq\fP
引用被替换的词，避免进一步的替换。
.TP 
\fBx\fP
像 \fBq\fP 一样引用替换词，但在 \fBblanks\fP 和换行符处分成词。 \fBq\fP 和 \fBx\fP 修饰符是互斥的; 使用提供的最后一个。
.TP 
\fBs/\fP\fIold\fP\fB/\fP\fInew\fP\fB/\fP
用 \fInew\fP 替换事件行中第一次出现的 \fIold\fP。 任何字符都可以用作分隔符来代替 /。 如果最终定界符是事件行的最后一个字符，则它是可选的。
分隔符可以在 \fIold\fP 和 \fInew\fP 中用单个反斜杠引用。 如果 & 出现在 \fInew\fP 中，则用 \fIold\fP 代替。 单个反斜杠将引用
&。 如果 \fIold\fP 为空，则将其设置为最后一个替换的 \fIold\fP，或者，如果没有发生先前的历史替换，则设置为
\fB!?\fP\fIstring\fP\fB[?]\fP 搜索中的最后一个 \fIstring\fP。 如果 \fInew\fP 为空，则删除每个匹配的 \fIold\fP。
.TP 
\fB&\fP
重复之前的替换。
.TP 
\fBg\fP
导致更改应用于整个事件行。 这与 `\fB:s\fP' (例如，`\fB:gs/\fP\fIold\fP\fB/\fP\fInew\fP\fB/\fP') 或 `\fB:&\fP')
一起使用。如果与 `\fB:s\fP' 一起使用，则可以使用任何分隔符代替 /，如果最后一个分隔符是事件行的最后一个字符，则它是可选的。 \fBa\fP 可以用作
\fBg\fP 的同义词。
.TP 
\fBG\fP
对事件行中的每个单词应用一次以下 `\fBs\fP' 或 `\fB&\fP' 修饰符。
.PD
.SH "SHELL BUILTIN COMMANDS"
.\" start of bash_builtins
.zZ
.PP
除非另有说明，否则本节中记录的每个内置命令都接受前面带有 \fB\-\fP 的选项，并接受 \fB\-\-\fP 以表示选项结束。
\fB:\fP、\fBtrue\fP、\fBfalse\fP 和 \fBtest\fP/\fB[\fP 内置函数不接受选项并且不特殊对待 \fB\-\-\fP。
\fBexit\fP、\fBlogout\fP、\fBreturn\fP、\fBbreak\fP、\fBcontinue\fP、\fBlet\fP 和 \fBshift\fP
内置函数接受并处理从 \fB\-\fP 开始的参数，而不需要 \fB\-\-\fP。 其他接受参数但未指定为接受选项的内置函数将以 \fB\-\fP
开头的参数解释为无效选项，并需要 \fB\-\-\fP 来防止这种解释。
.sp .5
.PD 0
.TP 
\fB:\fP [\fIarguments\fP]
.PD
没有效果; 该命令除了扩展 \fIarguments\fP 和执行任何指定的重定向之外什么都不做。 返回状态为零。
.TP 
 \fB.\| \fP \fIfilename\fP [\fIarguments\fP]
.PD 0
.TP 
\fBsource\fP \fIfilename\fP [\fIarguments\fP]
.PD
在当前 shell 环境中读取并执行来自 \fIfilename\fP 的命令，并返回从 \fIfilename\fP 执行的最后一条命令的退出状态。 如果
\fIfilename\fP 不包含斜杠，则使用
.SM
\fBPATH\fP 中的文件名来查找包含 \fIfilename\fP 的目录。 在
.SM
\fBPATH\fP 中搜索的文件不需要是可执行文件。 当 \fBbash\fP 不在 \fIposix mode\fP 中时，如果在
.SM
\fBPATH\fP
中找不到文件，则查找当前目录。 如果关闭 \fBshopt\fP 内置命令的 \fBsourcepath\fP 选项，则不会搜索
.SM
\fBPATH\fP。
如果提供任何 \fIarguments\fP，它们将成为执行 \fIfilename\fP 时的位置参数。 否则位置参数不变。 如果启用 \fB\-T\fP
选项，\fBsource\fP 将继承 \fBDEBUG\fP 上的任何陷阱; 如果不是，任何 \fBDEBUG\fP 陷阱字符串将被保存并恢复到 \fBsource\fP
的调用周围，并且 \fBsource\fP 在执行时取消设置 \fBDEBUG\fP 陷阱。 如果未设置 \fB\-T\fP，并且源文件更改 \fBDEBUG\fP 陷阱，则在
\fBsource\fP 完成时保留新值。 返回状态是脚本中最后退出的命令的状态 (如果没有执行任何命令则为 0)，如果未找到或无法读取
\fIfilename\fP 则返回 false。
.TP 
\fBalias\fP [\fB\-p\fP] [\fIname\fP[=\fIvalue\fP] ...]
不带参数或带 \fB\-p\fP 选项的 \fBAlias\fP 在标准输出上以 \fBalias\fP \fIname\fP=\fIvalue\fP 的形式打印别名列表。
当提供参数时，为给定 \fIvalue\fP 的每个 \fIname\fP 定义一个别名。 \fIvalue\fP
中的尾随空格会导致在扩展别名时检查下一个单词以进行别名替换。 对于没有提供 \fIvalue\fP 的参数列表中的每个 \fIname\fP，打印别名的名称和值。
\fBAlias\fP 返回 true，除非给出了没有定义别名的 \fIname\fP。
.TP 
\fBbg\fP [\fIjobspec\fP ...]
在后台恢复每个挂起的作业 \fIjobspec\fP，就好像它是用 \fB&\fP 启动的一样。 如果 \fIjobspec\fP 不存在，则使用 shell 的
\fIcurrent job\fP 概念。 \fBbg\fP \fIjobspec\fP 返回
0，除非在禁用作业控制时运行，或者在启用作业控制的情况下运行时，找不到任何指定的 \fIjobspec\fP 或在没有作业控制的情况下启动。
.TP 
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] [\fB\-lpsvPSVX\fP]
.PD 0
.TP 
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] [\fB\-q\fP \fIfunction\fP] [\fB\-u\fP \fIfunction\fP] [\fB\-r\fP \fIkeyseq\fP]
.TP 
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fB\-f\fP \fIfilename\fP
.TP 
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fB\-x\fP \fIkeyseq\fP:\fIshell\-command\fP
.TP 
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fIkeyseq\fP:\fIfunction\-name\fP
.TP 
\fBbind\fP [\fB\-m\fP \fIkeymap\fP] \fIkeyseq\fP:\fIreadline\-command\fP
.PD
显示当前 \fBreadline\fP 键和函数绑定，将键序列绑定到 \fBreadline\fP 函数或宏，或设置 \fBreadline\fP 变量。
每个非选项参数都是一个命令，因为它会出现在 \fI.inputrc\fP 中，但每个绑定或命令必须作为单独的参数传递; 例如，'`\eC\-x\eC\-r`:
重新读取初始化文件 '。 选项 (如果提供) 具有以下含义:
.RS
.PD 0
.TP 
\fB\-m \fP\fIkeymap\fP
使用 \fIkeymap\fP 作为受后续绑定影响的键映射。 可接受的 \fIkeymap\fP 名称是 \fIemacs, emacs\-standard, emacs\-meta, emacs\-ctlx, vi, vi\-move, vi\-command\fP 和 \fIvi\-insert\fP。 \fIvi\fP 等同于
\fIvi\-command\fP (\fIvi\-move\fP 也是同义词) ; \fIemacs\fP 等同于 \fIemacs\-standard\fP。
.TP 
\fB\-l\fP
列出所有 \fBreadline\fP 函数的名称。
.TP 
\fB\-p\fP
以可以重新读取的方式显示 \fBreadline\fP 函数名称和绑定。
.TP 
\fB\-P\fP
列出当前的 \fBreadline\fP 函数名称和绑定。
.TP 
\fB\-s\fP
显示绑定到宏的 \fBreadline\fP 键序列以及它们以可以重新读取的方式输出的字符串。
.TP 
\fB\-S\fP
显示绑定到宏的 \fBreadline\fP 键序列及其输出的字符串。
.TP 
\fB\-v\fP
以可以重新读取的方式显示 \fBreadline\fP 变量名称和值。
.TP 
\fB\-V\fP
列出当前 \fBreadline\fP 变量名称和值。
.TP 
\fB\-f \fP\fIfilename\fP
从 \fIfilename\fP 读取键绑定。
.TP 
\fB\-q \fP\fIfunction\fP
查询哪些键调用指定的 \fIfunction\fP。
.TP 
\fB\-u \fP\fIfunction\fP
解除绑定到指定 \fIfunction\fP 的所有键。
.TP 
\fB\-r \fP\fIkeyseq\fP
删除 \fIkeyseq\fP 的任何当前绑定。
.TP 
\fB\-x \fP\fIkeyseq\fP\fB:\fP\fIshell\-command\fP
每当输入 \fIkeyseq\fP 时，都会执行 \fIshell\-command\fP。 当执行 \fIshell\-command\fP 时，shell 将
.SM
\fBREADLINE_LINE\fP 变量设置为 \fBreadline\fP 行缓冲区的内容，
.SM
\fBREADLINE_POINT\fP 和
.SM
\fBREADLINE_MARK\fP 变量分别设置为插入点的当前位置和保存的插入点 (标记)。 如果执行的命令更改了
.SM
\fBREADLINE_LINE\fP、
.SM
\fBREADLINE_POINT\fP 或
.SM
\fBREADLINE_MARK\fP
中任何一个的值，这些新值将反映在编辑状态中。
.TP 
\fB\-X\fP
以可重复用作输入的格式列出绑定到 shell 命令和关联命令的所有键序列。
.PD
.PP
除非给出无法识别的选项或发生错误，否则返回值为 0。
.RE
.TP 
\fBbreak\fP [\fIn\fP]
从 \fBfor\fP、\fBwhile\fP、\fBuntil\fP 或 \fBselect\fP 循环中退出。 如果指定了 \fIn\fP，则中断 \fIn\fP 级别。 \fIn\fP
必须是 \(>= 1。 如果 \fIn\fP 大于封闭循环数，则退出所有封闭循环。 除非 \fIn\fP 不大于或等于，否则返回值为 0 1.
.TP 
\fBbuiltin\fP \fIshell\-builtin\fP [\fIarguments\fP]
执行指定的 shell 内置命令，将 \fIarguments\fP 传递给它，并返回其退出状态。 这在定义一个与 shell
内置函数同名的函数时很有用，保留了函数中内置函数的功能。 \fBcd\fP 内置函数通常以这种方式重新定义。 如果 \fIshell\-builtin\fP 不是
shell 内置命令，则返回状态为 false。
.TP 
\fBcaller\fP [\fIexpr\fP]
返回任何活动子例程调用的上下文 (一个 shell 函数或使用 \fB.\fP 或 \fBsource\fP 内置函数执行的脚本)。 如果没有
\fIexpr\fP，\fBcaller\fP 显示当前子程序调用的行号和源文件名。 如果一个非 negative 整数作为 \fIexpr\fP
提供，\fBcaller\fP 显示与当前执行调用栈中该位置对应的行号、子程序名称和源文件。 例如，可以使用此额外信息来打印栈跟踪。 当前帧是第 0 帧。
返回值为 0，除非 shell 没有执行子程序调用或 \fIexpr\fP 不对应调用栈中的有效位置。
.TP 
\fBcd\fP [\fB\-L\fP|[\fB\-P\fP [\fB\-e\fP]] [\-@]] [\fIdir\fP]
将当前目录更改为 \fIdir\fP。 如果未提供 \fIdir\fP，则
.SM
\fBHOME\fP shell 变量的值为默认值。 \fIdir\fP
之后的任何附加参数都将被忽略。 变量
.SM
\fBCDPATH\fP 定义包含 \fIdir\fP: 的目录的搜索路径
.SM
\fBCDPATH\fP
中的每个目录名称都将搜索 \fIdir\fP。
.SM
\fBCDPATH\fP 中的备用目录名称由冒号 (:) 分隔。
.SM
\fBCDPATH\fP
中的空目录名与当前目录相同，即 \*(lq\fB.\fP\*(rq。 如果 \fIdir\fP 以斜线 (/) 开头，则不使用
.SM
\fBCDPATH\fP。 \fB\-P\fP
选项导致 \fBcd\fP 在遍历 \fIdir\fP 时和在 \fIdir\fP 中处理 \fI..\fP 实例之前通过解析符号链接来使用物理目录结构体 (另请参见
\fBset\fP 内置命令的 \fB\-P\fP 选项) ; \fB\-L\fP 选项通过在 \fIdir\fP 中处理 \fI..\fP 实例后解析链接来强制遵循符号链接。 如果
\&\fI..\fP 出现在 \fIdir\fP 中，则通过从 \fIdir\fP 中删除紧邻的前一个路径名组件来处理它，返回到斜线或 \fIdir\fP 的开头。 如果
\fB\-e\fP 选项随 \fB\-P\fP 一起提供，并且在目录更改成功后无法成功确定当前工作目录，则 \fBcd\fP 将返回不成功状态。 在支持它的系统上，\fB\-@\fP
选项将与文件关联的扩展属性显示为目录。 在尝试更改目录之前，\fB\-\fP 的参数被转换为
.SM
\fB$OLDPWD\fP。 如果使用
.SM
\fBCDPATH\fP 中的非空目录名，或者如果 \fB\-\fP 是第一个参数，并且目录更改成功，则新工作目录的绝对路径名将写入标准输出。
如果目录更改成功，则返回值为真; 否则为假。
.TP 
\fBcommand\fP [\fB\-pVv\fP] \fIcommand\fP [\fIarg\fP ...]
运行 \fIcommand\fP 和 \fIargs\fP 抑制正常的 shell 函数查找。 仅执行内置命令或在
.SM
\fBPATH\fP 中找到的命令。
如果给出 \fB\-p\fP 选项，则使用
.SM
\fBPATH\fP 的默认值执行 \fIcommand\fP 搜索，保证找到所有标准实用工具。 如果提供了
\fB\-V\fP 或 \fB\-v\fP 选项，则会打印 \fIcommand\fP 的说明。 \fB\-v\fP 选项导致显示一个单词，指示用于调用 \fIcommand\fP
的命令或文件名; \fB\-V\fP 选项产生更详细的描述。 如果提供了 \fB\-V\fP 或 \fB\-v\fP 选项，则如果找到 \fIcommand\fP 则退出状态为
0，否则为 1。 如果两个选项均未提供且发生错误或无法找到 \fIcommand\fP，则退出状态为 127。 否则，内置 \fBcommand\fP
的退出状态就是 \fIcommand\fP 的退出状态。
.TP 
\fBcompgen\fP [\fIoption\fP] [\fIword\fP]
根据 \fIoption\fPs 为 \fIword\fP 生成可能的补全匹配，\fIoption\fPs 可以是除 \fB\-p\fP 和 \fB\-r\fP 之外的
\fBcomplete\fP 内置接受的任何选项，并将匹配写入标准输出。 当使用 \fB\-F\fP 或 \fB\-C\fP 选项时，由可编程完成工具设置的各种 shell
变量虽然可用，但不会有有用的值。
.sp 1
匹配将以相同的方式生成，就好像可编程完成代码直接从具有相同标志的完成规范生成它们一样。 如果指定 \fIword\fP，则只显示与 \fIword\fP
匹配的补全。
.sp 1
除非提供了无效选项，否则返回值为真，或者没有生成匹配项。
.TP 
\fBcomplete\fP [\fB\-abcdefgjksuv\fP] [\fB\-o\fP \fIcomp\-option\fP] [\fB\-DEI\fP] [\fB\-A\fP \fIaction\fP] [\fB\-G\fP \fIglobpat\fP] [\fB\-W\fP \fIwordlist\fP]
.br
[\fB\-F\fP \fIfunction\fP] [\fB\-C\fP \fIcommand\fP] [\fB\-X\fP \fIfilterpat\fP] [\fB\-P\fP
\fIprefix\fP] [\fB\-S\fP \fIsuffix\fP] \fIname\fP [\fIname ...\fP]
.PD 0
.TP 
\fBcomplete\fP \fB\-pr\fP [\fB\-DEI\fP] [\fIname\fP ...]
.PD
指定应如何完成每个 \fIname\fP 的参数。 如果提供了 \fB\-p\fP
选项，或者没有提供任何选项，则现有的完成规范将以允许它们作为输入重新使用的方式打印。 \fB\-r\fP 选项删除每个 \fIname\fP
的完成规范，或者，如果没有提供 \fIname\fPs，则删除所有完成规范。 \fB\-D\fP 选项表示其他提供的选项和操作应该应用于 `默认` 命令完成;
也就是说，尝试完成先前未定义完成的命令。 \fB\-E\fP 选项表示其他提供的选项和操作应该应用于 `空` 命令完成; 也就是说，尝试在空白行上完成。
\fB\-I\fP 选项指示其他提供的选项和操作应适用于行上初始非赋值字的完成，或在命令定界符 (例如 \fB;\fP 或 \fB|\fP，通常是命令名称完成) 之后。
如果提供了多个选项，则 \fB\-D\fP 选项优先于 \fB\-E\fP，并且两者都优先于 \fB\-I\fP。 如果提供 \fB\-D\fP、\fB\-E\fP 或 \fB\-I\fP
中的任何一个，则忽略任何其他 \fIname\fP 参数; 这些补全仅适用于选项指定的情况。
.sp 1
尝试完成单词时应用这些完成规范的过程在上面的 \fBProgrammable Completion\fP 下进行了描述。
.sp 1
其他选项，如果指定，具有以下含义。 应引用 \fB\-G\fP、\fB\-W\fP 和 \fB\-X\fP 选项 (以及必要时的 \fB\-P\fP 和 \fB\-S\fP 选项)
的引用，以防止在调用 \fBcomplete\fP 内置函数之前扩展它们。
.RS
.PD 0
.TP  8
\fB\-o\fP \fIcomp\-option\fP
除了简单的完成生成之外，\fIcomp\-option\fP 还控制了 compspec 行为的几个方面。 \fIcomp\-option\fP 可能是以下之一:
.RS
.TP  8
\fBbashdefault\fP
如果 compspec 没有生成匹配项，则执行其余的默认 \fBbash\fP 完成。
.TP  8
\fBdefault\fP
如果 compspec 没有生成匹配项，则使用 readline 的默认文件名完成。
.TP  8
\fBdirnames\fP
如果 compspec 没有生成匹配项，则执行目录名称完成。
.TP  8
\fBfilenames\fP
告诉 readline compspec 生成文件名，因此它可以执行任何特定于文件名的处理 (例如在目录名中添加斜杠、引用特殊字符或抑制尾随空格)。
旨在与 shell 函数一起使用。
.TP  8
\fBnoquote\fP
告诉 readline 不要引用完整的单词，如果它们是文件名 (引用文件名是默认的)。
.TP  8
\fBnosort\fP
告诉 readline 不要按字母顺序对可能完成的列表进行排序。
.TP  8
\fBnospace\fP
告诉 readline 不要将空格 (默认) 追加到行尾完成的单词。
.TP  8
\fBplusdirs\fP
在生成 compspec 定义的任何匹配项之后，将尝试完成目录名称并将任何匹配项添加到其他操作的结果中。
.RE
.TP  8
\fB\-A\fP \fIaction\fP
\fIaction\fP 可能是以下之一以生成可能完成的列表:
.RS
.TP  8
\fBalias\fP
别名。 也可以指定为 \fB\-a\fP。
.TP  8
\fBarrayvar\fP
数组变量名。
.TP  8
\fBbinding\fP
\fBReadline\fP 键绑定名称。
.TP  8
\fBbuiltin\fP
shell 内置命令的名称。 也可以指定为 \fB\-b\fP。
.TP  8
\fBcommand\fP
命令名称。 也可以指定为 \fB\-c\fP。
.TP  8
\fBdirectory\fP
目录名称。 也可以指定为 \fB\-d\fP。
.TP  8
\fBdisabled\fP
禁用的 shell 内置函数的名称。
.TP  8
\fBenabled\fP
启用的 shell 内置函数的名称。
.TP  8
\fBexport\fP
导出的名称 shell 变量。 也可以指定为 \fB\-e\fP。
.TP  8
\fBfile\fP
文件名。 也可以指定为 \fB\-f\fP。
.TP  8
\fBfunction\fP
shell 函数的名称。
.TP  8
\fBgroup\fP
组名。 也可以指定为 \fB\-g\fP。
.TP  8
\fBhelptopic\fP
\fBhelp\fP 内置程序接受的帮助主题。
.TP  8
\fBhostname\fP
主机名，取自
.SM
\fBHOSTFILE\fP shell 变量指定的文件。
.TP  8
\fBjob\fP
作业名称，如果作业控制处于活动状态。 也可以指定为 \fB\-j\fP。
.TP  8
\fBkeyword\fP
Shell 保留字。 也可以指定为 \fB\-k\fP。
.TP  8
\fBrunning\fP
如果作业控制处于活动状态，则运行作业的名称。
.TP  8
\fBservice\fP
服务名称。 也可以指定为 \fB\-s\fP。
.TP  8
\fBsetopt\fP
\fBset\fP 内置的 \fB\-o\fP 选项的有效参数。
.TP  8
\fBshopt\fP
\fBshopt\fP 内置接受的 Shell 选项名称。
.TP  8
\fBsignal\fP
信号名称。
.TP  8
\fBstopped\fP
如果作业控制处于活动状态，则停止作业的名称。
.TP  8
\fBuser\fP
用户名。 也可以指定为 \fB\-u\fP。
.TP  8
\fBvariable\fP
所有 shell 变量的名称。 也可以指定为 \fB\-v\fP。
.RE
.TP  8
\fB\-C\fP \fIcommand\fP
\fIcommand\fP 在子 shell 环境中执行，其输出用作可能的补全。
.TP  8
\fB\-F\fP \fIfunction\fP
shell 函数 \fIfunction\fP 在当前的 shell 环境中执行。 执行函数时，第一个参数 (\fB$1\fP) 是正在完成参数的命令名，第二个参数
(\fB$2\fP) 是正在完成的词，第三个参数 (\fB$3\fP) 是当前命令行正在完成的词之前的词.  完成后，将从
.SM
\fBCOMPREPLY\fP
数组变量的值中检索可能的完成。
.TP  8
\fB\-G\fP \fIglobpat\fP
路径名扩展模式 \fIglobpat\fP 被扩展以生成可能的补全。
.TP  8
\fB\-P\fP \fIprefix\fP
在应用所有其他选项后，\fIprefix\fP 被添加到每个可能的完成的开头。
.TP  8
\fB\-S\fP \fIsuffix\fP
在应用所有其他选项后，\fIsuffix\fP 将追加到每个可能的完成。
.TP  8
\fB\-W\fP \fIwordlist\fP
使用
.SM
\fBIFS\fP 特殊变量中的字符作为分隔符拆分 \fIwordlist\fP，并扩展每个结果词。 Shell 引用在 \fIwordlist\fP
中得到尊重，以便为单词提供一种机制来包含 shell 元字符或
.SM
\fBIFS\fP 值中的字符。
可能的补全是结果列表中与被补全的单词相匹配的成员。
.TP  8
\fB\-X\fP \fIfilterpat\fP
\fIfilterpat\fP 是用于路径名扩展的模式。 它应用于由前面的选项和参数生成的可能补全列表，并从列表中删除每个匹配 \fIfilterpat\fP
的补全。 \fIfilterpat\fP 中的前导 \fB!\fP 否定模式; 在这种情况下，任何不匹配 \fIfilterpat\fP 的补全都将被删除。
.PD
.PP
返回值为 true，除非提供了无效选项，提供了 \fB\-p\fP 或 \fB\-r\fP 以外的选项而没有 \fIname\fP 参数，尝试删除不存在规范的 \fIname\fP
的完成规范，或者发生错误添加完成规范。
.RE
.TP 
\fBcompopt\fP [\fB\-o\fP \fIoption\fP] [\fB\-DEI\fP] [\fB+o\fP \fIoption\fP] [\fIname\fP]
根据 \fIoption\fPs 修改每个 \fIname\fP 的完成选项，如果没有提供 \fIname\fPs，则修改当前执行的完成选项。 如果没有给出
\fIoption\fPs，则显示每个 \fIname\fP 或当前完成的完成选项。 \fIoption\fP 的可能值是对上述 \fBcomplete\fP
内置函数有效的值。 \fB\-D\fP 选项表示其他提供的选项应该应用于 `默认` 命令完成; 也就是说，尝试完成先前未定义完成的命令。 \fB\-E\fP
选项表示其他提供的选项应该应用于 `空` 命令完成; 也就是说，尝试在空白行上完成。 \fB\-I\fP
选项表示其他提供的选项应该应用于行中初始非赋值字的完成，或者在命令定界符 (例如 \fB;\fP 或 \fB|\fP) 之后，通常是命令名称完成。
.sp 1
除非提供了无效选项，否则返回值为 true，尝试修改不存在完成规范的 \fIname\fP 的选项，或者发生输出错误。
.TP 
\fBcontinue\fP [\fIn\fP]
恢复封闭 \fBfor\fP、\fBwhile\fP、\fBuntil\fP 或 \fBselect\fP 循环的下一次迭代。 如果指定了 \fIn\fP，则在 \fIn\fPth
封闭循环处继续。 \fIn\fP 必须是 \(>= 1。 如果 \fIn\fP 大于封闭循环的数量，则恢复最后一个封闭循环 (`顶层` 循环)。 除非
\fIn\fP 不大于或等于，否则返回值为 0 1.
.TP 
\fBdeclare\fP [\fB\-aAfFgiIlnrtux\fP] [\fB\-p\fP] [\fIname\fP[=\fIvalue\fP] ...]
.PD 0
.TP 
\fBtypeset\fP [\fB\-aAfFgiIlnrtux\fP] [\fB\-p\fP] [\fIname\fP[=\fIvalue\fP] ...]
.PD
声明变量或者赋予它们属性。 如果没有给出 \fIname\fPs，则显示变量的值。 \fB\-p\fP 选项将显示每个 \fIname\fP 的属性和值。 当 \fB\-p\fP
与 \fIname\fP 参数一起使用时，除 \fB\-f\fP 和 \fB\-F\fP 之外的其他选项将被忽略。 当 \fB\-p\fP 没有提供 \fIname\fP
参数时，它将显示具有附加选项指定的属性的所有变量的属性和值。 如果 \fB\-p\fP 没有提供其他选项，\fBdeclare\fP 将显示所有 shell
变量的属性和值。 \fB\-f\fP 选项将显示限制为 shell 函数。 \fB\-F\fP 选项禁止显示函数定义; 仅打印函数名称和属性。 如果使用
\fBshopt\fP 启用 \fBextdebug\fP shell 选项，则还会显示定义每个 \fIname\fP 的源文件名和行号。 \fB\-F\fP 选项表示
\fB\-f\fP。 \fB\-g\fP 选项强制在全局范围内创建或修改变量，即使在 shell 函数中执行 \fBdeclare\fP 也是如此。
在所有其他情况下都将被忽略。 \fB\-I\fP 选项导致局部变量继承周围作用域中具有相同 \fIname\fP 的任何现有变量的属性 (\fInameref\fP
属性除外) 和值。 如果不存在现有变量，则最初未设置局部变量。 以下选项可用于将输出限制为具有指定属性的变量或赋予变量属性:
.RS
.PD 0
.TP 
\fB\-a\fP
每个 \fIname\fP 都是一个索引数组变量 (参见上面的 \fBArrays\fP)。
.TP 
\fB\-A\fP
每个 \fIname\fP 都是一个关联数组变量 (参见上面的 \fBArrays\fP)。
.TP 
\fB\-f\fP
仅使用函数名称。
.TP 
\fB\-i\fP
该变量被视为整数; 算术评估 (见上面的
.SM
\fBARITHMETIC EVALUATION\fP) 是在变量赋值时执行的。
.TP 
\fB\-l\fP
为变量赋值时，所有大写字符都将转换为小写。 大写属性被禁用。
.TP 
\fB\-n\fP
为每个 \fIname\fP 赋予 \fInameref\fP 属性，使其成为引用另一个变量的名称。 另一个变量由 \fIname\fP 的值定义。 对 \fIname\fP
的所有引用、赋值和属性修改，除了使用或更改 \fB\-n\fP 属性本身的那些，都是在 \fIname\fP's 值引用的变量上执行的。 nameref
属性不能应用于数组变量。
.TP 
\fB\-r\fP
将 \fIname\fPs 设置为只读。 这些名称不能通过后续赋值语句或取消设置来赋值。
.TP 
\fB\-t\fP
为每个 \fIname\fP 赋予 \fItrace\fP 属性。 Traced 函数从调用 shell 继承了 \fBDEBUG\fP 和 \fBRETURN\fP 陷阱。
trace 属性对于变量没有特殊意义。
.TP 
\fB\-u\fP
为变量赋值时，所有小写字符都将转换为大写。 小写属性被禁用。
.TP 
\fB\-x\fP
标记 \fIname\fPs 以通过环境导出到后续命令。
.PD
.PP
使用 `+` 而不是 `\-` 会关闭该属性，但 \fB+a\fP 和 \fB+A\fP 可能不会用于销售损坏数组变量并且 \fB+r\fP 不会删除只读属性。
当在一个函数中使用时，\fBdeclare\fP 和 \fBtypeset\fP 使每个 \fIname\fP 成为局部的，就像 \fBlocal\fP 命令一样，除非提供了
\fB\-g\fP 选项。 如果变量名称后跟 =\fIvalue\fP，则变量的值设置为 \fIvalue\fP。 当使用 \fB\-a\fP 或 \fB\-A\fP
和复合赋值语法创建数组变量时，额外的属性只有在后续赋值后才会生效。 除非遇到无效选项，否则返回值为 0，尝试使用定义一个函数
.if  n ``\-f foo=bar'',
.if  t \f(CW\-f foo=bar\fP,
试图为只读变量赋值，试图在不使用复合赋值语法的情况下为数组变量赋值 (参见上面的 \fBArrays\fP)，其中一个 \fInames\fP 不是有效的
shell 变量名，一个试图关闭只读变量的只读状态，试图关闭数组变量的数组状态，或试图用 \fB\-f\fP 显示不存在的函数。
.RE
.TP 
\fBdirs [\-clpv] [+\fP\fIn\fP\fB] [\-\fP\fIn\fP\fB]\fP
没有选项，显示当前记住的目录列表。 默认显示在一行中，目录名称由空格分隔。 使用 \fBpushd\fP 命令将目录添加到列表中; \fBpopd\fP
命令从列表中删除条目。 当前目录始终是栈中的第一个目录。
.RS
.PD 0
.TP 
\fB\-c\fP
通过删除所有条目来清除目录栈。
.TP 
\fB\-l\fP
使用完整路径名生成列表; 默认列表格式使用波浪号来表示主目录。
.TP 
\fB\-p\fP
打印目录栈，每行一个条目。
.TP 
\fB\-v\fP
打印目录栈，每行一个条目，在每个条目前加上它在栈中的索引。
.TP 
\fB+\fP\fIn\fP
显示在不带选项调用时从 \fBdirs\fP 显示的列表左侧开始计数的 \fIn\fPth 条目，从零开始。
.TP 
\fB\-\fP\fIn\fP
显示在不带选项调用时从 \fBdirs\fP 显示的列表右侧开始计数的 \fIn\fPth 条目，从零开始。
.PD
.PP
除非提供了无效选项或 \fIn\fP 索引超出目录栈的末尾，否则返回值为 0。
.RE
.TP 
\fBdisown\fP [\fB\-ar\fP] [\fB\-h\fP] [\fIjobspec\fP ... | \fIpid\fP ... ]
在没有选项的情况下，从活动作业表中删除每个 \fIjobspec\fP。 如果 \fIjobspec\fP 不存在，并且既没有提供 \fB\-a\fP 也没有提供
\fB\-r\fP 选项，则使用 \fIcurrent job\fP。 如果给出了 \fB\-h\fP 选项，则每个 \fIjobspec\fP 不会从表中删除，但会被标记，以便在
shell 收到
.SM
\fBSIGHUP\fP 时不会将
.SM
\fBSIGHUP\fP 发送到作业。 如果没有提供 \fIjobspec\fP，则
\fB\-a\fP 选项表示删除或标记所有作业; 没有 \fIjobspec\fP 参数的 \fB\-r\fP 选项将操作限制为正在运行的作业。 除非 \fIjobspec\fP
未指定有效作业，否则返回值为 0。
.TP 
\fBecho\fP [\fB\-neE\fP] [\fIarg\fP ...]
输出 \fIarg\fPs，以空格分隔，后跟一个换行符。 除非发生写入错误，否则返回状态为 0。 如果指定了 \fB\-n\fP，则禁止尾随换行符。 如果给出
\fB\-e\fP 选项，则启用对以下反斜杠转义字符的解释。 \fB\-E\fP 选项禁用对这些转义字符的解释，即使在默认解释它们的系统上也是如此。
\fBxpg_echo\fP shell 选项可用于动态确定 \fBecho\fP 是否默认扩展这些转义字符。 \fBecho\fP 不会将 \fB\-\-\fP 解释为选项结束。
\fBecho\fP 解释以下转义序列:
.RS
.PD 0
.TP 
\fB\ea\fP
警报 (bell)
.TP 
\fB\eb\fP
backspace
.TP 
\fB\ec\fP
抑制进一步的输出
.TP 
\fB\ee\fP
.TP 
\fB\eE\fP
转义字符
.TP 
\fB\ef\fP
换页
.TP 
\fB\en\fP
新队
.TP 
\fB\er\fP
回车
.TP 
\fB\et\fP
水平制表符
.TP 
\fB\ev\fP
垂直制表符
.TP 
\fB\e\e\fP
backslash
.TP 
\fB\e0\fP\fInnn\fP
值为八进制值 \fInnn\fP (零到三个八进制数字) 的八位字符
.TP 
\fB\ex\fP\fIHH\fP
值为十六进制值 \fIHH\fP (一个或两个十六进制数字) 的八位字符
.TP 
\fB\eu\fP\fIHHHH\fP
值为十六进制值 \fIHHHH\fP (一到四位十六进制数字) 的 Unicode (ISO/IEC 10646) 字符
.TP 
\fB\eU\fP\fIHHHHHHHH\fP
值为十六进制值 \fIHHHHHHHH\fP (一到八个十六进制数字) 的 Unicode (ISO/IEC 10646) 字符
.PD
.RE
.TP 
\fBenable\fP [\fB\-a\fP] [\fB\-dnps\fP] [\fB\-f\fP \fIfilename\fP] [\fIname\fP ...]
启用和禁用内置 shell 命令。 禁用内置命令允许在不指定完整路径名的情况下执行与 shell 内置命令同名的磁盘命令，即使 shell
通常在磁盘命令之前搜索内置命令。 如果使用 \fB\-n\fP，则每个 \fIname\fP 都被禁用; 否则，启用 \fInames\fP。 例如，要使用通过
.SM
\fBPATH\fP 而不是 shell 内置版本找到的 \fBtest\fP 二进制文件，运行
.if  t \f(CWenable -n test\fP.
.if  n ``enable -n test''.
\fB\-f\fP 选项意味着在支持动态加载的系统上从共享对象 \fIfilename\fP 加载新的内置命令 \fIname\fP。 \fB\-d\fP 选项将删除以前用
\fB\-f\fP 加载的内置函数。 如果没有给出 \fIname\fP 参数，或者如果提供了 \fB\-p\fP 选项，则会打印 shell 内置函数列表。
在没有其他选项参数的情况下，该列表包含所有启用的 shell 内置函数。 如果提供 \fB\-n\fP，则仅打印禁用的内置函数。 如果提供
\fB\-a\fP，则打印的列表包括所有内建函数，并指示每个内建函数是否已启用。 如果提供 \fB\-s\fP，则输出仅限于 POSIX \fIspecial\fP
内置函数。 返回值为 0，除非 \fIname\fP 不是 shell 内置函数或从共享对象加载新内置函数时出错。
.TP 
\fBeval\fP [\fIarg\fP ...]
\fIarg\fPs 被读取并连接在一起成为一个命令。 然后 shell 读取并执行该命令，其退出状态作为 \fBeval\fP 的值返回。 如果没有
\fIargs\fP，或者只有 null 参数，\fBeval\fP 返回 0.
.TP 
\fBexec\fP [\fB\-cl\fP] [\fB\-a\fP \fIname\fP] [\fIcommand\fP [\fIarguments\fP]]
如果指定了 \fIcommand\fP，它将替换 shell。 没有创建新进程。 \fIarguments\fP 成为 \fIcommand\fP 的参数。 如果提供了
\fB\-l\fP 选项，则 shell 会在传递给 \fIcommand\fP 的第零个参数的开头放置一个破折号。 这就是 \fIlogin\fP(1) 所做的。
\fB\-c\fP 选项导致 \fIcommand\fP 在空环境下执行。 如果提供了 \fB\-a\fP，则 shell 将 \fIname\fP
作为第零个参数传递给已执行的命令。 如果由于某种原因无法执行 \fIcommand\fP，则会退出非交互式 shell，除非启用 \fBexecfail\fP
shell 选项。 在这种情况下，它返回失败。 如果文件无法执行，交互式 shell 将返回失败。 如果 \fBexec\fP 失败，子 shell
将无条件退出。 如果不指定 \fIcommand\fP，任何重定向都在当前 shell 生效，返回状态为 0。 如果有重定向错误，返回状态为 1.
.TP 
\fBexit\fP [\fIn\fP]
导致 shell 以 \fIn\fP 状态退出。 如果省略 \fIn\fP，则退出状态是最后执行的命令的状态。 在 shell 终止之前执行
.SM
\fBEXIT\fP 上的陷阱。
.TP 
\fBexport\fP [\fB\-fn\fP\^] [\fIname\fP[=\fIword\fP]] ...
.PD 0
.TP 
\fBexport \-p\fP
.PD
提供的 \fInames\fP 被标记为自动导出到随后执行的命令的环境中。 如果给出了 \fB\-f\fP 选项，则 \fInames\fP 指的是函数。 如果没有给出
\fInames\fP，或者如果提供了 \fB\-p\fP 选项，则打印所有导出变量的名称列表。 \fB\-n\fP 选项导致从每个 \fIname\fP 中删除导出属性。
如果变量名称后跟 =\fIword\fP，则变量的值设置为 \fIword\fP。 \fBexport\fP 返回退出状态 0，除非遇到无效选项，其中一个
\fInames\fP 不是有效的 shell 变量名，或者 \fB\-f\fP 提供了一个不是函数的 \fIname\fP。
.TP 
\fBfc\fP [\fB\-e\fP \fIename\fP] [\fB\-lnr\fP] [\fIfirst\fP] [\fIlast\fP]
.PD 0
.TP 
\fBfc\fP \fB\-s\fP [\fIpat\fP=\fIrep\fP] [\fIcmd\fP]
.PD
第一种形式从历史列表中选择从 \fIfirst\fP 到 \fIlast\fP 的一系列命令并显示或编辑并重新执行它们。 \fIFirst\fP 和 \fIlast\fP
可以指定为字符串 (以定位以该字符串开头的最后一个命令) 或数字 (历史列表的索引，其中 negative 数字用作当前命令编号的偏移量)。
列出时，\fIfirst\fP 或 \fIlast\fP 为 0 相当于 \-1，\-0 相当于当前命令 (通常为 \fBfc\fP 命令) ; 否则 0 等同于 \-1，\-0
无效。 如果没有指定 \fIlast\fP，则设置为当前命令列表 (以便
.if  n ``fc \-l \-10''
.if  t \f(CWfc \-l \-10\fP
打印最后 10 个命令)，否则为 \fIfirst\fP。 如果不指定 \fIfirst\fP，编辑时设为上一条命令，列表时设为 \-16。
.sp 1
\fB\-n\fP 选项在列出时抑制命令编号。 \fB\-r\fP 选项颠倒命令的顺序。 如果给出了 \fB\-l\fP 选项，命令将在标准输出中列出。
否则，将在包含这些命令的文件上调用 \fIename\fP 给出的编辑器。 如果未给出 \fIename\fP，则使用
.SM
\fBFCEDIT\fP
变量的值，如果未设置
.SM
\fBFCEDIT\fP，则使用
.SM
\fBEDITOR\fP 的值。 如果两个变量都没有设置，
.FN vi
用来。 编辑完成后，回显并执行编辑的命令。
.sp 1
在第二种形式中，\fIcommand\fP 在每个 \fIpat\fP 实例被 \fIrep\fP 替换后重新执行。 \fICommand\fP 的解释与上面的
\fIfirst\fP 相同。 一个有用的别名是
.if  n ``r="fc -s"'',
.if  t \f(CWr='fc \-s'\fP,
这样打字
.if  n ``r cc''
.if  t \f(CWr cc\fP
运行以开头的最后一个命令
.if  n ``cc''
.if  t \f(CWcc\fP
和打字
.if  n ``r''
.if  t \f(CWr\fP
重新执行最后一条命令。
.sp 1
如果使用第一种形式，则返回值为 0，除非遇到无效选项或 \fIfirst\fP 或 \fIlast\fP 指定越界的历史记录行。 如果提供了 \fB\-e\fP
选项，则返回值是最后执行的命令的值，如果命令的临时文件发生错误，则返回失败。 如果使用第二种形式，则返回状态是命令重新执行的状态，除非 \fIcmd\fP
没有指定有效的历史行，在这种情况下 \fBfc\fP 返回失败。
.TP 
\fBfg\fP [\fIjobspec\fP]
在前台恢复 \fIjobspec\fP，并使其成为当前作业。 如果 \fIjobspec\fP 不存在，则使用 shell 的 \fIcurrent job\fP 概念。
返回值是放在前台的命令的值，如果在禁用作业控制时运行，或者在启用作业控制时运行，如果 \fIjobspec\fP 未指定有效作业或 \fIjobspec\fP
指定在没有作业控制的情况下启动的作业，则返回值.
.TP 
\fBgetopts\fP \fIoptstring\fP \fIname\fP [\fIarg ...\fP]
shell 程序使用 \fBgetopts\fP 来解析位置参数。 \fIoptstring\fP 包含要识别的选项字符;
如果一个字符后跟一个冒号，则该选项应该有一个参数，它应该用空格与它分开。 冒号和问号字符不能用作选项字符。 每次调用时，\fBgetopts\fP
将下一个选项放在 shell 变量 \fIname\fP 中，如果 \fIname\fP 不存在则初始化，下一个要处理的参数的索引放入变量
.SM
\fBOPTIND\fP 中。 每次调用 shell 或 shell 脚本时，
.SM
\fBOPTIND\fP 都被初始化为 1。 When an
option requires an 参数，\fBgetopts\fP places that 参数 into the variable
.SM
\fBOPTARG\fP.  shell 不会自动复位
.SM
\fBOPTIND\fP; 如果要使用一组新参数，则必须在同一个 shell 调用中多次调用
\fBgetopts\fP 之间手动重置它。
.sp 1
当遇到选项结束时，\fBgetopts\fP 以大于零的返回值退出。
.SM
\fBOPTIND\fP 设置为第一个非选项参数的索引，\fIname\fP 设置为
?。
.sp 1
\fBgetopts\fP 通常解析位置参数，但如果提供更多参数作为 \fIarg\fP 值，则 \fBgetopts\fP 解析这些参数。
.sp 1
\fBgetopts\fP 可以通过两种方式报告错误。 如果 \fIoptstring\fP 的第一个字符是冒号，则使用 \fIsilent\fP 错误报告。
在正常操作中，遇到无效选项或缺少选项参数时会打印诊断消息。 如果变量
.SM
\fBOPTERR\fP 设置为 0，则不会显示错误消息，即使
\fIoptstring\fP 的第一个字符不是冒号。
.sp 1
如果看到无效选项，\fBgetopts\fP 放置? 进入 \fIname\fP，如果不是静默，则打印一条错误消息并取消设置
.SM
\fBOPTARG\fP。
如果 \fBgetopts\fP 是无声的，则将找到的选项字符放在
.SM
\fBOPTARG\fP 中并且不打印诊断消息。
.sp 1
如果未找到所需的参数，并且 \fBgetopts\fP 不静音，则在 \fIname\fP 中放置一个问号 (\^\fB?\fP\^)，取消设置
.SM
\fBOPTARG\fP，并打印一条诊断消息。 如果 \fBgetopts\fP 是无声的，则在 \fIname\fP 中放置一个冒号 (\^\fB:\fP\^)，并将
.SM
\fBOPTARG\fP 设置为找到的选项字符。
.sp 1
如果找到指定或未指定的选项，则 \fBgetopts\fP 返回真。 如果遇到选项结尾或发生错误，则返回 false。
.TP 
\fBhash\fP [\fB\-lr\fP] [\fB\-p\fP \fIfilename\fP] [\fB\-dt\fP] [\fIname\fP]
每次调用 \fBhash\fP 时，通过搜索 \fB$PATH\fP 中的目录确定并记住命令 \fIname\fP 的完整路径名。 任何以前记住的路径名都将被丢弃。
如果提供了 \fB\-p\fP 选项，则不执行路径搜索，并且 \fIfilename\fP 用作命令的完整文件名。 \fB\-r\fP 选项导致 shell
忘记所有记住的位置。 \fB\-d\fP 选项导致 shell 忘记每个 \fIname\fP 的记忆位置。 如果提供了 \fB\-t\fP 选项，则打印每个 \fIname\fP
对应的完整路径名。 如果 \fB\-t\fP 提供了多个 \fIname\fP 参数，则 \fIname\fP 将打印在哈希完整路径名之前。 \fB\-l\fP
选项使输出以一种可重复用作输入的格式显示。 如果没有给出参数，或者如果只提供 \fB\-l\fP，则打印有关已记住命令的信息。 除非未找到 \fIname\fP
或提供了无效选项，否则返回状态为真。
.TP 
\fBhelp\fP [\fB\-dms\fP] [\fIpattern\fP]
显示有关内置命令的有用信息。 如果指定了 \fIpattern\fP，则 \fBhelp\fP 给出与 \fIpattern\fP 匹配的所有命令的详细帮助;
否则打印所有内置函数和 shell 控制结构的帮助。
.RS
.PD 0
.TP 
\fB\-d\fP
显示每个 \fIpattern\fP 的简短描述
.TP 
\fB\-m\fP
以类似联机帮助页的格式显示每个 \fIpattern\fP 的描述
.TP 
\fB\-s\fP
仅显示每个 \fIpattern\fP 的简短使用概要
.PD
.PP
除非没有命令与 \fIpattern\fP 匹配，否则返回状态为 0。
.RE
.TP 
\fBhistory [\fP\fIn\fP\fB]\fP
.PD 0
.TP 
\fBhistory\fP \fB\-c\fP
.TP 
\fBhistory \-d\fP \fIoffset\fP
.TP 
\fBhistory \-d\fP \fIstart\fP\-\fIend\fP
.TP 
\fBhistory\fP \fB\-anrw\fP [\fIfilename\fP]
.TP 
\fBhistory\fP \fB\-p\fP \fIarg\fP [\fIarg ...\fP]
.TP 
\fBhistory\fP \fB\-s\fP \fIarg\fP [\fIarg ...\fP]
.PD
如果没有选项，则显示带有行号的命令历史列表。 带有 \fB*\fP 的行已被修改。 \fIn\fP 的参数仅列出最后的 \fIn\fP 行。 如果 shell 变量
.SM
\fBHISTTIMEFORMAT\fP 已设置且不为空，则它用作 \fIstrftime\fP(3)
的格式字符串以显示与每个显示的历史记录条目相关联的时间戳。 在格式化的时间戳和历史行之间不打印中间空白。 如果提供了
\fIfilename\fP，它将用作历史文件的名称; 如果不是，则使用
.SM
\fBHISTFILE\fP 的值。 选项 (如果提供) 具有以下含义:
.RS
.PD 0
.TP 
\fB\-c\fP
通过删除所有条目来清除历史列表。
.TP 
\fB\-d\fP \fIoffset\fP
删除位置 \fIoffset\fP 的历史条目。 如果 \fIoffset\fP 是 negative，它被解释为相对于比上一个历史位置大 1 的位置，所以
negative 索引从历史末尾倒数，\-1 的索引指的是当前的 \fBhistory \-d\fP 命令。
.TP 
\fB\-d\fP \fIstart\fP\-\fIend\fP
删除位置 \fIstart\fP 和 \fIend\fP 之间的历史条目，包括在内。 \fIstart\fP 和 \fIend\fP 的正值和 negative
值的解释如上所述。
.TP 
\fB\-a\fP
将 `新` 历史行追加到历史文件。 这些是自当前 \fBbash\fP 会话开始以来输入的历史行，但尚未追加到历史文件中。
.TP 
\fB\-n\fP
将尚未从历史文件中读取的历史行读取到当前历史列表中。 这些是自当前 \fBbash\fP 会话开始以来追加到历史文件的行。
.TP 
\fB\-r\fP
读取历史文件的内容并将其追加到当前历史列表中。
.TP 
\fB\-w\fP
将当前历史列表写入历史文件，覆盖历史文件的内容。
.TP 
\fB\-p\fP
对以下 \fIargs\fP 执行历史替换并将结果显示在标准输出上。 不将结果存储在历史列表中。 必须引用每个 \fIarg\fP 以禁用正常的历史扩展。
.TP 
\fB\-s\fP
将 \fIargs\fP 作为单个条目存储在历史列表中。 在添加 \fIargs\fP 之前删除历史列表中的最后一个命令。
.PD
.PP
如果设置了
.SM
\fBHISTTIMEFORMAT\fP 变量，则将与每个历史条目关联的时间戳信息写入历史文件，并用历史注释字符标记。
读取历史文件时，以历史注释字符开头紧跟数字的行被解释为后续历史条目的时间戳。 返回值为 0，除非遇到无效选项，读取或写入历史文件时发生错误，无效的
\fIoffset\fP 作为参数提供给 \fB\-d\fP，或者作为参数提供给 \fB\-p\fP 的历史扩展失败。
.RE
.TP 
\fBjobs\fP [\fB\-lnprs\fP] [ \fIjobspec\fP ... ]
.PD 0
.TP 
\fBjobs\fP \fB\-x\fP \fIcommand\fP [ \fIargs\fP ... ]
.PD
第一个表格列出了活动的工作。 选项含义如下:
.RS
.PD 0
.TP 
\fB\-l\fP
除了正常信息外，还列出进程 ID。
.TP 
\fB\-n\fP
仅显示有关自上次通知用户其状态以来已更改状态的作业的信息。
.TP 
\fB\-p\fP
仅列出作业的进程组组长的进程 ID。
.TP 
\fB\-r\fP
仅显示正在运行的作业。
.TP 
\fB\-s\fP
仅显示停止的作业。
.PD
.PP
如果给出 \fIjobspec\fP，则输出仅限于有关该作业的信息。 除非遇到无效选项或提供无效 \fIjobspec\fP，否则返回状态为 0。
.PP
如果提供了 \fB\-x\fP 选项，\fBjobs\fP 会将在 \fIcommand\fP 或 \fIargs\fP 中找到的任何 \fIjobspec\fP 替换为相应的进程组
ID，并执行 \fIcommand\fP 并将其传递给 \fIargs\fP，并返回其退出状态。
.RE
.TP 
\fBkill\fP [\fB\-s\fP \fIsigspec\fP | \fB\-n\fP \fIsignum\fP | \fB\-\fP\fIsigspec\fP] [\fIpid\fP | \fIjobspec\fP] ...
.PD 0
.TP 
\fBkill\fP \fB\-l\fP|\fB\-L\fP [\fIsigspec\fP | \fIexit_status\fP]
.PD
将 \fIsigspec\fP 或 \fIsignum\fP 命名的信号发送给 \fIpid\fP 或 \fIjobspec\fP 命名的进程。 \fIsigspec\fP
是不区分大小写的信号名称，例如
.SM
\fBSIGKILL\fP (带或不带
.SM
\fBSIG\fP 前缀) 或信号编号; \fIsignum\fP
是信号编号。 如果 \fIsigspec\fP 不存在，则假定为
.SM
\fBSIGTERM\fP。 \fB\-l\fP 的一个参数列出了信号名称。 给定
\fB\-l\fP 时，若有参数，则列出该参数对应的信号名称，返回状态为 0。 \fIexit_status\fP 参数到 \fB\-l\fP
是一个数字，指定信号编号或由信号终止的进程的退出状态。 \fB\-L\fP 选项等同于 \fB\-l\fP。 如果至少一个信号被成功发送，\fBkill\fP 返回
true，如果发生错误或遇到无效选项，则返回 false。
.TP 
\fBlet\fP \fIarg\fP [\fIarg\fP ...]
每个 \fIarg\fP 都是一个要计算的算术表达式 (参见上面的
.SM
\fBARITHMETIC EVALUATION\fP)。 如果最后一个
\fIarg\fP 的计算结果为 0，则 \fBlet\fP 返回 1; 否则返回 0。
.TP 
\fBlocal\fP [\fIoption\fP] [\fIname\fP[=\fIvalue\fP] ... | \- ]
对于每个参数，创建一个名为 \fIname\fP 的局部变量，并分配给 \fIvalue\fP。 \fIoption\fP 可以是 \fBdeclare\fP 接受的任何选项。
当在一个函数中使用 \fBlocal\fP 时，它会导致变量 \fIname\fP 的可见作用域仅限于该函数及其子项。 如果 \fIname\fP 为 \-，则 shell
选项集在调用 \fBlocal\fP 的函数中设置为本地: 使用函数内的 \fBset\fP 内置函数更改的 shell 选项在函数返回时恢复为原始值。
恢复的效果就好像执行了一系列 \fBset\fP 命令以恢复在函数之前的值。 在没有操作数的情况下，\fBlocal\fP 将本地变量列表写入标准输出。
不在函数内时使用 \fBlocal\fP 是错误的。 返回状态为 0，除非 \fBlocal\fP 在函数之外使用，提供了无效的 \fIname\fP，或者
\fIname\fP 是只读变量。
.TP 
\fBlogout\fP
退出一个登录 shell。
.TP 
\fBmapfile\fP [\fB\-d\fP \fIdelim\fP] [\fB\-n\fP \fIcount\fP] [\fB\-O\fP \fIorigin\fP] [\fB\-s\fP \fIcount\fP] [\fB\-t\fP] [\fB\-u\fP \fIfd\fP] [\fB\-C\fP \fIcallback\fP] [\fB\-c\fP \fIquantum\fP] [\fIarray\fP]
.PD 0
.TP 
\fBreadarray\fP [\fB\-d\fP \fIdelim\fP] [\fB\-n\fP \fIcount\fP] [\fB\-O\fP \fIorigin\fP] [\fB\-s\fP \fIcount\fP] [\fB\-t\fP] [\fB\-u\fP \fIfd\fP] [\fB\-C\fP \fIcallback\fP] [\fB\-c\fP \fIquantum\fP] [\fIarray\fP]
.PD
从标准输入读取行到索引数组变量 \fIarray\fP，或者如果提供了 \fB\-u\fP 选项，则从文件描述符 \fIfd\fP 读取行。 变量
.SM
\fBMAPFILE\fP 是默认的 \fIarray\fP。 选项 (如果提供) 具有以下含义:
.RS
.PD 0
.TP 
\fB\-d\fP
\fIdelim\fP 的第一个字符用于终止每个输入行，而不是换行符。 如果 \fIdelim\fP 为空字符串，则 \fBmapfile\fP 读取 NUL
字符时将终止一行。
.TP 
\fB\-n\fP
最多复制 \fIcount\fP 行。 如果 \fIcount\fP 为 0，则复制所有行。
.TP 
\fB\-O\fP
在索引 \fIorigin\fP 处开始分配给 \fIarray\fP。 默认索引是 0.
.TP 
\fB\-s\fP
丢弃读取的第一个 \fIcount\fP 行。
.TP 
\fB\-t\fP
从读取的每一行中删除尾随 \fIdelim\fP (默认换行符)。
.TP 
\fB\-u\fP
从文件描述符 \fIfd\fP 而不是标准输入读取行。
.TP 
\fB\-C\fP
每次读取 \fIquantum\fP 行时计算 \fIcallback\fP。 \fB\-c\fP 选项指定 \fIquantum\fP。
.TP 
\fB\-c\fP
指定每个调用到 \fIcallback\fP 之间读取的行数。
.PD
.PP
如果在没有 \fB\-c\fP 的情况下指定 \fB\-C\fP，则默认量程为 5000。 评估 \fIcallback\fP
时，会提供下一个要分配的数组元素的索引以及要分配给该元素的行作为附加参数。 \fIcallback\fP 在读取行之后但在分配数组元素之前进行计算。
.PP
如果没有提供明确的来源，\fBmapfile\fP 将在分配给它之前清除 \fIarray\fP。
.PP
\fBmapfile\fP 成功返回，除非提供了无效选项或选项参数，\fIarray\fP 无效或不可分配，或者 \fIarray\fP 不是索引数组。
.RE
.TP 
\fBpopd\fP [\-\fBn\fP] [+\fIn\fP] [\-\fIn\fP]
从目录栈中删除条目。 没有参数，从栈中删除顶层目录，并对新的顶层目录执行 \fBcd\fP。 参数 (如果提供) 具有以下含义:
.RS
.PD 0
.TP 
\fB\-n\fP
从栈中删除目录时抑制目录的正常更改，以便仅操作栈。
.TP 
\fB+\fP\fIn\fP
删除从 \fBdirs\fP 显示的列表左侧开始计数的 \fIn\fPth 条目，从零开始。 例如:
.if  n ``popd +0''
.if  t \f(CWpopd +0\fP
删除第一个目录，
.if  n ``popd +1''
.if  t \f(CWpopd +1\fP
第二。
.TP 
\fB\-\fP\fIn\fP
删除从 \fBdirs\fP 显示的列表右侧开始计数的 \fIn\fPth 条目，从零开始。 例如:
.if  n ``popd -0''
.if  t \f(CWpopd -0\fP
删除最后一个目录，
.if  n ``popd -1''
.if  t \f(CWpopd -1\fP
倒数第二个。
.PD
.PP
如果 \fBpopd\fP 命令成功，还会执行 \fBdirs\fP，返回状态为 0。 如果遇到无效选项、目录栈为空、指定了不存在的目录栈条目或目录更改失败，则
\fBpopd\fP 返回 false。
.RE
.TP 
\fBprintf\fP [\fB\-v\fP \fIvar\fP] \fIformat\fP [\fIarguments\fP]
在 \fIformat\fP 的控制下将格式化后的 \fIarguments\fP 写入标准输出。 \fB\-v\fP 选项导致将输出分配给变量 \fIvar\fP
而不是打印到标准输出。
.sp 1
\fIformat\fP 是一个字符串，包含三种类型的对象:
普通字符，简单地复制到标准输出，字符转义序列，转换并复制到标准输出，格式规范，每一种都会导致打印下一个连续 \fIargument\fP。 除了标准的
\fIprintf\fP(1) 格式规范外，\fBprintf\fP 还解释了以下扩展:
.RS
.PD 0
.TP 
\fB%b\fP
导致 \fBprintf\fP 以与 \fBecho \-e\fP 相同的方式在相应的 \fIargument\fP 中扩展反斜杠转义序列。
.TP 
\fB%q\fP
使 \fBprintf\fP 以可重复用作 shell 输入的格式输出相应的 \fIargument\fP。
.TP 
\fB%(\fP\fIdatefmt\fP\fB)T\fP
导致 \fBprintf\fP 输出使用 \fIdatefmt\fP 作为 \fIstrftime\fP(3) 的格式字符串产生的日期时间字符串。 相应的
\fIargument\fP 是一个整数，表示自纪元以来的秒数。 可以使用两个特殊的参数值: \-1 代表当前时间，\-2 代表调用 shell 的时间。
如果未指定参数，则转换的行为就像已给出 \-1 一样。 这是通常的 \fBprintf\fP 行为的例外。
.PD
.PP
%b、%q 和 %T 指令都使用格式规范中的字段宽度和精度参数，并从 (或使用该宽度的字段) 扩展参数中写入那么多字节，通常包含比原始参数更多的字符。
.PP
非字符串格式说明符的参数被视为 C 常量，但允许使用前导加号或减号，如果前导字符是单引号或双引号，则该值是后续字符的 ASCII 值。
.PP
\fIformat\fP 在必要时被重新使用以消耗所有 \fIarguments\fP。 如果 \fIformat\fP 需要比提供的更多的
\fIarguments\fP，则额外的格式规范的行为就好像已提供了零值或空字符串 (视情况而定)。 成功时返回值为零，失败时为非零。
.RE
.TP 
\fBpushd\fP [\fB\-n\fP] [+\fIn\fP] [\-\fIn\fP]
.PD 0
.TP 
\fBpushd\fP [\fB\-n\fP] [\fIdir\fP]
.PD
将目录添加到目录栈的顶部，或旋转栈，使新栈顶成为当前工作目录。 如果没有参数，\fBpushd\fP 交换前两个目录并返回 0，除非目录栈为空。 参数
(如果提供) 具有以下含义:
.RS
.PD 0
.TP 
\fB\-n\fP
在旋转或向栈添加目录时抑制目录的正常更改，以便仅操作栈。
.TP 
\fB+\fP\fIn\fP
旋转栈，使 \fIn\fPth 目录 (从 \fBdirs\fP 显示的列表左侧开始计数，从零开始) 位于顶部。
.TP 
\fB\-\fP\fIn\fP
旋转栈，使 \fIn\fPth 目录 (从 \fBdirs\fP 显示的列表右侧开始计数，从零开始) 位于顶部。
.TP 
\fIdir\fP
将 \fIdir\fP 添加到顶部的目录栈，使其成为新的当前工作目录，就好像它已作为参数提供给 \fBcd\fP 内置函数一样。
.PD
.PP
如果 \fBpushd\fP 命令成功，也会执行 \fBdirs\fP。 如果使用第一种形式，\fBpushd\fP 返回 0，除非 cd 到 \fIdir\fP 失败。
对于第二种形式，\fBpushd\fP 返回 0，除非目录栈为空，指定的目录栈元素不存在，或者目录更改为指定的新当前目录失败。
.RE
.TP 
\fBpwd\fP [\fB\-LP\fP]
打印当前工作目录的绝对路径名。 如果提供了 \fB\-P\fP 选项或启用了 \fBset\fP 内置命令的 \fB\-o physical\fP
选项，则打印的路径名不包含符号链接。 如果使用 \fB\-L\fP 选项，打印的路径名可能包含符号链接。
除非在读取当前目录的名称时发生错误或提供了无效选项，否则返回状态为 0。
.TP 
\fBread\fP [\fB\-ers\fP] [\fB\-a\fP \fIaname\fP] [\fB\-d\fP \fIdelim\fP] [\fB\-i\fP \fItext\fP] [\fB\-n\fP \fInchars\fP] [\fB\-N\fP \fInchars\fP] [\fB\-p\fP \fIprompt\fP] [\fB\-t\fP \fItimeout\fP] [\fB\-u\fP \fIfd\fP] [\fIname\fP ...]
从标准输入读取一行，或者从作为参数提供给 \fB\-u\fP 选项的文件描述符 \fIfd\fP 中读取一行，按照上面在 \fBWord Splitting\fP
下的描述拆分成单词，第一个单词分配给第一个 \fIname\fP，第二个单词分配给第二个 \fIname\fP 等。
如果单词多于名称，则将剩余的单词及其中间的定界符分配给最后一个 \fIname\fP。 如果从输入流中读取的单词少于名称，则剩余的名称将分配空值。
.SM
\fBIFS\fP 中的字符用于使用 shell 用于扩展的相同规则将行拆分为单词 (上面在 \fBWord Splitting\fP).
反斜杠字符 (\fB\e\fP) 可用于删除下一个字符读取和行继续的任何特殊含义。 选项 (如果提供) 具有以下含义:
.RS
.PD 0
.TP 
\fB\-a \fP\fIaname\fP
这些词被分配给数组变量 \fIaname\fP 的顺序索引，从 0 开始。 \fIaname\fP 在分配任何新值之前未设置。 其他 \fIname\fP 参数被忽略。
.TP 
\fB\-d \fP\fIdelim\fP
\fIdelim\fP 的第一个字符用于终止输入行，而不是换行符。 如果 \fIdelim\fP 为空字符串，则 \fBread\fP 读取 NUL 字符时将终止一行。
.TP 
\fB\-e\fP
如果标准输入来自终端，则使用 \fBreadline\fP (参见上面的
.SM
\fBREADLINE\fP) 获取该行。 Readline 使用当前
(或默认，如果行编辑以前未激活) 编辑设置，但使用 Readline 的默认文件名完成。
.TP 
\fB\-i \fP\fItext\fP
如果 \fBreadline\fP 被用来读取该行，则 \fItext\fP 在编辑开始之前被放入编辑缓冲区。
.TP 
\fB\-n \fP\fInchars\fP
\fBread\fP 在读取 \fInchars\fP 个字符后返回，而不是等待完整的输入行，但如果在分隔符之前读取的字符少于 \fInchars\fP
个字符，则使用分隔符。
.TP 
\fB\-N \fP\fInchars\fP
\fBread\fP 在准确读取 \fInchars\fP 字符后返回，而不是等待完整的输入行，除非遇到 EOF 或 \fBread\fP 超时。
输入中遇到的分隔符不会被特殊处理，并且不会导致 \fBread\fP 返回，直到读取 \fInchars\fP 字符。 结果不在 \fBIFS\fP 中的字符上拆分;
其目的是为变量分配完全读取的字符 (反斜杠除外; 请参见下面的 \fB\-r\fP 选项)。
.TP 
\fB\-p \fP\fIprompt\fP
在尝试读取任何输入之前，在出现标准错误时显示 \fIprompt\fP，不带尾随换行符。 仅当输入来自最终端时才会显示提示。
.TP 
\fB\-r\fP
反斜杠不充当转义字符。 反斜杠被认为是该行的一部分。 特别是，反斜杠 \- 换行符对不能用作续行符。
.TP 
\fB\-s\fP
静音模式。 如果输入来自最终端，则不会回显字符。
.TP 
\fB\-t \fP\fItimeout\fP
如果在 \fItimeout\fP 秒内未读取完整的一行输入 (或指定数量的字符)，则导致 \fBread\fP 超时并返回失败。 \fItimeout\fP
可以是小数点后有小数部分的十进制数。 此选项仅在 \fBread\fP 正在从终端、管道或其他特殊文件读取输入时有效; 从常规文件读取时它没有效果。 如果
\fBread\fP 超时，\fBread\fP 将读取的任何部分输入保存到指定的变量 \fIname\fP 中。 如果 \fItimeout\fP 为 0，则 \fBread\fP
立即返回，而不尝试读取任何数据。 如果输入在指定的文件描述符上可用，则退出状态为 0，否则为非零。 如果超过超时，退出状态大于 128。
.TP 
\fB\-u \fP\fIfd\fP
从文件描述符 \fIfd\fP 读取输入。
.PD
.PP
如果没有提供 \fInames\fP，读取的行 (没有结束定界符但未修改) 将分配给变量
.SM
\fBREPLY\fP。
退出状态为零，除非遇到文件结束，\fBread\fP 超时 (此时状态大于 128)，发生变量赋值错误 (如赋值给一个只读变量)，或者无效的文件描述符作为
\fB\-u\fP 的参数提供。
.RE
.TP 
\fBreadonly\fP [\fB\-aAf\fP] [\fB\-p\fP] [\fIname\fP[=\fIword\fP] ...]
.PD
给定的 \fInames\fP 被标记为只读; 这些 \fInames\fP 的值可能不会被后续分配更改。 如果提供了 \fB\-f\fP 选项，则对应于 \fInames\fP
的函数被如此标记。 \fB\-a\fP 选项将变量限制为索引数组; \fB\-A\fP 选项将变量限制为关联数组。 如果提供了两个选项，则 \fB\-A\fP 优先。
如果没有给出 \fIname\fP 参数，或者提供了 \fB\-p\fP 选项，则打印所有只读名称的列表。 其他选项可用于将输出限制为只读名称集的一个子集。
\fB\-p\fP 选项使输出以一种可重复用作输入的格式显示。 如果变量名称后跟 =\fIword\fP，则变量的值设置为 \fIword\fP。
除非遇到无效选项，否则返回状态为 0，其中一个 \fInames\fP 不是有效的 shell 变量名，或者 \fB\-f\fP 提供了一个不是函数的
\fIname\fP。
.TP 
\fBreturn\fP [\fIn\fP]
导致一个函数停止执行并将 \fIn\fP 指定的值返回给它的调用者。 如果省略 \fIn\fP，则返回状态为在函数体中执行的最后一个命令的状态。 如果
\fBreturn\fP 由陷阱处理程序执行，则用于确定状态的最后一条命令是在陷阱处理程序之前执行的最后一条命令。 如果在 \fBDEBUG\fP 陷阱期间执行
\fBreturn\fP，则用于确定状态的最后一条命令是调用 \fBreturn\fP 之前陷阱处理程序执行的最后一条命令。 如果 \fBreturn\fP
在一个函数外使用，但在 \fB.\fP (\fBsource\fP) 命令执行脚本期间，它会导致 shell 停止执行该脚本并返回 \fIn\fP
或脚本中执行的最后一个命令的退出状态作为退出状态剧本。 如果提供 \fIn\fP，则返回值是其最低有效 8 位。 如果 \fBreturn\fP
提供了一个非数字参数，或者在一个函数之外使用，而不是在 \fB.\fP\^ 或 \fBsource\fP 执行脚本期间，则返回状态为非零。 与 \fBRETURN\fP
陷阱关联的任何命令都会在执行任数或脚本之后恢复之前执行。
.TP 
\fBset\fP [\fB\-\-abefhkmnptuvxBCEHPT\fP] [\fB\-o\fP \fIoption\-name\fP] [\fIarg\fP ...]
.PD 0
.TP 
\fBset\fP [\fB+abefhkmnptuvxBCEHPT\fP] [\fB+o\fP \fIoption\-name\fP] [\fIarg\fP ...]
.PD
在没有选项的情况下，每个 shell 变量的名称和值都以一种格式显示，该格式可以重复用作设置或重置当前设置变量的输入。 只读变量不能重置。 在
\fIposix mode\fP 中，只列出了 shell 变量。 输出根据当前语言环境排序。 指定选项时，它们会设置或取消设置 shell 属性。
选项处理后剩余的任何参数都被视为位置参数的值，并按顺序分配给 \fB$1\fP、\fB$2\fP、\fB...\fP \fB$\fP\fIn\fP。 选项，如果指定，具有以下含义:
.RS
.PD 0
.TP  8
\fB\-a\fP
创建或修改的每个变量或函数都被赋予导出属性并标记为导出到后续命令的环境。
.TP  8
\fB\-b\fP
立即报告终止的后台作业的状态，而不是在下一个主要提示之前。 这仅在启用作业控制时有效。
.TP  8
\fB\-e\fP
如果 \fIpipeline\fP (可能由单个 \fIsimple command\fP)、\fIlist\fP 或 \fIcompound command\fP
(参见上面的
.SM
\fBSHELL GRAMMAR\fP) 组成) 以非零状态退出，则立即退出。 如果失败的命令是紧跟 \fBwhile\fP 或
\fBuntil\fP 关键字的命令列表的一部分，\fBif\fP 或 \fBelif\fP 保留字后面的测试部分，\fB&&\fP 或 \fB||\fP
列表中除命令之外执行的任何命令的一部分，则 shell 不会退出在最后的 \fB&&\fP 或 \fB||\fP
之后，管道中除最后一个命令之外的任何命令，或者如果命令的返回值被 \fB!\fP 反转。 如果子 shell 以外的复合命令返回非零状态，因为在忽略
\fB\-e\fP 时命令失败，则 shell 不会退出。 如果设置了 \fBERR\fP 上的陷阱，则会在 shell 退出之前执行。 此选项分别适用于 shell
环境和每个子 shell 环境 (参见上面的
.SM
\fBCOMMAND EXECUTION ENVIRONMENT\fP)，并可能导致子 shell
在执行子 shell 中的所有命令之前退出。
.if  t .sp 0.5
.if  n .sp 1
如果复合命令或 shell 函数在忽略 \fB\-e\fP 的上下文中执行，则在复合命令或函数体中执行的任何命令都不会受到 \fB\-e\fP 设置的影响，即使设置了
\fB\-e\fP 并且命令返回失败状态也是如此。 如果复合命令或 shell 函数在忽略 \fB\-e\fP 的上下文中执行时设置
\fB\-e\fP，则该设置在复合命令或包含函数调用的命令完成之前不会有任何效果。
.TP  8
\fB\-f\fP
禁用路径名扩展。
.TP  8
\fB\-h\fP
记住查找执行命令时的命令位置。 这是默认启用的。
.TP  8
\fB\-k\fP
赋值语句形式的所有参数都放在命令的环境中，而不仅仅是命令名前面的那些。
.TP  8
\fB\-m\fP
监控模式。 作业控制已启用。 对于支持它的系统上的交互式 shells，此选项在默认情况下处于启用状态 (请参见上面的
.SM
\fBJOB CONTROL\fP)。 所有进程都在单独的进程组中运行。 当后台作业完成时，shell 打印包含其退出状态的一行。
.TP  8
\fB\-n\fP
读取命令但不执行它们。 这可用于检查 shell 脚本的语法错误。 这会被交互式 shells 忽略。
.TP  8
\fB\-o \fP\fIoption\-name\fP
\fIoption\-name\fP 可以是以下之一:
.RS
.TP  8
\fBallexport\fP
与 \fB\-a\fP 相同。
.TP  8
\fBbraceexpand\fP
与 \fB\-B\fP 相同。
.TP  8
\fBemacs\fP
使用 emacs 风格的命令行编辑界面。 当 shell 处于交互状态时默认启用，除非 shell 使用 \fB\-\-noediting\fP 选项启动。
这也会影响用于 \fBread \-e\fP 的编辑界面。
.TP  8
\fBerrexit\fP
与 \fB\-e\fP 相同。
.TP  8
\fBerrtrace\fP
与 \fB\-E\fP 相同。
.TP  8
\fBfunctrace\fP
与 \fB\-T\fP 相同。
.TP  8
\fBhashall\fP
与 \fB\-h\fP 相同。
.TP  8
\fBhistexpand\fP
与 \fB\-H\fP 相同。
.TP  8
\fBhistory\fP
启用命令历史记录，如上文
.SM
\fBHISTORY\fP 中所述。 此选项在交互式 shells 中默认打开。
.TP  8
\fBignoreeof\fP
效果就好像 shell 命令一样
.if  t \f(CWIGNOREEOF=10\fP
.if  n ``IGNOREEOF=10''
已被执行 (见上面的 \fBShell Variables\fP)。
.TP  8
\fBkeyword\fP
与 \fB\-k\fP 相同。
.TP  8
\fBmonitor\fP
与 \fB\-m\fP 相同。
.TP  8
\fBnoclobber\fP
与 \fB\-C\fP 相同。
.TP  8
\fBnoexec\fP
与 \fB\-n\fP 相同。
.TP  8
\fBnoglob\fP
与 \fB\-f\fP 相同。
.TP  8
\fBnolog\fP
目前忽略。
.TP  8
\fBnotify\fP
与 \fB\-b\fP 相同。
.TP  8
\fBnounset\fP
与 \fB\-u\fP 相同。
.TP  8
\fBonecmd\fP
与 \fB\-t\fP 相同。
.TP  8
\fBphysical\fP
与 \fB\-P\fP 相同。
.TP  8
\fBpipefail\fP
如果设置，则管道的返回值是最后一个以非零状态退出的 (rightmost) 命令的值，如果管道中的所有命令都成功退出则为零。 默认情况下禁用此选项。
.TP  8
\fBposix\fP
更改默认操作不同于 POSIX 标准的 \fBbash\fP 的行为以匹配标准 (\fIposix mode\fP)。 请参见下面的
.SM
\fBSEE ALSO\fP 以获取详细说明 posix 模式如何影响 bash 行为的文档的引用。
.TP  8
\fBprivileged\fP
与 \fB\-p\fP 相同。
.TP  8
\fBverbose\fP
与 \fB\-v\fP 相同。
.TP  8
\fBvi\fP
使用 vi 风格的命令行编辑界面。 这也会影响用于 \fBread \-e\fP 的编辑界面。
.TP  8
\fBxtrace\fP
与 \fB\-x\fP 相同。
.sp .5
.PP
如果 \fB\-o\fP 没有提供 \fIoption\-name\fP，则打印当前选项的值。 如果 \fB+o\fP 没有提供
\fIoption\-name\fP，则标准输出上会显示一系列用于重新创建当前选项设置的 \fBset\fP 命令。
.RE
.TP  8
\fB\-p\fP
打开 \fIprivileged\fP 模式。 在此模式下，不处理
.SM
\fB$ENV\fP 和
.SM
\fB$BASH_ENV\fP
文件，不从环境继承 shell 函数，并且忽略
.SM
\fBSHELLOPTS\fP、
.SM
\fBBASHOPTS\fP、
.SM
\fBCDPATH\fP 和
.SM
\fBGLOBIGNORE\fP 变量，如果它们出现在环境中。 如果 shell 使用不等于真实用户 (group)
id 的有效用户 (group) id 启动，并且未提供 \fB\-p\fP 选项，则会执行这些操作并将有效用户 id 设置为真实用户 id。如果在启动时提供
\fB\-p\fP 选项，则不会重置有效用户 ID。 关闭此选项会导致将有效用户和组 ID 设置为真实用户和组 ID。
.TP  8
\fB\-t\fP
读取并执行一条命令后退出。
.TP  8
\fB\-u\fP
进行参数扩展时，将未设置变量和除特殊参数 "@" 和 "*" 以外的参数视为错误。 如果尝试对未设置的变量或参数进行扩展，则 shell
会打印一条错误消息，如果不是交互式的，则以非零状态退出。
.TP  8
\fB\-v\fP
在读取时打印 shell 输入行。
.TP  8
\fB\-x\fP
\fIsimple command\fP、\fBfor\fP 命令、\fBcase\fP 命令、\fBselect\fP 命令或算术 \fBfor\fP 命令展开后，显示
.SM
\fBPS4\fP 的展开值，后面是命令及其展开的参数或关联词列表。
.TP  8
\fB\-B\fP
shell 执行大括号扩展 (参见上面的 \fBBrace Expansion\fP)。 这是默认打开的。
.TP  8
\fB\-C\fP
如果设置，\fBbash\fP 不会用 \fB>\fP、\fB>&\fP 和 \fB<>\fP 重定向运算符覆盖现有文件。 当使用重定向运算符
\fB>|\fP 而不是 \fB>\fP 创建输出文件时，这可能会被覆盖。
.TP  8
\fB\-E\fP
如果设置，则 \fBERR\fP 上的任何陷阱都由 shell 函数、命令替换和在子 shell 环境中执行的命令继承。 在这种情况下，\fBERR\fP
陷阱通常不会被继承。
.TP  8
\fB\-H\fP
启用 \fB!\fP 样式历史替换。 当 shell 处于交互状态时，此选项默认打开。
.TP  8
\fB\-P\fP
如果设置，则 shell 在执行更改当前工作目录的命令 (例如 \fBcd\fP) 时不会解析符号链接。 它使用物理目录结构体代替。
默认情况下，\fBbash\fP 在执行更改当前目录的命令时遵循目录的逻辑链。
.TP  8
\fB\-T\fP
如果设置，则 \fBDEBUG\fP 和 \fBRETURN\fP 上的任何陷阱都由 shell 函数、命令替换和在子 shell 环境中执行的命令继承。
在这种情况下，\fBDEBUG\fP 和 \fBRETURN\fP 陷阱通常不会被继承。
.TP  8
\fB\-\-\fP
如果此选项后面没有参数，则位置参数未设置。 否则，位置参数将设置为 \fIarg\fPs，即使其中一些参数以 \fB\-\fP 开头。
.TP  8
\fB\-\fP
发出选项结束信号，将所有剩余的 \fIarg\fPs 分配给位置参数。 \fB\-x\fP 和 \fB\-v\fP 选项被关闭。 如果没有 \fIarg\fPs，位置参数不变。
.PD
.PP
除非另有说明，否则这些选项默认情况下处于关闭状态。 使用 + 而不是 \- 会导致这些选项被关闭。 这些选项也可以指定为调用 shell 的参数。
当前的选项集可以在 \fB$\-\fP 中找到。 除非遇到无效选项，否则返回状态始终为真。
.RE
.TP 
\fBshift\fP [\fIn\fP]
来自 \fIn\fP+1 的位置参数... 重命名为 \fB$1\fP \fB....\fP 由数字 \fB$#\fP 到 \fB$#\fP\-\fIn\fP+1 表示的参数未设置。
\fIn\fP 必须是小于或等于 \fB$#\fP 的非 negative 数。 如果 \fIn\fP 为 0，则不更改任何参数。 如果未给出 \fIn\fP，则假定为 1。
如果 \fIn\fP 大于 \fB$#\fP，则位置参数不变。 如果 \fIn\fP 大于 \fB$#\fP 或小于零，则返回状态大于零; otherwise  0.
.TP 
\fBshopt\fP [\fB\-pqsu\fP] [\fB\-o\fP] [\fIoptname\fP ...]
切换控制可选 shell 行为的设置值。 这些设置可以是下面列出的设置，或者，如果使用 \fB\-o\fP 选项，则可以是 \fBset\fP 内置命令的 \fB\-o\fP
选项可用的设置。 如果没有选项，或有 \fB\-p\fP 选项，将显示所有可设置选项的列表，并指示每个选项是否已设置; 如果提供
\fIoptnames\fP，则输出仅限于这些选项。 \fB\-p\fP 选项使输出以一种可以作为输入重复使用的形式显示。 其他选项含义如下:
.RS
.PD 0
.TP 
\fB\-s\fP
每个 \fIoptname\fP 启用 (set)。
.TP 
\fB\-u\fP
每个 \fIoptname\fP 禁用 (unset)。
.TP 
\fB\-q\fP
抑制正常输出 (安静模式) ; 返回状态指示 \fIoptname\fP 是已设置还是未设置。 如果 \fB\-q\fP 给定多个 \fIoptname\fP 参数，如果
\fIoptnames\fP 全部使能则返回状态为 0; 否则非零。
.TP 
\fB\-o\fP
将 \fIoptname\fP 的值限制为为 \fBset\fP 内置的 \fB\-o\fP 选项定义的值。
.PD
.PP
如果 \fB\-s\fP 或 \fB\-u\fP 与没有 \fIoptname\fP 参数一起使用，则 \fBshopt\fP 仅分别显示已设置或未设置的那些选项。
除非另有说明，\fBshopt\fP 选项默认禁用 (unset)。
.PP
如果启用所有 \fIoptnames\fP，则列出选项时的返回状态为零，否则为非零。 设置或取消设置选项时，返回状态为零，除非 \fIoptname\fP
不是有效的 shell 选项。
.PP
\fBshopt\fP 选项列表是:
.if  t .sp .5v
.if  n .sp 1v
.PD 0
.TP  8
\fBassoc_expand_once\fP
如果设置，则 shell 会在算术表达式求值期间抑制关联数组下标的多重求值，同时执行可以执行变量赋值的内置函数，以及执行执行数组解引用的内置函数。
.TP  8
\fBautocd\fP
如果设置，则执行作为目录名称的命令名称，就好像它是 \fBcd\fP 命令的参数一样。 此选项仅供交互式 shells 使用。
.TP  8
\fBcdable_vars\fP
如果设置，则假定不是目录的 \fBcd\fP 内置命令的参数是变量的名称，其值是要更改到的目录。
.TP  8
\fBcdspell\fP
如果设置，将更正 \fBcd\fP 命令中目录组件拼写中的小错误。 检查的错误是转置字符、缺少字符和一个字符过多。
如果找到更正，则打印更正后的文件名，然后命令继续执行。 此选项仅供交互式 shells 使用。
.TP  8
\fBcheckhash\fP
如果设置，\fBbash\fP 会在尝试执行之前检查哈希表中找到的命令是否存在。 如果散列命令不再存在，则执行正常路径搜索。
.TP  8
\fBcheckjobs\fP
如果设置，\fBbash\fP 会在退出交互式 shell 之前列出任何已停止和正在运行的作业的状态。
如果有任何作业正在运行，这会导致退出被推迟，直到在没有干预命令的情况下尝试第二次退出 (参见上面的
.SM
\fBJOB CONTROL\fP)。
如果任何作业停止，shell 总是推迟退出。
.TP  8
\fBcheckwinsize\fP
如果设置，\fBbash\fP 在每个外部 (non\-builtin) 命令后检查窗口大小，并在必要时更新
.SM
\fBLINES\fP 和
.SM
\fBCOLUMNS\fP 的值。 默认情况下启用此选项。
.TP  8
\fBcmdhist\fP
如果设置，\fBbash\fP 会尝试将多行命令的所有行保存在同一个历史记录条目中。 这允许轻松地重新编辑多行命令。
默认情况下启用此选项，但只有在启用命令历史记录时才有效，如上文
.SM
\fBHISTORY\fP 所述。
.PD 0
.TP  8
\fBcompat31\fP
.TP  8
\fBcompat32\fP
.TP  8
\fBcompat40\fP
.TP  8
\fBcompat41\fP
.TP  8
\fBcompat42\fP
.TP  8
\fBcompat43\fP
.TP  8
\fBcompat44\fP
.PD
这些控制 shell 兼容模式的方面 (参见下面的
.SM
\fBSHELL COMPATIBILITY MODE\fP)。
.TP  8
\fBcomplete_fullquote\fP
如果设置，\fBbash\fP 在执行完成时引用文件名和目录名中的所有 shell 元字符。 如果未设置，当这些元字符出现在要完成的单词中的 shell
变量引用中时，\fBbash\fP 会从将在完整文件名中引用的字符集中删除美元符号等元字符。 这意味着扩展到目录的变量名中的美元符号将不会被引用;
但是，文件名中出现的任何美元符号也不会被引用。 这仅在 bash 使用反斜杠引用完整的文件名时才有效。 默认情况下设置此变量，这是通过 4.2
的版本中的默认 bash 行为。
.TP  8
\fBdirexpand\fP
如果设置，\fBbash\fP 在执行文件名完成时用单词扩展的结果替换目录名。 这会更改 readline 编辑缓冲区的内容。 如果未设置，\fBbash\fP
会尝试保留用户键入的内容。
.TP  8
\fBdirspell\fP
如果设置，如果最初提供的目录名称不存在，则 \fBbash\fP 会在单词完成期间尝试对目录名称进行拼写更正。
.TP  8
\fBdotglob\fP
如果设置，\fBbash\fP 包括以 `.` 开头的文件名在路径名扩展的结果中。文件名 \fB\*(lq.\*(rq\fP 和 \fB\*(lq..\*(rq\fP
必须始终显式匹配，即使设置了 \fBdotglob\fP。
.TP  8
\fBexecfail\fP
如果设置，如果非交互式 shell 无法执行指定为 \fBexec\fP 内置命令的参数的文件，则它不会退出。 如果 \fBexec\fP 失败，则交互式
shell 不会退出。
.TP  8
\fBexpand_aliases\fP
如果设置，别名将按照上面
.SM
\fBALIASES\fP 下的描述进行扩展。 对于交互式 shells，此选项默认启用。
.TP  8
\fBextdebug\fP
如果在 shell 调用或 shell 启动文件中设置，安排在 shell 启动之前执行调试器配置文件，与 \fB\-\-debugger\fP 选项相同。
如果在调用后设置，则启用旨在供调试器使用的行为:
.RS
.TP 
\fB1.\fP
\fBdeclare\fP 内置的 \fB\-F\fP 选项显示源文件名和行号对应于作为参数提供的每个函数名称。
.TP 
\fB2.\fP
如果 \fBDEBUG\fP 陷阱运行的命令返回非零值，则将跳过且不执行下一条命令。
.TP 
\fB3.\fP
如果 \fBDEBUG\fP 陷阱运行的命令返回值 2，并且 shell 正在子例程中执行 (由 \fB.\fP 或 \fBsource\fP 内置函数执行的 shell
函数或 shell 脚本)，则 shell 模拟调用 \fBreturn\fP。
.TP 
\fB4.\fP
.SM
\fBBASH_ARGC\fP 和
.SM
\fBBASH_ARGV\fP 的更新如上文所述。
.TP 
\fB5.\fP
函数跟踪已启用: 命令替换、shell 函数和使用 \fB(\fP \fIcommand\fP \fB)\fP 调用的子 shell 继承 \fBDEBUG\fP 和
\fBRETURN\fP 陷阱。
.TP 
\fB6.\fP
启用错误跟踪: 命令替换、shell 函数和使用 \fB(\fP \fIcommand\fP \fB)\fP 调用的子 shell 继承 \fBERR\fP 陷阱。
.RE
.TP  8
\fBextglob\fP
如果设置，则启用上述 \fBPathname Expansion\fP 下的扩展模式匹配，特性。
.TP  8
\fBextquote\fP
如果设置，则 \fB$\fP\(aq\fIstring\fP\(aq 和 \fB$\fP"\fIstring\fP" 引用在用双引号引起来的
\fB${\fP\fIparameter\fP\fB}\fP 扩展中执行。 默认情况下启用此选项。
.TP  8
\fBfailglob\fP
如果设置，则在路径名扩展期间无法匹配文件名的模式会导致扩展错误。
.TP  8
\fBforce_fignore\fP
如果设置，由
.SM
\fBFIGNORE\fP shell 变量指定的后缀会导致在执行单词完成时忽略单词，即使被忽略的单词是唯一可能的完成。 关于
.SM
\fBFIGNORE\fP 的说明见上面的
.SM
\fBSHELL VARIABLES\fP。 默认情况下启用此选项。
.TP  8
\fBglobasciiranges\fP
如果设置，则在模式匹配括号表达式中使用的范围表达式 (请参见上面的
.SM
\fBPattern Matching\fP) 在执行比较时就像在传统 C
语言环境中一样。 也就是说，不考虑当前语言环境的整理顺序，因此 \fBb\fP 不会在 \fBA\fP 和 \fBB\fP 之间进行整理，大写和小写 ASCII
字符将一起整理。
.TP  8
\fBglobstar\fP
如果设置，路径名扩展上下文中使用的模式 \fB**\fP 将匹配所有文件和零个或多个目录和子目录。 如果模式后跟 \fB/\fP，则只有目录和子目录匹配。
.TP  8
\fBgnu_errfmt\fP
如果设置，shell 错误消息将以标准 GNU 错误消息格式写入。
.TP  8
\fBhistappend\fP
如果设置，当 shell 退出时，历史列表将追加到由
.SM
\fBHISTFILE\fP 变量的值命名的文件，而不是覆盖该文件。
.TP  8
\fBhistreedit\fP
如果设置，并且正在使用 \fBreadline\fP，用户将有机会重新编辑失败的历史替换。
.TP  8
\fBhistverify\fP
如果设置，并且正在使用 \fBreadline\fP，则历史替换的结果不会立即传递给 shell 解析器。 相反，生成的行被加载到 \fBreadline\fP
编辑缓冲区中，允许进一步修改。
.TP  8
\fBhostcomplete\fP
如果已设置，并且正在使用 \fBreadline\fP，则在完成包含 \fB@\fP 的单词时，\fBbash\fP 将尝试执行主机名完成 (请参见上面
.SM
\fBREADLINE\fP 下的 \fBCompleting\fP)。 这是默认启用的。
.TP  8
\fBhuponexit\fP
如果设置，当交互式登录 shell 退出时，\fBbash\fP 将向所有作业发送
.SM
\fBSIGHUP\fP。
.TP  8
\fBinherit_errexit\fP
如果设置，命令替换将继承 \fBerrexit\fP 选项的值，而不是在子 shell 环境中取消设置。 启用 \fIposix mode\fP 时启用此选项。
.TP  8
\fBinteractive_comments\fP
如果设置，则允许以 \fB#\fP 开头的单词导致该单词和该行上的所有剩余字符在交互式 shell 中被忽略 (参见上面的
.SM
\fBCOMMENTS\fP)。 默认情况下启用此选项。
.TP  8
\fBlastpipe\fP
如果已设置，并且作业控制未激活，则 shell 会在当前 shell 环境中运行未在后台执行的管道的最后一条命令。
.TP  8
\fBlithist\fP
如果设置并启用了 \fBcmdhist\fP 选项，则多行命令将使用嵌入的换行符保存到历史记录中，而不是尽可能使用分号分隔符。
.TP  8
\fBlocalvar_inherit\fP
如果设置，本地变量在分配任何新值之前继承前一个作用域中存在的同名变量的值和属性。 nameref 属性不是继承的。
.TP  8
\fBlocalvar_unset\fP
如果设置，调用 \fBunset\fP
在本地变量上之前的函数作用域标记它们，以便后续查找发现它们未设置，直到函数返回。这与在当前函数范围内取消设置本地变量的行为相同。
.TP  8
\fBlogin_shell\fP
如果 shell 作为登录 shell 启动 (请参见上面的
.SM
\fBINVOCATION\fP)，则设置此选项。 该值可能不会更改。
.TP  8
\fBmailwarn\fP
如果已设置，并且 \fBbash\fP 正在检查邮件的文件自上次检查后已被访问，则会显示消息 \fImailfile\fP 中的邮件已被读取`。
.TP  8
\fBno_empty_cmd_completion\fP
如果设置，并且正在使用 \fBreadline\fP，则当尝试在空行上完成时，\fBbash\fP 将不会尝试搜索
.SM
\fBPATH\fP 以寻找可能的完成。
.TP  8
\fBnocaseglob\fP
如果设置，则 \fBbash\fP 在执行路径名扩展时以不区分大小写的方式匹配文件名 (请参见上面的 \fBPathname Expansion\fP)。
.TP  8
\fBnocasematch\fP
如果设置，\fBbash\fP 在执行 \fBcase\fP 或 \fB[[\fP
条件命令时执行匹配时，在执行模式替换字扩展时，或在过滤可能的完成作为可编程完成的一部分时，以不区分大小写的方式匹配模式。
.TP  8
\fBnullglob\fP
如果设置，\fBbash\fP 允许不匹配任何文件的模式 (参见上面的 \fBPathname Expansion\fP) 扩展为空字符串，而不是它们自己。
.TP  8
\fBprogcomp\fP
如果设置，则启用可编程完成工具 (参见上面的 \fBProgrammable Completion\fP)。 默认情况下启用此选项。
.TP  8
\fBprogcomp_alias\fP
如果设置，并且启用可编程完成，\fBbash\fP 将没有任何完成的命令名称视为可能的别名并尝试别名扩展。如果它有别名，\fBbash\fP
会尝试使用扩展别名产生的命令字进行可编程完成。
.TP  8
\fBpromptvars\fP
如果设置，提示字符串将在扩展后进行参数扩展、命令替换、算术扩展和引号删除，如上文
.SM
\fBPROMPTING\fP 所述。 默认情况下启用此选项。
.TP  8
\fBrestricted_shell\fP
如果 shell 在受限模式下启动 (请参见下面的
.SM
\fBRESTRICTED SHELL\fP)，则会设置此选项。 该值可能不会更改。
这在执行启动文件时不会重置，从而允许启动文件发现 shell 是否受到限制。
.TP  8
\fBshift_verbose\fP
如果设置，当移位计数超过位置参数的数量时，\fBshift\fP 内置函数会打印一条错误消息。
.TP  8
\fBsourcepath\fP
如果设置，则 \fBsource\fP (\fB.\fP) 内置函数使用
.SM
\fBPATH\fP 的值来查找包含作为参数提供的文件的目录。
默认情况下启用此选项。
.TP  8
\fBxpg_echo\fP
如果设置，\fBecho\fP 内置函数默认扩展反斜杠转义序列。
.RE
.PD
.TP 
\fBsuspend\fP [\fB\-f\fP]
暂停执行此 shell，直到它收到
.SM
\fBSIGCONT\fP 信号。 登录 shell 不能挂起; \fB\-f\fP 选项可用于覆盖它并强制暂停。
除非 shell 是登录 shell 且未提供 \fB\-f\fP，或者未启用作业控制，否则返回状态为 0。
.TP 
\fBtest\fP \fIexpr\fP
.PD 0
.TP 
\fB[\fP \fIexpr\fP \fB]\fP
根据条件表达式 \fIexpr\fP 的评估返回状态 0 (true) 或 1 (false)。 每个运算符和操作数必须是一个单独的参数。
.if  \n(zZ=0 Expressions are composed of the primaries described above under
.if  \n(zZ=1 Expressions are composed of the primaries described in the \fBbash\fP manual page under
.SM
\fBCONDITIONAL EXPRESSIONS\fP.  \fBtest\fP 不接受任何选项，也不接受和忽略 \fB\-\-\fP
的参数作为选项结束的标志。
.if  t .sp 0.5
.if  n .sp 1
可以使用以下运算符组合表达式，按优先级降序排列。 评价取决于参数; 见下文。 当有五个或更多参数时使用运算符优先级。
.RS
.PD 0
.TP 
\fB! \fP\fIexpr\fP
如果 \fIexpr\fP 为假，则为真。
.TP 
\fB( \fP\fIexpr\fP\fB )\fP
返回 \fIexpr\fP 的值。 这可用于覆盖运算符的正常优先级。
.TP 
\fIexpr1\fP \-\fBa\fP \fIexpr2\fP
如果 \fIexpr1\fP 和 \fIexpr2\fP 都为真，则为真。
.TP 
\fIexpr1\fP \-\fBo\fP \fIexpr2\fP
如果 \fIexpr1\fP 或 \fIexpr2\fP 为真，则为真。
.PD
.PP
\fBtest\fP 和 \fB[\fP 使用一组基于参数数量的规则来评估条件表达式。
.if  t .sp 0.5
.if  n .sp 1
.PD 0
.TP 
0 arguments
表达式是错误的。
.TP 
1 argument
当且仅当参数不为空时，表达式才为真。
.TP 
2 arguments
如果第一个参数是 \fB!\fP，当且仅当第二个参数为 null 时表达式为真。 如果第一个参数是上面列出的
.SM
\fBCONDITIONAL EXPRESSIONS\fP 下的一元条件运算符之一，则如果一元测试为真，则表达式为真。 如果第一个参数不是有效的一元条件运算符，则表达式为假。
.TP 
3 arguments
以下条件按列出的顺序应用。 如果第二个参数是上面列出的
.SM
\fBCONDITIONAL EXPRESSIONS\fP
下的二进制条件运算符之一，则表达式的结果是使用第一个和第三个参数作为操作数的二进制测试的结果。 当有三个参数时，\fB\-a\fP 和 \fB\-o\fP
运算符被认为是二元运算符。 如果第一个参数是 \fB!\fP，则该值是使用第二个和第三个参数的双参数测试的否定。 如果第一个参数正好是
\fB(\fP，第三个参数正好是 \fB)\fP，结果就是第二个参数的一次参数测试。 否则，表达式为假。
.TP 
4 arguments
如果第一个参数为 \fB!\fP，则结果为剩余参数组成的三参数表达式的否定。 否则，将使用上面列出的规则根据优先级解析和评估表达式。
.TP 
5 or more arguments
使用上面列出的规则根据优先级解析和评估表达式。
.if  t .sp 0.5
.if  n .sp 1
.LP
当与 \fBtest\fP 或 \fB[\fP 一起使用时，\fB<\fP 和 \fB>\fP 运算符使用 ASCII 排序按字典顺序排序。
.RE
.PD
.TP 
\fBtimes\fP
打印 shell 和从 shell 运行的进程的累积用户和系统时间。 返回状态是 0.
.TP 
\fBtrap\fP [\fB\-lp\fP] [[\fIarg\fP] \fIsigspec\fP ...]
当 shell 收到 signal(s) \fIsigspec\fP 时，要读取并执行命令 \fIarg\fP。 如果 \fIarg\fP 不存在 (并且只有一个
\fIsigspec\fP) 或 \fB\-\fP，每个指定的信号将重置为其原始配置 (它在进入 shell 时的值)。 如果 \fIarg\fP 是空字符串，则每个
\fIsigspec\fP 指定的信号将被 shell 及其调用的命令忽略。 如果 \fIarg\fP 不存在但提供了 \fB\-p\fP，则显示与每个
\fIsigspec\fP 关联的陷阱命令。 如果未提供参数或仅提供 \fB\-p\fP，则 \fBtrap\fP 打印与每个信号关联的命令列表。 \fB\-l\fP 选项导致
shell 打印信号名称及其对应编号的列表。 每个 \fIsigspec\fP 要么是 <\fIsignal.h\fP>
中定义的信号名称，要么是信号编号。 信号名称不区分大小写，
.SM
\fBSIG\fP 前缀是可选的。
.if  t .sp 0.5
.if  n .sp 1
如果 \fIsigspec\fP 是
.SM
\fBEXIT\fP (0)，则在从 shell 退出时执行命令 \fIarg\fP。 如果 \fIsigspec\fP 是
.SM
\fBDEBUG\fP，则在每个 \fIsimple command\fP、\fIfor\fP 命令、\fIcase\fP 命令、\fIselect\fP
命令、每个算术 \fIfor\fP 命令之前执行命令 \fIarg\fP，并且在 shell 函数中执行第一个命令之前 (参见上面的
.SM
\fBSHELL GRAMMAR\fP)。 有关其对 \fBDEBUG\fP 陷阱的影响的详细信息，请参见 \fBextdebug\fP 选项对 \fBshopt\fP 内置的描述。 如果
\fIsigspec\fP 是
.SM
\fBRETURN\fP，则每次 shell 函数或使用 \fB.\fP 或 \fBsource\fP
内置函数执行的脚本完成执行时，都会执行命令 \fIarg\fP。
.if  t .sp 0.5
.if  n .sp 1
如果 \fIsigspec\fP 是
.SM
\fBERR\fP，只要管道 (可能由单个简单命令组成)、列表或复合命令返回非零退出状态，就会执行命令
\fIarg\fP，但要满足以下条件。 如果失败的命令是紧跟在 \fBwhile\fP 或 \fBuntil\fP 关键字之后的命令列表的一部分，\fIif\fP
语句中测试的一部分，\fB&&\fP 或 \fB||\fP 列表中执行的命令的一部分，但不执行
.SM
\fBERR\fP 陷阱 final \fB&&\fP 或
\fB||\fP，管道中除最后一个命令之外的任何命令，或者如果命令的返回值正在使用 \fB!\fP 反转。 \fBerrexit\fP (\fB\-e\fP)
选项遵循相同的条件。
.if  t .sp 0.5
.if  n .sp 1
进入 shell 时忽略的信号不能被捕获或重置。 未被忽略的捕获信号在创建时在子 shell 或子 shell 环境中重置为其原始值。 如果任何
\fIsigspec\fP 无效，则返回状态为 false; 否则 \fBtrap\fP 返回真。
.TP 
\fBtype\fP [\fB\-aftpP\fP] \fIname\fP [\fIname\fP ...]
如果没有选项，请指示每个 \fIname\fP 用作命令名称时将如何解释。 如果使用 \fB\-t\fP 选项，则 \fBtype\fP 打印一个字符串，它是
\fIalias\fP、\fIkeyword\fP、\fIfunction\fP、\fIbuiltin\fP 或 \fIfile\fP 之一 (如果 \fIname\fP
分别是别名、shell 保留字、函数、内置函数或磁盘文件)。 如果未找到 \fIname\fP，则不打印任何内容，并返回 false 退出状态。 如果使用
\fB\-p\fP 选项，\fBtype\fP 要么返回磁盘文件的名称，如果 \fIname\fP 被指定为命令名，则返回将被执行的磁盘文件的名称，或者如果
.if  t \f(CWtype -t name\fP
.if  n ``type -t name''
不会返回 \fIfile\fP。 \fB\-P\fP 选项强制对每个 \fIname\fP 进行
.SM
\fBPATH\fP 搜索，即使
.if  t \f(CWtype -t name\fP
.if  n ``type -t name''
不会返回 \fIfile\fP。 如果对命令进行哈希处理，则 \fB\-p\fP 和 \fB\-P\fP 打印哈希值，该值不一定是
.SM
\fBPATH\fP
中最先出现的文件。 如果使用 \fB\-a\fP 选项，则 \fBtype\fP 打印所有包含名为 \fIname\fP 的可执行文件的位置。 这包括别名和函数，当且仅当
\fB\-p\fP 选项未被使用时。 使用 \fB\-a\fP 时不参考散列命令表。 \fB\-f\fP 选项抑制 shell 函数查找，与 \fBcommand\fP 内置一样。
如果找到所有参数，则 \fBtype\fP 返回 true，如果没有找到，则返回 false。
.TP 
\fBulimit\fP [\fB\-HS\fP] \fB\-a\fP
.PD 0
.TP 
\fBulimit\fP [\fB\-HS\fP] [\fB\-bcdefiklmnpqrstuvxPRT\fP [\fIlimit\fP]]
.PD
在允许此类控制的系统上，提供对 shell 可用资源以及由它启动的进程的控制。 \fB\-H\fP 和 \fB\-S\fP 选项指定为给定资源设置硬限制或软限制。
一旦设置了硬限制，非 root 用户就不能增加它; 软限制可以增加到硬限制的值。 如果既未指定 \fB\-H\fP 也未指定
\fB\-S\fP，则会同时设置软限制和硬限制。 \fIlimit\fP 的值可以是为资源指定的元中的一个数字，也可以是特殊值 \fBhard\fP、\fBsoft\fP 或
\fBunlimited\fP 之一，分别代表当前硬限制、当前软限制和无限制。 如果省略 \fIlimit\fP，则打印资源软限制的当前值，除非给出 \fB\-H\fP
选项。 当指定了多个资源时，限制名称和元 (如果适用) 将打印在值之前。 其他选项解释如下:
.RS
.PD 0
.TP 
\fB\-a\fP
报告了所有电流限制; 没有限制
.TP 
\fB\-b\fP
最大套接字缓冲区大小
.TP 
\fB\-c\fP
创建的核心文件的最大大小
.TP 
\fB\-d\fP
进程字段的最大大小
.TP 
\fB\-e\fP
最大调度优先级 ("nice")
.TP 
\fB\-f\fP
shell 及其子进程写入的文件的最大大小
.TP 
\fB\-i\fP
挂起信号的最大数量
.TP 
\fB\-k\fP
可分配的最大 kqueue 数
.TP 
\fB\-l\fP
可以锁定到内存中的最大大小
.TP 
\fB\-m\fP
最大驻留集大小 (许多系统不遵守此限制)
.TP 
\fB\-n\fP
打开文件描述符的最大数量 (大多数系统不允许设置该值)
.TP 
\fB\-p\fP
512 字节块中的管道大小 (可能未设置)
.TP 
\fB\-q\fP
POSIX 消息队列中的最大字节数
.TP 
\fB\-r\fP
最大实时调度优先级
.TP 
\fB\-s\fP
最大栈大小
.TP 
\fB\-t\fP
以秒为单位的最大 cpu 时间
.TP 
\fB\-u\fP
单个用户可用的最大进程数
.TP 
\fB\-v\fP
shell 及其子系统可用的最大虚拟内存量
.TP 
\fB\-x\fP
最大文件锁数
.TP 
\fB\-P\fP
最大伪终端数
.TP 
\fB\-R\fP
实时进程在阻塞之前可以运行的最长时间，以微秒为单位
.TP 
\fB\-T\fP
最大线程数
.PD
.PP
如果给出 \fIlimit\fP，并且未使用 \fB\-a\fP 选项，则 \fIlimit\fP 是指定资源的新值。 如果未给出选项，则假定为 \fB\-f\fP。 值以
1024 字节为增量，\fB\-t\fP 除外，它以秒为单位; \fB\-R\fP，以微秒为单位; \fB\-p\fP，以 512 字节块为单位;
\fB\-P\fP、\fB\-T\fP、\fB\-b\fP、\fB\-k\fP、\fB\-n\fP、\fB\-u\fP，为非标定值; 并且，在 posix 模式下，\fB\-c\fP 和 \fB\-f\fP，它们以
512 字节为增量。 返回状态为 0，除非提供了无效选项或参数，或者在设置新限制时发生错误。
.RE
.TP 
\fBumask\fP [\fB\-p\fP] [\fB\-S\fP] [\fImode\fP]
用户文件创建掩码设置为 \fImode\fP。 如果 \fImode\fP 以数字开头，则解释为八进制数; 否则它被解释为类似于 \fIchmod\fP(1)
接受的符号模式掩码。 如果省略 \fImode\fP，则打印掩码的当前值。 \fB\-S\fP 选项使掩码以符号形式打印; 默认输出是一个八进制数。 如果提供
\fB\-p\fP 选项并省略 \fImode\fP，则输出的形式可以作为输入重复使用。 如果模式已成功更改或未提供 \fImode\fP 参数，则返回状态为 0，否则为
false。
.TP 
\fBunalias\fP [\-\fBa\fP] [\fIname\fP ...]
从定义的别名列表中删除每个 \fIname\fP。 如果提供 \fB\-a\fP，则删除所有别名定义。 除非提供的 \fIname\fP 不是定义的别名，否则返回值为真。
.TP 
\fBunset\fP [\-\fBfv\fP] [\-\fBn\fP] [\fIname\fP ...]
对于每个 \fIname\fP，删除相应的变量或函数。 如果给出了 \fB\-v\fP 选项，则每个 \fIname\fP 都引用一个 shell 变量，并且该变量被删除。
只读变量不能取消设置。 如果指定 \fB\-f\fP，则每个 \fIname\fP 引用一个 shell 函数，并且去除函数定义。 如果提供了 \fB\-n\fP 选项，并且
\fIname\fP 是具有 \fInameref\fP 属性的变量，则将取消设置 \fIname\fP 而不是变量 it 引用。 如果提供 \fB\-f\fP 选项，则
\fB\-n\fP 无效。 如果未提供任何选项，则每个 \fIname\fP 指的是一个变量; 如果没有该名称的变量，则取消设置具有该名称的函数 (如果有的话)。
每个未设置的变量或函数都从传递给后续命令的环境中删除。 If any of
.SM
\fBBASH_ALIASES\fP,
.SM
\fBBASH_ARGV0\fP,
.SM
\fBBASH_CMDS\fP,
.SM
\fBBASH_COMMAND\fP,
.SM
\fBBASH_SUBSHELL\fP,
.SM
\fBBASHPID\fP,
.SM
\fBCOMP_WORDBREAKS\fP,
.SM
\fBDIRSTACK\fP,
.SM
\fBEPOCHREALTIME\fP,
.SM
\fBEPOCHSECONDS\fP,
.SM
\fBFUNCNAME\fP,
.SM
\fBGROUPS\fP,
.SM
\fBHISTCMD\fP,
.SM
\fBLINENO\fP,
.SM
\fBRANDOM\fP,
.SM
\fBSECONDS\fP, 或
.SM
\fBSRANDOM\fP 未设置，它们将失去其特殊属性，即使它们随后被重置。
除非 \fIname\fP 是只读的，否则退出状态为真。
.TP 
\fBwait\fP [\fB\-fn\fP] [\fB\-p\fP \fIvarname\fP] [\fIid ...\fP]
等待每个指定的子进程并返回其终止状态。 每个 \fIid\fP 可能是一个进程 ID 或一个作业规范; 如果给出了作业规范，则等待该作业管道中的所有进程。
如果未给出 \fIid\fP，则 \fBwait\fP 等待所有正在运行的后台作业和最后执行的进程替换，如果其进程 ID 与 \fB$!\fP 相同，并且返回状态为零。
如果提供了 \fB\-n\fP 选项，则 \fBwait\fP 等待 \fIid\fPs 列表中的单个作业，或者如果没有提供
\fIid\fPs，则等待任何作业完成并返回其退出状态。 如果提供的参数都不是 shell 的子代，或者如果没有提供参数并且 shell
没有未等待的子代，则退出状态为 127。 如果提供了 \fB\-p\fP 选项，返回退出状态的作业的进程或作业标识符将分配给由选项参数命名的变量
\fIvarname\fP。 在任何赋值之前，变量最初将被取消设置。 这仅在提供 \fB\-n\fP 选项时有用。 提供 \fB\-f\fP 选项，当启用作业控制时，强制
\fBwait\fP 在返回其状态之前等待 \fIid\fP 终止，而不是在它更改状态时返回。 如果 \fIid\fP 指定了一个不存在的进程或作业，则返回状态为
127。 否则，返回状态是等待的最后一个进程或作业的退出状态。
.SH "SHELL COMPATIBILITY MODE"
Bash\-4.0 引入了 `shell 兼容级别` 的概念，指定为 shopt 内置
\fBcompat31\fP、\fBcompat32\fP、\fBcompat40\fP、\fBcompat41\fP 等的一组选项。 当前只有一个兼容级别 \-\-
每个选项都是互斥的。 兼容性级别旨在允许用户在迁移脚本以使用当前特性和行为时从与新版本不兼容的先前版本中选择行为。它旨在成为一个临时解决方案。
.PP
本节未提及特定版本的标准行为 (例如，设置 \fBcompat32\fP 意味着引用 regexp 匹配运算符的 rhs 会在单词中引用特殊的 regexp
字符，这是 bash\-3.2 及更高版本中的默认行为)。
.PP
如果用户启用 \fBcompat32\fP，它可能会影响其他兼容级别的行为，直至并包括当前兼容级别。 这个想法是每个兼容级别控制在该版本的 \fBbash\fP
中更改的行为，但该行为可能已经存在于早期版本中。 例如，在 bash\-4.1 中使用 \fB[[\fP 命令进行基于区域设置的比较，而早期版本使用基于
ASCII 的比较，因此启用 \fBcompat32\fP 也将启用基于 ASCII 的比较。 该粒度可能不足以满足所有用途，因此用户应谨慎使用兼容性级别。
阅读特定特性的文档以了解当前行为。
.PP
Bash\-4.3 引入了一个新的 shell 变量:
.SM
\fBBASH_COMPAT\fP。 分配给该变量的值 (如 4.2
的十进制版本号，或对应于 \fBcompat\fP\fINN\fP 选项的整数，如 42) 决定了兼容性级别。
.PP
从 bash\-4.4 开始，Bash 开始弃用旧的兼容性级别。 最终，这些选项将被删除，取而代之的是
.SM
\fBBASH_COMPAT\fP。
.PP
Bash\-5.0 是最终版本，之前的版本会有单独的 shopt 选项。用户应在 bash\-5.0 及更高版本上使用
.SM
\fBBASH_COMPAT\fP。
.PP
下表描述了由每个兼容级别设置控制的行为更改。 \fBcompat\fP\fINN\fP 标记用作使用以下机制之一将兼容级别设置为 \fINN\fP 的简写。 对于
bash\-5.0 之前的版本，可以使用相应的 \fBcompat\fP\fINN\fP shopt 选项设置兼容级别。 对于 bash\-4.3
及更高版本，
.SM
\fBBASH_COMPAT\fP 变量是首选，对于 bash\-5.1 及更高版本是必需的。
.TP 
\fBcompat31\fP
.PD 0
.RS
.IP \(bu
引用 \fB[[\fP 命令的正则表达式匹配运算符 (=~) 的 rhs 没有特殊效果
.RE
.PD
.TP 
\fBcompat32\fP
.PD 0
.RS
.IP \(bu
中断诸如 "a ; b ; c" 之类的命令列表会导致执行列表中的下一个命令 (在 bash\-4.0 及更高版本中，shell
的行为就好像它收到了中断一样，因此中断列表中的一个命令会中止整个列表的执行)
.RE
.PD
.TP 
\fBcompat40\fP
.PD 0
.RS
.IP \(bu
\fB<\fP 和 \fB>\fP 运算符到 \fB[[\fP 命令在比较字符串时不考虑当前语言环境; 他们使用 ASCII 排序。 bash\-4.1
之前的 Bash 版本使用 ASCII 整理和 \fIstrcmp\fP(3); bash\-4.1 及更高版本使用当前语言环境的归类序列和
\fIstrcoll\fP(3)。
.RE
.PD
.TP 
\fBcompat41\fP
.PD 0
.RS
.IP \(bu
在 \fIposix\fP 模式下，\fBtime\fP 后面可能跟选项，仍然被识别为保留字 (这是 POSIX 解释 267)
.IP \(bu
在 \fIposix\fP 模式下，解析器要求偶数个单引号出现在双引号参数扩展的 \fIword\fP 部分并对其进行特殊处理，以便单引号内的字符被认为是引号
(这是 POSIX 解释 221)
.RE
.PD
.TP 
\fBcompat42\fP
.PD 0
.RS
.IP \(bu
双引号模式替换中的替换字符串不会像 bash\-4.2 之后的版本那样进行引号删除
.IP \(bu
在 posix 模式下，在扩展双引号参数扩展的 \fIword\fP 部分时，单引号被认为是特殊的，可用于引用右大括号或其他特殊字符 (这是 POSIX 解释
221 的一部分) ; 在以后的版本中，单引号在双引号的单词扩展中并不特殊
.RE
.PD
.TP 
\fBcompat43\fP
.PD 0
.RS
.IP \(bu
如果尝试使用带引号的复合赋值作为参数来声明 (声明 \-a foo='(1 2)')，则 shell 不会打印警告消息。更高版本警告此用法已弃用
.IP \(bu
单词扩展错误被认为是导致当前命令失败的非致命错误，即使在 posix 模式下也是如此 (默认行为是使它们成为导致 shell 退出的致命错误)
.IP \(bu
当执行 shell 函数时，循环状态 (while/until/etc.) 不会被重置，因此该函数中的 \fBbreak\fP 或 \fBcontinue\fP
将在调用上下文中中断或继续循环。Bash\-4.4 及更高版本重置循环状态以防止这种情况
.RE
.PD
.TP 
\fBcompat44\fP
.PD 0
.RS
.IP \(bu
shell 设置
.SM
\fBBASH_ARGV\fP 和
.SM
\fBBASH_ARGC\fP
使用的值，因此即使未启用扩展调试模式，它们也可以扩展到 shell 的位置参数
.IP \(bu
子 shell 从其父上下文继承循环，因此 \fBbreak\fP 或 \fBcontinue\fP 将导致子 shell 退出。 Bash\-5.0
及以后的版本重置循环状态防止退出
.IP \(bu
即使 shell 未处于 posix 模式，设置属性的 \fBexport\fP 和 \fBreadonly\fP
等内置函数之前的变量赋值继续影响调用环境中具有相同名称的变量
.RE
.PD
.TP 
\fBcompat50\fP
.PD 0
.RS
.IP \(bu
Bash\-5.1 改变了
.SM
\fB$RANDOM\fP 的生成方式，引入了更多的随机性。如果 shell 兼容级别设置为 50 或更低，它将恢复为
bash\-5.0 和以前版本的方法，因此通过为
.SM
\fBRANDOM\fP 赋值来为随机数生成器播种将产生与 bash\-5.0 中相同的序列
.IP \(bu
如果命令哈希表为空，bash\-5.1 之前的 bash 版本会打印一条信息性消息，即使在生成可作为输入重复使用的输出时也是如此。当提供 \fB\-l\fP
选项时，Bash\-5.1 会抑制该消息。
.RE
.PD
.if  \n(zZ=1 .ig zZ
.\" bash_builtins
.SH "RESTRICTED SHELL"
.\" rbash.1
.zY
.PP
如果 \fBbash\fP 以名称 \fBrbash\fP 启动，或者在调用时提供了 \fB\-r\fP 选项，则 shell 会受到限制。 受限的 shell
用于设置比标准 shell 更受控制的环境。 它的行为与 \fBbash\fP 相同，但不允许或不执行以下操作:
.IP \(bu
使用 \fBcd\fP 更改目录
.IP \(bu
设置或取消设置
.SM
\fBSHELL\fP、
.SM
\fBPATH\fP、
.SM
\fBHISTFILE\fP、
.SM
\fBENV\fP 或
.SM
\fBBASH_ENV\fP 的值
.IP \(bu
指定包含 \fB/\fP 的命令名称
.IP \(bu
将包含 \fB/\fP 的文件名指定为 \fB.\fP 内置命令的参数
.IP \(bu
将包含斜杠的文件名指定为 \fBhistory\fP 内置命令的参数
.IP \(bu
将包含斜杠的文件名指定为 \fBhash\fP 内置命令的 \fB\-p\fP 选项的参数
.IP \(bu
在启动时从 shell 环境导入函数定义
.IP \(bu
启动时从 shell 环境解析
.SM
\fBSHELLOPTS\fP 的值
.IP \(bu
使用 >、>|、<>、>&、&> 和 >> 重定向输出重定向
.IP \(bu
使用 \fBexec\fP 内置命令将 shell 替换为另一个命令
.IP \(bu
使用 \fB\-f\fP 和 \fB\-d\fP 选项向 \fBenable\fP 内置命令添加或删除内置命令
.IP \(bu
使用 \fBenable\fP 内置命令启用禁用的 shell 内置命令
.IP \(bu
为 \fBcommand\fP 内置命令指定 \fB\-p\fP 选项
.IP \(bu
使用 \fBset +r\fP 或 \fBset +o restricted\fP 关闭受限模式。
.PP
这些限制在读取任何启动文件后强制执行。
.PP
.ie  \n(zY=1 When a command that is found to be a shell script is executed,
.el \{ When a command that is found to be a shell script is executed
(see
.SM
.B "COMMAND EXECUTION"
above),
\}
\fBrbash\fP 关闭 shell 产生的任何限制以执行脚本。
.if  \n(zY=1 .ig zY
.\" end of rbash.1
.SH "SEE ALSO"
.PD 0
.TP 
\fIBash Reference Manual\fP, Brian Fox and Chet Ramey
.TP 
\fIThe Gnu Readline Library\fP, Brian Fox and Chet Ramey
.TP 
\fIThe Gnu History Library\fP, Brian Fox and Chet Ramey
.TP 
\fIPortable Operating System Interface (POSIX) Part 2: Shell and Utilities\fP, IEEE \-\-
http://pubs.opengroup.org/onlinepubs/9699919799/
.TP 
http://tiswww.case.edu/~chet/bash/POSIX \-\- a description of posix mode
.TP 
\fIsh\fP(1), \fIksh\fP(1), \fIcsh\fP(1)
.TP 
\fIemacs\fP(1), \fIvi\fP(1)
.TP 
\fIreadline\fP(3)
.PD
.SH FILES
.PD 0
.TP 
.FN /bin/bash
\fBbash\fP 可执行文件
.TP 
.FN /etc/profile
系统范围的初始化文件，为登录 shells 执行
.TP 
.FN ~/.bash_profile
个人初始化文件，登录 shells 执行
.TP 
.FN ~/.bashrc
单独的 per\-interactive\-shell 启动文件
.TP 
.FN ~/.bash_logout
个人登录 shell 清理文件，当登录 shell 退出时执行
.TP 
.FN ~/.inputrc
个别 \fIreadline\fP 初始化文件
.PD
.SH AUTHORS
Brian Fox，自由软件基金会
.br
bfox@gnu.org
.PP
Chet Ramey，凯斯西储大学
.br
chet.ramey@case.edu
.SH "BUG REPORTS"
如果您在 \fBbash,\fP 中发现错误，您应该报告它。 但首先，您应该确定它确实是一个错误，并且它出现在最新版本的 \fBbash\fP 中。
\fIftp://ftp.gnu.org/pub/gnu/bash/\fP 始终提供最新版本。
.PP
一旦确定错误确实存在，请使用 \fIbashbug\fP 命令提交错误报告。 如果您有修复程序，我们也鼓励您邮寄它! 建议和 `哲学` 错误报告可以邮寄到
\fIbug\-bash@gnu.org\fP 或发布到 Usenet 新闻组 \fBgnu.bash.bug\fP。
.PP
所有错误报告应包括:
.PP
.PD 0
.TP  20
The version number of \fBbash\fP
.TP 
The hardware and operating system
.TP 
The compiler used to compile
.TP 
A description of the bug behaviour
.TP 
A short script or `recipe' which exercises the bug
.PD
.PP
\fIbashbug\fP 自动将前三个项插入到它提供的用于提交错误报告的模板中。
.PP
有关此手册页的评论和错误报告应提交给 \fIchet.ramey@case.edu\fP。
.SH BUGS
它太大而且太慢。
.PP
\fBbash\fP 与传统版本的 \fBsh\fP 之间存在一些细微差别，主要是因为
.SM
\fBPOSIX\fP 规范。
.PP
别名在某些用途中令人困惑。
.PP
Shell 内置命令和函数不是 stoppable/restartable。
.PP
下形式的复合命令和命令序列 `a ; b ; c' 当试图挂起进程时，没有得到妥善处理。 当进程停止时，shell 立即执行序列中的下一个命令。
将命令序列放在括号之间以强制将其放入子 shell 中就足够了，子 shell 可以作为元停止。
.PP
数组变量可能不会导出 (yet)。
.PP
一次可能只有一个活动协进程。
.zZ
.zY
.PP
.SH [手册页中文版]
.PP
本翻译为免费文档；阅读
.UR https://www.gnu.org/licenses/gpl-3.0.html
GNU 通用公共许可证第 3 版
.UE
或稍后的版权条款。因使用该翻译而造成的任何问题和损失完全由您承担。
.PP
该中文翻译由 wtklbm
.B <wtklbm@gmail.com>
根据个人学习需要制作。
.PP
项目地址:
.UR \fBhttps://github.com/wtklbm/manpages-chinese\fR
.ME 。
